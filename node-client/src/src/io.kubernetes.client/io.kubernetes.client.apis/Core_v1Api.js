/**
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.10.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import V1APIResourceList from '../io.kubernetes.client.models/V1APIResourceList';
import V1Binding from '../io.kubernetes.client.models/V1Binding';
import V1ComponentStatus from '../io.kubernetes.client.models/V1ComponentStatus';
import V1ComponentStatusList from '../io.kubernetes.client.models/V1ComponentStatusList';
import V1ConfigMap from '../io.kubernetes.client.models/V1ConfigMap';
import V1ConfigMapList from '../io.kubernetes.client.models/V1ConfigMapList';
import V1DeleteOptions from '../io.kubernetes.client.models/V1DeleteOptions';
import V1Endpoints from '../io.kubernetes.client.models/V1Endpoints';
import V1EndpointsList from '../io.kubernetes.client.models/V1EndpointsList';
import V1Event from '../io.kubernetes.client.models/V1Event';
import V1EventList from '../io.kubernetes.client.models/V1EventList';
import V1LimitRange from '../io.kubernetes.client.models/V1LimitRange';
import V1LimitRangeList from '../io.kubernetes.client.models/V1LimitRangeList';
import V1Namespace from '../io.kubernetes.client.models/V1Namespace';
import V1NamespaceList from '../io.kubernetes.client.models/V1NamespaceList';
import V1Node from '../io.kubernetes.client.models/V1Node';
import V1NodeList from '../io.kubernetes.client.models/V1NodeList';
import V1PersistentVolume from '../io.kubernetes.client.models/V1PersistentVolume';
import V1PersistentVolumeClaim from '../io.kubernetes.client.models/V1PersistentVolumeClaim';
import V1PersistentVolumeClaimList from '../io.kubernetes.client.models/V1PersistentVolumeClaimList';
import V1PersistentVolumeList from '../io.kubernetes.client.models/V1PersistentVolumeList';
import V1Pod from '../io.kubernetes.client.models/V1Pod';
import V1PodList from '../io.kubernetes.client.models/V1PodList';
import V1PodTemplate from '../io.kubernetes.client.models/V1PodTemplate';
import V1PodTemplateList from '../io.kubernetes.client.models/V1PodTemplateList';
import V1ReplicationController from '../io.kubernetes.client.models/V1ReplicationController';
import V1ReplicationControllerList from '../io.kubernetes.client.models/V1ReplicationControllerList';
import V1ResourceQuota from '../io.kubernetes.client.models/V1ResourceQuota';
import V1ResourceQuotaList from '../io.kubernetes.client.models/V1ResourceQuotaList';
import V1Scale from '../io.kubernetes.client.models/V1Scale';
import V1Secret from '../io.kubernetes.client.models/V1Secret';
import V1SecretList from '../io.kubernetes.client.models/V1SecretList';
import V1Service from '../io.kubernetes.client.models/V1Service';
import V1ServiceAccount from '../io.kubernetes.client.models/V1ServiceAccount';
import V1ServiceAccountList from '../io.kubernetes.client.models/V1ServiceAccountList';
import V1ServiceList from '../io.kubernetes.client.models/V1ServiceList';
import V1Status from '../io.kubernetes.client.models/V1Status';
import V1beta1Eviction from '../io.kubernetes.client.models/V1beta1Eviction';

/**
* Core_v1 service.
* @module io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api
* @version 0.3-SNAPSHOT
*/
export default class Core_v1Api {

    /**
    * Constructs a new Core_v1Api. 
    * @alias module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api
    * @class
    * @param {module:io.kubernetes.client/ApiClient} apiClient Optional API client implementation to use,
    * default to {@link module:io.kubernetes.client/ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the connectDeleteNamespacedPodProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectDeleteNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectDeleteNamespacedPodProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectDeleteNamespacedPodProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectDeleteNamespacedPodProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectDeleteNamespacedPodProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectDeleteNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectDeleteNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectDeleteNamespacedPodProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectDeleteNamespacedServiceProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectDeleteNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectDeleteNamespacedServiceProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectDeleteNamespacedServiceProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectDeleteNamespacedServiceProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectDeleteNamespacedServiceProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectDeleteNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectDeleteNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectDeleteNamespacedServiceProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectDeleteNodeProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectDeleteNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectDeleteNodeProxy");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectDeleteNodeProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Node
     * @param {String} name name of the Node
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectDeleteNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectDeleteNodeProxyWithPath(name, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectDeleteNodeProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectDeleteNodeProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectGetNamespacedPodAttach operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedPodAttachCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to attach of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.container The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param {Boolean} opts.stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @param {Boolean} opts.stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @param {Boolean} opts.stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @param {Boolean} opts.tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedPodAttachCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectGetNamespacedPodAttach(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectGetNamespacedPodAttach");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectGetNamespacedPodAttach");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'container': opts['container'],
        'stderr': opts['stderr'],
        'stdin': opts['stdin'],
        'stdout': opts['stdout'],
        'tty': opts['tty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/attach', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectGetNamespacedPodExec operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedPodExecCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to exec of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.command Command is the remote command to execute. argv array. Not executed within a shell.
     * @param {String} opts.container Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param {Boolean} opts.stderr Redirect the standard error stream of the pod for this call. Defaults to true.
     * @param {Boolean} opts.stdin Redirect the standard input stream of the pod for this call. Defaults to false.
     * @param {Boolean} opts.stdout Redirect the standard output stream of the pod for this call. Defaults to true.
     * @param {Boolean} opts.tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedPodExecCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectGetNamespacedPodExec(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectGetNamespacedPodExec");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectGetNamespacedPodExec");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'command': opts['command'],
        'container': opts['container'],
        'stderr': opts['stderr'],
        'stdin': opts['stdin'],
        'stdout': opts['stdout'],
        'tty': opts['tty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/exec', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectGetNamespacedPodPortforward operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedPodPortforwardCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to portforward of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Number} opts.ports List of ports to forward Required when using WebSockets
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedPodPortforwardCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectGetNamespacedPodPortforward(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectGetNamespacedPodPortforward");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectGetNamespacedPodPortforward");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'ports': opts['ports']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/portforward', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectGetNamespacedPodProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectGetNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectGetNamespacedPodProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectGetNamespacedPodProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectGetNamespacedPodProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectGetNamespacedPodProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectGetNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectGetNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectGetNamespacedPodProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectGetNamespacedServiceProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectGetNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectGetNamespacedServiceProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectGetNamespacedServiceProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectGetNamespacedServiceProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectGetNamespacedServiceProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectGetNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectGetNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectGetNamespacedServiceProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectGetNodeProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectGetNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectGetNodeProxy");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectGetNodeProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Node
     * @param {String} name name of the Node
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectGetNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectGetNodeProxyWithPath(name, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectGetNodeProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectGetNodeProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectHeadNamespacedPodProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectHeadNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectHeadNamespacedPodProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectHeadNamespacedPodProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectHeadNamespacedPodProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectHeadNamespacedPodProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectHeadNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectHeadNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectHeadNamespacedPodProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectHeadNamespacedServiceProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectHeadNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectHeadNamespacedServiceProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectHeadNamespacedServiceProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectHeadNamespacedServiceProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectHeadNamespacedServiceProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectHeadNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectHeadNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectHeadNamespacedServiceProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectHeadNodeProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectHeadNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectHeadNodeProxy");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectHeadNodeProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Node
     * @param {String} name name of the Node
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectHeadNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectHeadNodeProxyWithPath(name, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectHeadNodeProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectHeadNodeProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectOptionsNamespacedPodProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectOptionsNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectOptionsNamespacedPodProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectOptionsNamespacedPodProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectOptionsNamespacedPodProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectOptionsNamespacedPodProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectOptionsNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectOptionsNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectOptionsNamespacedPodProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectOptionsNamespacedServiceProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectOptionsNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectOptionsNamespacedServiceProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectOptionsNamespacedServiceProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectOptionsNamespacedServiceProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectOptionsNamespacedServiceProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectOptionsNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectOptionsNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectOptionsNamespacedServiceProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectOptionsNodeProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectOptionsNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectOptionsNodeProxy");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectOptionsNodeProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Node
     * @param {String} name name of the Node
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectOptionsNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectOptionsNodeProxyWithPath(name, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectOptionsNodeProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectOptionsNodeProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPatchNamespacedPodProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPatchNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPatchNamespacedPodProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPatchNamespacedPodProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPatchNamespacedPodProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPatchNamespacedPodProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPatchNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPatchNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectPatchNamespacedPodProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPatchNamespacedServiceProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPatchNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPatchNamespacedServiceProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPatchNamespacedServiceProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPatchNamespacedServiceProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPatchNamespacedServiceProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPatchNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPatchNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectPatchNamespacedServiceProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPatchNodeProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPatchNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPatchNodeProxy");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPatchNodeProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Node
     * @param {String} name name of the Node
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPatchNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPatchNodeProxyWithPath(name, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPatchNodeProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectPatchNodeProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPostNamespacedPodAttach operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedPodAttachCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to attach of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.container The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param {Boolean} opts.stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @param {Boolean} opts.stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @param {Boolean} opts.stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @param {Boolean} opts.tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedPodAttachCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPostNamespacedPodAttach(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPostNamespacedPodAttach");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPostNamespacedPodAttach");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'container': opts['container'],
        'stderr': opts['stderr'],
        'stdin': opts['stdin'],
        'stdout': opts['stdout'],
        'tty': opts['tty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/attach', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPostNamespacedPodExec operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedPodExecCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to exec of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.command Command is the remote command to execute. argv array. Not executed within a shell.
     * @param {String} opts.container Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param {Boolean} opts.stderr Redirect the standard error stream of the pod for this call. Defaults to true.
     * @param {Boolean} opts.stdin Redirect the standard input stream of the pod for this call. Defaults to false.
     * @param {Boolean} opts.stdout Redirect the standard output stream of the pod for this call. Defaults to true.
     * @param {Boolean} opts.tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedPodExecCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPostNamespacedPodExec(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPostNamespacedPodExec");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPostNamespacedPodExec");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'command': opts['command'],
        'container': opts['container'],
        'stderr': opts['stderr'],
        'stdin': opts['stdin'],
        'stdout': opts['stdout'],
        'tty': opts['tty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/exec', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPostNamespacedPodPortforward operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedPodPortforwardCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to portforward of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Number} opts.ports List of ports to forward Required when using WebSockets
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedPodPortforwardCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPostNamespacedPodPortforward(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPostNamespacedPodPortforward");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPostNamespacedPodPortforward");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'ports': opts['ports']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/portforward', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPostNamespacedPodProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPostNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPostNamespacedPodProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPostNamespacedPodProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPostNamespacedPodProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPostNamespacedPodProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPostNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPostNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectPostNamespacedPodProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPostNamespacedServiceProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPostNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPostNamespacedServiceProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPostNamespacedServiceProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPostNamespacedServiceProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPostNamespacedServiceProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPostNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPostNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectPostNamespacedServiceProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPostNodeProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPostNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPostNodeProxy");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPostNodeProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Node
     * @param {String} name name of the Node
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPostNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPostNodeProxyWithPath(name, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPostNodeProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectPostNodeProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPutNamespacedPodProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPutNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPutNamespacedPodProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPutNamespacedPodProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPutNamespacedPodProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to pod.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPutNamespacedPodProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPutNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPutNamespacedPodProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectPutNamespacedPodProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPutNamespacedServiceProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPutNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPutNamespacedServiceProxy");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPutNamespacedServiceProxy");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPutNamespacedServiceProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPutNamespacedServiceProxyWithPath(name, namespace, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPutNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectPutNamespacedServiceProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectPutNamespacedServiceProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPutNodeProxy operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPutNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPutNodeProxy");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the connectPutNodeProxyWithPath operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Node
     * @param {String} name name of the Node
     * @param {String} path path to the resource
     * @param {Object} opts Optional parameters
     * @param {String} opts.path2 Path is the URL path to use for the current proxy request to node.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~connectPutNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    connectPutNodeProxyWithPath(name, path, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectPutNodeProxyWithPath");
      }

      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling connectPutNodeProxyWithPath");
      }


      let pathParams = {
        'name': name,
        'path': path
      };
      let queryParams = {
        'path': opts['path2']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['*/*'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespace operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Namespace
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace}
     */
    createNamespace(body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespace");
      }


      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Namespace;

      return this.apiClient.callApi(
        '/api/v1/namespaces', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedBinding operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedBindingCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Binding} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Binding
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Binding} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedBindingCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Binding}
     */
    createNamespacedBinding(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedBinding");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedBinding");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Binding;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/bindings', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedConfigMap operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMap} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMap} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMap}
     */
    createNamespacedConfigMap(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedConfigMap");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedConfigMap");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ConfigMap;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedEndpoints operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Endpoints} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Endpoints} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Endpoints}
     */
    createNamespacedEndpoints(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedEndpoints");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedEndpoints");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Endpoints;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedEvent operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Event} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create an Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Event} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Event}
     */
    createNamespacedEvent(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedEvent");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedEvent");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Event;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedLimitRange operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRange} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRange} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRange}
     */
    createNamespacedLimitRange(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedLimitRange");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedLimitRange");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1LimitRange;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedPersistentVolumeClaim operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim}
     */
    createNamespacedPersistentVolumeClaim(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedPersistentVolumeClaim");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedPersistentVolumeClaim");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolumeClaim;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedPod operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Pod} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Pod}
     */
    createNamespacedPod(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedPod");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedPod");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Pod;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedPodBinding operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedPodBindingCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Binding} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create binding of a Pod
     * @param {String} name name of the Binding
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Binding} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedPodBindingCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Binding}
     */
    createNamespacedPodBinding(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling createNamespacedPodBinding");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedPodBinding");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedPodBinding");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Binding;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/binding', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedPodEviction operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedPodEvictionCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1beta1Eviction} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create eviction of a Pod
     * @param {String} name name of the Eviction
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1beta1Eviction} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedPodEvictionCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1beta1Eviction}
     */
    createNamespacedPodEviction(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling createNamespacedPodEviction");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedPodEviction");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedPodEviction");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1beta1Eviction;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/eviction', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedPodTemplate operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplate} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplate} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplate}
     */
    createNamespacedPodTemplate(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedPodTemplate");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedPodTemplate");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PodTemplate;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedReplicationController operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController}
     */
    createNamespacedReplicationController(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedReplicationController");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedReplicationController");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ReplicationController;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedResourceQuota operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota}
     */
    createNamespacedResourceQuota(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedResourceQuota");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedResourceQuota");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ResourceQuota;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedSecret operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Secret} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Secret} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Secret}
     */
    createNamespacedSecret(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedSecret");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedSecret");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Secret;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedService operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Service} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Service}
     */
    createNamespacedService(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedService");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedService");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Service;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNamespacedServiceAccount operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccount} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccount} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccount}
     */
    createNamespacedServiceAccount(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createNamespacedServiceAccount");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNamespacedServiceAccount");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ServiceAccount;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createNode operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNodeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Node
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Node} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createNodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Node}
     */
    createNode(body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createNode");
      }


      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Node;

      return this.apiClient.callApi(
        '/api/v1/nodes', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createPersistentVolume operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createPersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a PersistentVolume
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~createPersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume}
     */
    createPersistentVolume(body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createPersistentVolume");
      }


      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolume;

      return this.apiClient.callApi(
        '/api/v1/persistentvolumes', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNamespacedConfigMap operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNamespacedConfigMap(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCollectionNamespacedConfigMap");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNamespacedEndpoints operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNamespacedEndpoints(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCollectionNamespacedEndpoints");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNamespacedEvent operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNamespacedEvent(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCollectionNamespacedEvent");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNamespacedLimitRange operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNamespacedLimitRange(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCollectionNamespacedLimitRange");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNamespacedPersistentVolumeClaim operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNamespacedPersistentVolumeClaim(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCollectionNamespacedPersistentVolumeClaim");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNamespacedPod operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNamespacedPod(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCollectionNamespacedPod");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNamespacedPodTemplate operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNamespacedPodTemplate(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCollectionNamespacedPodTemplate");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNamespacedReplicationController operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNamespacedReplicationController(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCollectionNamespacedReplicationController");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNamespacedResourceQuota operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNamespacedResourceQuota(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCollectionNamespacedResourceQuota");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNamespacedSecret operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNamespacedSecret(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCollectionNamespacedSecret");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNamespacedServiceAccount operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNamespacedServiceAccount(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCollectionNamespacedServiceAccount");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionNode operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNodeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of Node
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionNodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionNode(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/nodes', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCollectionPersistentVolume operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionPersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of PersistentVolume
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteCollectionPersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteCollectionPersistentVolume(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/persistentvolumes', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespace operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a Namespace
     * @param {String} name name of the Namespace
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespace(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespace");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespace");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedConfigMap operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a ConfigMap
     * @param {String} name name of the ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedConfigMap(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedConfigMap");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedConfigMap");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedConfigMap");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedEndpoints operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete Endpoints
     * @param {String} name name of the Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedEndpoints(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedEndpoints");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedEndpoints");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedEndpoints");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedEvent operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete an Event
     * @param {String} name name of the Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedEvent(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedEvent");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedEvent");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedEvent");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedLimitRange operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a LimitRange
     * @param {String} name name of the LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedLimitRange(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedLimitRange");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedLimitRange");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedLimitRange");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedPersistentVolumeClaim operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedPersistentVolumeClaim(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedPersistentVolumeClaim");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedPersistentVolumeClaim");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedPersistentVolumeClaim");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedPod operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedPod(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedPod");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedPod");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedPod");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedPodTemplate operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a PodTemplate
     * @param {String} name name of the PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedPodTemplate(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedPodTemplate");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedPodTemplate");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedPodTemplate");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedReplicationController operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedReplicationController(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedReplicationController");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedReplicationController");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedReplicationController");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedResourceQuota operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedResourceQuota(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedResourceQuota");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedResourceQuota");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedResourceQuota");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedSecret operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a Secret
     * @param {String} name name of the Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedSecret(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedSecret");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedSecret");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedSecret");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedService operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedService(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedService");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedService");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedService");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNamespacedServiceAccount operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a ServiceAccount
     * @param {String} name name of the ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNamespacedServiceAccount(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNamespacedServiceAccount");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteNamespacedServiceAccount");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNamespacedServiceAccount");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteNode operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNodeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a Node
     * @param {String} name name of the Node
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deleteNodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deleteNode(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteNode");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteNode");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the deletePersistentVolume operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deletePersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1DeleteOptions} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Number} opts.gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} opts.orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} opts.propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~deletePersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Status}
     */
    deletePersistentVolume(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deletePersistentVolume");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deletePersistentVolume");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Status;

      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the getAPIResources operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~getAPIResourcesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1APIResourceList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * get available resources
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~getAPIResourcesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1APIResourceList}
     */
    getAPIResources(callback) {
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1APIResourceList;

      return this.apiClient.callApi(
        '/api/v1/', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listComponentStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listComponentStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ComponentStatusList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list objects of kind ComponentStatus
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listComponentStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ComponentStatusList}
     */
    listComponentStatus(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1ComponentStatusList;

      return this.apiClient.callApi(
        '/api/v1/componentstatuses', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listConfigMapForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listConfigMapForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMapList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ConfigMap
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listConfigMapForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMapList}
     */
    listConfigMapForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1ConfigMapList;

      return this.apiClient.callApi(
        '/api/v1/configmaps', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listEndpointsForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listEndpointsForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1EndpointsList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Endpoints
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listEndpointsForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1EndpointsList}
     */
    listEndpointsForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1EndpointsList;

      return this.apiClient.callApi(
        '/api/v1/endpoints', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listEventForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listEventForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1EventList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Event
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listEventForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1EventList}
     */
    listEventForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1EventList;

      return this.apiClient.callApi(
        '/api/v1/events', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listLimitRangeForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listLimitRangeForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRangeList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind LimitRange
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listLimitRangeForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRangeList}
     */
    listLimitRangeForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1LimitRangeList;

      return this.apiClient.callApi(
        '/api/v1/limitranges', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespace operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1NamespaceList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Namespace
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1NamespaceList}
     */
    listNamespace(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1NamespaceList;

      return this.apiClient.callApi(
        '/api/v1/namespaces', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedConfigMap operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMapList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMapList}
     */
    listNamespacedConfigMap(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedConfigMap");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1ConfigMapList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedEndpoints operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1EndpointsList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1EndpointsList}
     */
    listNamespacedEndpoints(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedEndpoints");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1EndpointsList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedEvent operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1EventList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1EventList}
     */
    listNamespacedEvent(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedEvent");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1EventList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedLimitRange operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRangeList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRangeList}
     */
    listNamespacedLimitRange(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedLimitRange");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1LimitRangeList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedPersistentVolumeClaim operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaimList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaimList}
     */
    listNamespacedPersistentVolumeClaim(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedPersistentVolumeClaim");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1PersistentVolumeClaimList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedPod operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PodList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PodList}
     */
    listNamespacedPod(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedPod");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1PodList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedPodTemplate operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplateList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplateList}
     */
    listNamespacedPodTemplate(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedPodTemplate");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1PodTemplateList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedReplicationController operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationControllerList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationControllerList}
     */
    listNamespacedReplicationController(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedReplicationController");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1ReplicationControllerList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedResourceQuota operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuotaList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuotaList}
     */
    listNamespacedResourceQuota(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedResourceQuota");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1ResourceQuotaList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedSecret operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1SecretList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1SecretList}
     */
    listNamespacedSecret(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedSecret");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1SecretList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedService operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceList}
     */
    listNamespacedService(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedService");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1ServiceList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNamespacedServiceAccount operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccountList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccountList}
     */
    listNamespacedServiceAccount(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listNamespacedServiceAccount");
      }


      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1ServiceAccountList;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listNode operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNodeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1NodeList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Node
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listNodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1NodeList}
     */
    listNode(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1NodeList;

      return this.apiClient.callApi(
        '/api/v1/nodes', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listPersistentVolume operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listPersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind PersistentVolume
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listPersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeList}
     */
    listPersistentVolume(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1PersistentVolumeList;

      return this.apiClient.callApi(
        '/api/v1/persistentvolumes', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listPersistentVolumeClaimForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listPersistentVolumeClaimForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaimList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listPersistentVolumeClaimForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaimList}
     */
    listPersistentVolumeClaimForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1PersistentVolumeClaimList;

      return this.apiClient.callApi(
        '/api/v1/persistentvolumeclaims', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listPodForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listPodForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PodList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Pod
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listPodForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PodList}
     */
    listPodForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1PodList;

      return this.apiClient.callApi(
        '/api/v1/pods', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listPodTemplateForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listPodTemplateForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplateList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind PodTemplate
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listPodTemplateForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplateList}
     */
    listPodTemplateForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1PodTemplateList;

      return this.apiClient.callApi(
        '/api/v1/podtemplates', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listReplicationControllerForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listReplicationControllerForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationControllerList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ReplicationController
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listReplicationControllerForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationControllerList}
     */
    listReplicationControllerForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1ReplicationControllerList;

      return this.apiClient.callApi(
        '/api/v1/replicationcontrollers', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listResourceQuotaForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listResourceQuotaForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuotaList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ResourceQuota
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listResourceQuotaForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuotaList}
     */
    listResourceQuotaForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1ResourceQuotaList;

      return this.apiClient.callApi(
        '/api/v1/resourcequotas', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listSecretForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listSecretForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1SecretList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Secret
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listSecretForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1SecretList}
     */
    listSecretForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1SecretList;

      return this.apiClient.callApi(
        '/api/v1/secrets', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listServiceAccountForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listServiceAccountForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccountList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ServiceAccount
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listServiceAccountForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccountList}
     */
    listServiceAccountForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1ServiceAccountList;

      return this.apiClient.callApi(
        '/api/v1/serviceaccounts', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listServiceForAllNamespaces operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listServiceForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Service
     * @param {Object} opts Optional parameters
     * @param {String} opts._continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} opts.fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Boolean} opts.includeUninitialized If true, partially initialized resources are included in the response.
     * @param {String} opts.labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} opts.limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {String} opts.resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {Number} opts.timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} opts.watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~listServiceForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceList}
     */
    listServiceForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'includeUninitialized': opts['includeUninitialized'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = V1ServiceList;

      return this.apiClient.callApi(
        '/api/v1/services', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespace operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Namespace
     * @param {String} name name of the Namespace
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace}
     */
    patchNamespace(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespace");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespace");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Namespace;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespaceStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespaceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified Namespace
     * @param {String} name name of the Namespace
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespaceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace}
     */
    patchNamespaceStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespaceStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespaceStatus");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Namespace;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedConfigMap operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMap} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified ConfigMap
     * @param {String} name name of the ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMap}
     */
    patchNamespacedConfigMap(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedConfigMap");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedConfigMap");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedConfigMap");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ConfigMap;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedEndpoints operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Endpoints} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Endpoints
     * @param {String} name name of the Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Endpoints}
     */
    patchNamespacedEndpoints(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedEndpoints");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedEndpoints");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedEndpoints");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Endpoints;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedEvent operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Event} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Event
     * @param {String} name name of the Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Event}
     */
    patchNamespacedEvent(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedEvent");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedEvent");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedEvent");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Event;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedLimitRange operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRange} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified LimitRange
     * @param {String} name name of the LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRange}
     */
    patchNamespacedLimitRange(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedLimitRange");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedLimitRange");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedLimitRange");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1LimitRange;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedPersistentVolumeClaim operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim}
     */
    patchNamespacedPersistentVolumeClaim(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedPersistentVolumeClaim");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedPersistentVolumeClaim");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedPersistentVolumeClaim");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolumeClaim;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedPersistentVolumeClaimStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedPersistentVolumeClaimStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedPersistentVolumeClaimStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim}
     */
    patchNamespacedPersistentVolumeClaimStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedPersistentVolumeClaimStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedPersistentVolumeClaimStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedPersistentVolumeClaimStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolumeClaim;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedPod operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Pod}
     */
    patchNamespacedPod(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedPod");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedPod");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedPod");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Pod;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedPodStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedPodStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedPodStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Pod}
     */
    patchNamespacedPodStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedPodStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedPodStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedPodStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Pod;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedPodTemplate operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplate} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified PodTemplate
     * @param {String} name name of the PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplate}
     */
    patchNamespacedPodTemplate(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedPodTemplate");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedPodTemplate");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedPodTemplate");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PodTemplate;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedReplicationController operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController}
     */
    patchNamespacedReplicationController(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedReplicationController");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedReplicationController");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedReplicationController");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ReplicationController;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedReplicationControllerScale operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedReplicationControllerScaleCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Scale} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update scale of the specified ReplicationController
     * @param {String} name name of the Scale
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedReplicationControllerScaleCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Scale}
     */
    patchNamespacedReplicationControllerScale(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedReplicationControllerScale");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedReplicationControllerScale");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedReplicationControllerScale");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Scale;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedReplicationControllerStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedReplicationControllerStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedReplicationControllerStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController}
     */
    patchNamespacedReplicationControllerStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedReplicationControllerStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedReplicationControllerStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedReplicationControllerStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ReplicationController;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedResourceQuota operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota}
     */
    patchNamespacedResourceQuota(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedResourceQuota");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedResourceQuota");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedResourceQuota");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ResourceQuota;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedResourceQuotaStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedResourceQuotaStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedResourceQuotaStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota}
     */
    patchNamespacedResourceQuotaStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedResourceQuotaStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedResourceQuotaStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedResourceQuotaStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ResourceQuota;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedSecret operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Secret} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Secret
     * @param {String} name name of the Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Secret}
     */
    patchNamespacedSecret(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedSecret");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedSecret");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedSecret");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Secret;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedService operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Service}
     */
    patchNamespacedService(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedService");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedService");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedService");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Service;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedServiceAccount operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccount} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified ServiceAccount
     * @param {String} name name of the ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccount}
     */
    patchNamespacedServiceAccount(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedServiceAccount");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedServiceAccount");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedServiceAccount");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ServiceAccount;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNamespacedServiceStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedServiceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNamespacedServiceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Service}
     */
    patchNamespacedServiceStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNamespacedServiceStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchNamespacedServiceStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNamespacedServiceStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Service;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNode operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNodeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Node
     * @param {String} name name of the Node
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Node}
     */
    patchNode(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNode");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNode");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Node;

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchNodeStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNodeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified Node
     * @param {String} name name of the Node
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchNodeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Node}
     */
    patchNodeStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchNodeStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchNodeStatus");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Node;

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchPersistentVolume operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchPersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchPersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume}
     */
    patchPersistentVolume(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchPersistentVolume");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchPersistentVolume");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolume;

      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the patchPersistentVolumeStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchPersistentVolumeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~patchPersistentVolumeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume}
     */
    patchPersistentVolumeStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchPersistentVolumeStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchPersistentVolumeStatus");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolume;

      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readComponentStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readComponentStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ComponentStatus} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified ComponentStatus
     * @param {String} name name of the ComponentStatus
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readComponentStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ComponentStatus}
     */
    readComponentStatus(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readComponentStatus");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ComponentStatus;

      return this.apiClient.callApi(
        '/api/v1/componentstatuses/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespace operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Namespace
     * @param {String} name name of the Namespace
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace}
     */
    readNamespace(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespace");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Namespace;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespaceStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespaceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified Namespace
     * @param {String} name name of the Namespace
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespaceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace}
     */
    readNamespaceStatus(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespaceStatus");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Namespace;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedConfigMap operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMap} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified ConfigMap
     * @param {String} name name of the ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMap}
     */
    readNamespacedConfigMap(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedConfigMap");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedConfigMap");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ConfigMap;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedEndpoints operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Endpoints} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Endpoints
     * @param {String} name name of the Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Endpoints}
     */
    readNamespacedEndpoints(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedEndpoints");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedEndpoints");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Endpoints;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedEvent operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Event} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Event
     * @param {String} name name of the Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Event}
     */
    readNamespacedEvent(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedEvent");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedEvent");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Event;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedLimitRange operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRange} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified LimitRange
     * @param {String} name name of the LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRange}
     */
    readNamespacedLimitRange(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedLimitRange");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedLimitRange");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1LimitRange;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedPersistentVolumeClaim operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim}
     */
    readNamespacedPersistentVolumeClaim(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedPersistentVolumeClaim");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedPersistentVolumeClaim");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolumeClaim;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedPersistentVolumeClaimStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPersistentVolumeClaimStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPersistentVolumeClaimStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim}
     */
    readNamespacedPersistentVolumeClaimStatus(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedPersistentVolumeClaimStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedPersistentVolumeClaimStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolumeClaim;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedPod operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Pod}
     */
    readNamespacedPod(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedPod");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedPod");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Pod;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedPodLog operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPodLogCallback
     * @param {String} error Error message, if any.
     * @param {'String'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read log of the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.container The container for which to stream logs. Defaults to only container if there is one container in the pod.
     * @param {Boolean} opts.follow Follow the log stream of the pod. Defaults to false.
     * @param {Number} opts.limitBytes If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.previous Return previous terminated container logs. Defaults to false.
     * @param {Number} opts.sinceSeconds A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
     * @param {Number} opts.tailLines If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
     * @param {Boolean} opts.timestamps If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPodLogCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'String'}
     */
    readNamespacedPodLog(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedPodLog");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedPodLog");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'container': opts['container'],
        'follow': opts['follow'],
        'limitBytes': opts['limitBytes'],
        'pretty': opts['pretty'],
        'previous': opts['previous'],
        'sinceSeconds': opts['sinceSeconds'],
        'tailLines': opts['tailLines'],
        'timestamps': opts['timestamps']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['text/plain', 'application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = 'String';

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/log', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedPodStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPodStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPodStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Pod}
     */
    readNamespacedPodStatus(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedPodStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedPodStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Pod;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedPodTemplate operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplate} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified PodTemplate
     * @param {String} name name of the PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplate}
     */
    readNamespacedPodTemplate(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedPodTemplate");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedPodTemplate");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PodTemplate;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedReplicationController operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController}
     */
    readNamespacedReplicationController(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedReplicationController");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedReplicationController");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ReplicationController;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedReplicationControllerScale operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedReplicationControllerScaleCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Scale} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read scale of the specified ReplicationController
     * @param {String} name name of the Scale
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedReplicationControllerScaleCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Scale}
     */
    readNamespacedReplicationControllerScale(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedReplicationControllerScale");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedReplicationControllerScale");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Scale;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedReplicationControllerStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedReplicationControllerStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedReplicationControllerStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController}
     */
    readNamespacedReplicationControllerStatus(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedReplicationControllerStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedReplicationControllerStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ReplicationController;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedResourceQuota operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota}
     */
    readNamespacedResourceQuota(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedResourceQuota");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedResourceQuota");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ResourceQuota;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedResourceQuotaStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedResourceQuotaStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedResourceQuotaStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota}
     */
    readNamespacedResourceQuotaStatus(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedResourceQuotaStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedResourceQuotaStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ResourceQuota;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedSecret operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Secret} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Secret
     * @param {String} name name of the Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Secret}
     */
    readNamespacedSecret(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedSecret");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedSecret");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Secret;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedService operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Service}
     */
    readNamespacedService(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedService");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedService");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Service;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedServiceAccount operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccount} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified ServiceAccount
     * @param {String} name name of the ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccount}
     */
    readNamespacedServiceAccount(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedServiceAccount");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedServiceAccount");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ServiceAccount;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNamespacedServiceStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedServiceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNamespacedServiceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Service}
     */
    readNamespacedServiceStatus(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNamespacedServiceStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readNamespacedServiceStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Service;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNode operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNodeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Node}
     */
    readNode(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNode");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Node;

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readNodeStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNodeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readNodeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Node}
     */
    readNodeStatus(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readNodeStatus");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Node;

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readPersistentVolume operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readPersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {Boolean} opts.exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param {Boolean} opts._export Should this value be exported.  Export strips fields that a user can not specify.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readPersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume}
     */
    readPersistentVolume(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readPersistentVolume");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'exact': opts['exact'],
        'export': opts['_export']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolume;

      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the readPersistentVolumeStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readPersistentVolumeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~readPersistentVolumeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume}
     */
    readPersistentVolumeStatus(name, opts, callback) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readPersistentVolumeStatus");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolume;

      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespace operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Namespace
     * @param {String} name name of the Namespace
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace}
     */
    replaceNamespace(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespace");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespace");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Namespace;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespaceFinalize operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespaceFinalizeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace finalize of the specified Namespace
     * @param {String} name name of the Namespace
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespaceFinalizeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace}
     */
    replaceNamespaceFinalize(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespaceFinalize");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespaceFinalize");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Namespace;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}/finalize', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespaceStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespaceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified Namespace
     * @param {String} name name of the Namespace
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespaceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Namespace}
     */
    replaceNamespaceStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespaceStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespaceStatus");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Namespace;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedConfigMap operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMap} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified ConfigMap
     * @param {String} name name of the ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMap} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ConfigMap}
     */
    replaceNamespacedConfigMap(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedConfigMap");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedConfigMap");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedConfigMap");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ConfigMap;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedEndpoints operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Endpoints} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Endpoints
     * @param {String} name name of the Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Endpoints} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Endpoints}
     */
    replaceNamespacedEndpoints(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedEndpoints");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedEndpoints");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedEndpoints");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Endpoints;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedEvent operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Event} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Event
     * @param {String} name name of the Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Event} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Event}
     */
    replaceNamespacedEvent(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedEvent");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedEvent");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedEvent");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Event;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedLimitRange operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRange} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified LimitRange
     * @param {String} name name of the LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRange} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1LimitRange}
     */
    replaceNamespacedLimitRange(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedLimitRange");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedLimitRange");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedLimitRange");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1LimitRange;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedPersistentVolumeClaim operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim}
     */
    replaceNamespacedPersistentVolumeClaim(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedPersistentVolumeClaim");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedPersistentVolumeClaim");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedPersistentVolumeClaim");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolumeClaim;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedPersistentVolumeClaimStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedPersistentVolumeClaimStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedPersistentVolumeClaimStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolumeClaim}
     */
    replaceNamespacedPersistentVolumeClaimStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedPersistentVolumeClaimStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedPersistentVolumeClaimStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedPersistentVolumeClaimStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolumeClaim;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedPod operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Pod} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Pod}
     */
    replaceNamespacedPod(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedPod");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedPod");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedPod");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Pod;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedPodStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedPodStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Pod} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedPodStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Pod}
     */
    replaceNamespacedPodStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedPodStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedPodStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedPodStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Pod;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedPodTemplate operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplate} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified PodTemplate
     * @param {String} name name of the PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplate} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PodTemplate}
     */
    replaceNamespacedPodTemplate(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedPodTemplate");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedPodTemplate");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedPodTemplate");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PodTemplate;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedReplicationController operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController}
     */
    replaceNamespacedReplicationController(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedReplicationController");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedReplicationController");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedReplicationController");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ReplicationController;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedReplicationControllerScale operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedReplicationControllerScaleCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Scale} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace scale of the specified ReplicationController
     * @param {String} name name of the Scale
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Scale} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedReplicationControllerScaleCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Scale}
     */
    replaceNamespacedReplicationControllerScale(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedReplicationControllerScale");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedReplicationControllerScale");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedReplicationControllerScale");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Scale;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedReplicationControllerStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedReplicationControllerStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedReplicationControllerStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ReplicationController}
     */
    replaceNamespacedReplicationControllerStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedReplicationControllerStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedReplicationControllerStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedReplicationControllerStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ReplicationController;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedResourceQuota operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota}
     */
    replaceNamespacedResourceQuota(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedResourceQuota");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedResourceQuota");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedResourceQuota");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ResourceQuota;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedResourceQuotaStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedResourceQuotaStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedResourceQuotaStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ResourceQuota}
     */
    replaceNamespacedResourceQuotaStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedResourceQuotaStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedResourceQuotaStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedResourceQuotaStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ResourceQuota;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedSecret operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Secret} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Secret
     * @param {String} name name of the Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Secret} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Secret}
     */
    replaceNamespacedSecret(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedSecret");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedSecret");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedSecret");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Secret;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedService operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Service} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Service}
     */
    replaceNamespacedService(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedService");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedService");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedService");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Service;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedServiceAccount operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccount} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified ServiceAccount
     * @param {String} name name of the ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccount} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1ServiceAccount}
     */
    replaceNamespacedServiceAccount(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedServiceAccount");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedServiceAccount");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedServiceAccount");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1ServiceAccount;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNamespacedServiceStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedServiceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Service} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNamespacedServiceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Service}
     */
    replaceNamespacedServiceStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNamespacedServiceStatus");
      }

      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceNamespacedServiceStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNamespacedServiceStatus");
      }


      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Service;

      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNode operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNodeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Node
     * @param {String} name name of the Node
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Node} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Node}
     */
    replaceNode(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNode");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNode");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Node;

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceNodeStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNodeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified Node
     * @param {String} name name of the Node
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1Node} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replaceNodeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1Node}
     */
    replaceNodeStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceNodeStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceNodeStatus");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1Node;

      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replacePersistentVolume operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replacePersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replacePersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume}
     */
    replacePersistentVolume(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replacePersistentVolume");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replacePersistentVolume");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolume;

      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the replacePersistentVolumeStatus operation.
     * @callback module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replacePersistentVolumeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretty If &#39;true&#39;, then the output is pretty printed.
     * @param {module:io.kubernetes.client/io.kubernetes.client.apis/Core_v1Api~replacePersistentVolumeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:io.kubernetes.client/io.kubernetes.client.models/V1PersistentVolume}
     */
    replacePersistentVolumeStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;

      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replacePersistentVolumeStatus");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replacePersistentVolumeStatus");
      }


      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['*/*'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = V1PersistentVolume;

      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }


}
