import { ResponseContext, RequestContext, HttpFile, HttpInfo } from '../http/http';
import { Configuration} from '../configuration'

import { AdmissionregistrationV1ServiceReference } from '../models/AdmissionregistrationV1ServiceReference';
import { AdmissionregistrationV1WebhookClientConfig } from '../models/AdmissionregistrationV1WebhookClientConfig';
import { ApiextensionsV1ServiceReference } from '../models/ApiextensionsV1ServiceReference';
import { ApiextensionsV1WebhookClientConfig } from '../models/ApiextensionsV1WebhookClientConfig';
import { ApiregistrationV1ServiceReference } from '../models/ApiregistrationV1ServiceReference';
import { AuthenticationV1TokenRequest } from '../models/AuthenticationV1TokenRequest';
import { CoreV1EndpointPort } from '../models/CoreV1EndpointPort';
import { CoreV1Event } from '../models/CoreV1Event';
import { CoreV1EventList } from '../models/CoreV1EventList';
import { CoreV1EventSeries } from '../models/CoreV1EventSeries';
import { DiscoveryV1EndpointPort } from '../models/DiscoveryV1EndpointPort';
import { EventsV1Event } from '../models/EventsV1Event';
import { EventsV1EventList } from '../models/EventsV1EventList';
import { EventsV1EventSeries } from '../models/EventsV1EventSeries';
import { StorageV1TokenRequest } from '../models/StorageV1TokenRequest';
import { V1APIGroup } from '../models/V1APIGroup';
import { V1APIGroupList } from '../models/V1APIGroupList';
import { V1APIResource } from '../models/V1APIResource';
import { V1APIResourceList } from '../models/V1APIResourceList';
import { V1APIService } from '../models/V1APIService';
import { V1APIServiceCondition } from '../models/V1APIServiceCondition';
import { V1APIServiceList } from '../models/V1APIServiceList';
import { V1APIServiceSpec } from '../models/V1APIServiceSpec';
import { V1APIServiceStatus } from '../models/V1APIServiceStatus';
import { V1APIVersions } from '../models/V1APIVersions';
import { V1AWSElasticBlockStoreVolumeSource } from '../models/V1AWSElasticBlockStoreVolumeSource';
import { V1Affinity } from '../models/V1Affinity';
import { V1AggregationRule } from '../models/V1AggregationRule';
import { V1AttachedVolume } from '../models/V1AttachedVolume';
import { V1AzureDiskVolumeSource } from '../models/V1AzureDiskVolumeSource';
import { V1AzureFilePersistentVolumeSource } from '../models/V1AzureFilePersistentVolumeSource';
import { V1AzureFileVolumeSource } from '../models/V1AzureFileVolumeSource';
import { V1Binding } from '../models/V1Binding';
import { V1BoundObjectReference } from '../models/V1BoundObjectReference';
import { V1CSIDriver } from '../models/V1CSIDriver';
import { V1CSIDriverList } from '../models/V1CSIDriverList';
import { V1CSIDriverSpec } from '../models/V1CSIDriverSpec';
import { V1CSINode } from '../models/V1CSINode';
import { V1CSINodeDriver } from '../models/V1CSINodeDriver';
import { V1CSINodeList } from '../models/V1CSINodeList';
import { V1CSINodeSpec } from '../models/V1CSINodeSpec';
import { V1CSIPersistentVolumeSource } from '../models/V1CSIPersistentVolumeSource';
import { V1CSIVolumeSource } from '../models/V1CSIVolumeSource';
import { V1Capabilities } from '../models/V1Capabilities';
import { V1CephFSPersistentVolumeSource } from '../models/V1CephFSPersistentVolumeSource';
import { V1CephFSVolumeSource } from '../models/V1CephFSVolumeSource';
import { V1CertificateSigningRequest } from '../models/V1CertificateSigningRequest';
import { V1CertificateSigningRequestCondition } from '../models/V1CertificateSigningRequestCondition';
import { V1CertificateSigningRequestList } from '../models/V1CertificateSigningRequestList';
import { V1CertificateSigningRequestSpec } from '../models/V1CertificateSigningRequestSpec';
import { V1CertificateSigningRequestStatus } from '../models/V1CertificateSigningRequestStatus';
import { V1CinderPersistentVolumeSource } from '../models/V1CinderPersistentVolumeSource';
import { V1CinderVolumeSource } from '../models/V1CinderVolumeSource';
import { V1ClientIPConfig } from '../models/V1ClientIPConfig';
import { V1ClusterRole } from '../models/V1ClusterRole';
import { V1ClusterRoleBinding } from '../models/V1ClusterRoleBinding';
import { V1ClusterRoleBindingList } from '../models/V1ClusterRoleBindingList';
import { V1ClusterRoleList } from '../models/V1ClusterRoleList';
import { V1ComponentCondition } from '../models/V1ComponentCondition';
import { V1ComponentStatus } from '../models/V1ComponentStatus';
import { V1ComponentStatusList } from '../models/V1ComponentStatusList';
import { V1Condition } from '../models/V1Condition';
import { V1ConfigMap } from '../models/V1ConfigMap';
import { V1ConfigMapEnvSource } from '../models/V1ConfigMapEnvSource';
import { V1ConfigMapKeySelector } from '../models/V1ConfigMapKeySelector';
import { V1ConfigMapList } from '../models/V1ConfigMapList';
import { V1ConfigMapNodeConfigSource } from '../models/V1ConfigMapNodeConfigSource';
import { V1ConfigMapProjection } from '../models/V1ConfigMapProjection';
import { V1ConfigMapVolumeSource } from '../models/V1ConfigMapVolumeSource';
import { V1Container } from '../models/V1Container';
import { V1ContainerImage } from '../models/V1ContainerImage';
import { V1ContainerPort } from '../models/V1ContainerPort';
import { V1ContainerState } from '../models/V1ContainerState';
import { V1ContainerStateRunning } from '../models/V1ContainerStateRunning';
import { V1ContainerStateTerminated } from '../models/V1ContainerStateTerminated';
import { V1ContainerStateWaiting } from '../models/V1ContainerStateWaiting';
import { V1ContainerStatus } from '../models/V1ContainerStatus';
import { V1ControllerRevision } from '../models/V1ControllerRevision';
import { V1ControllerRevisionList } from '../models/V1ControllerRevisionList';
import { V1CronJob } from '../models/V1CronJob';
import { V1CronJobList } from '../models/V1CronJobList';
import { V1CronJobSpec } from '../models/V1CronJobSpec';
import { V1CronJobStatus } from '../models/V1CronJobStatus';
import { V1CrossVersionObjectReference } from '../models/V1CrossVersionObjectReference';
import { V1CustomResourceColumnDefinition } from '../models/V1CustomResourceColumnDefinition';
import { V1CustomResourceConversion } from '../models/V1CustomResourceConversion';
import { V1CustomResourceDefinition } from '../models/V1CustomResourceDefinition';
import { V1CustomResourceDefinitionCondition } from '../models/V1CustomResourceDefinitionCondition';
import { V1CustomResourceDefinitionList } from '../models/V1CustomResourceDefinitionList';
import { V1CustomResourceDefinitionNames } from '../models/V1CustomResourceDefinitionNames';
import { V1CustomResourceDefinitionSpec } from '../models/V1CustomResourceDefinitionSpec';
import { V1CustomResourceDefinitionStatus } from '../models/V1CustomResourceDefinitionStatus';
import { V1CustomResourceDefinitionVersion } from '../models/V1CustomResourceDefinitionVersion';
import { V1CustomResourceSubresourceScale } from '../models/V1CustomResourceSubresourceScale';
import { V1CustomResourceSubresources } from '../models/V1CustomResourceSubresources';
import { V1CustomResourceValidation } from '../models/V1CustomResourceValidation';
import { V1DaemonEndpoint } from '../models/V1DaemonEndpoint';
import { V1DaemonSet } from '../models/V1DaemonSet';
import { V1DaemonSetCondition } from '../models/V1DaemonSetCondition';
import { V1DaemonSetList } from '../models/V1DaemonSetList';
import { V1DaemonSetSpec } from '../models/V1DaemonSetSpec';
import { V1DaemonSetStatus } from '../models/V1DaemonSetStatus';
import { V1DaemonSetUpdateStrategy } from '../models/V1DaemonSetUpdateStrategy';
import { V1DeleteOptions } from '../models/V1DeleteOptions';
import { V1Deployment } from '../models/V1Deployment';
import { V1DeploymentCondition } from '../models/V1DeploymentCondition';
import { V1DeploymentList } from '../models/V1DeploymentList';
import { V1DeploymentSpec } from '../models/V1DeploymentSpec';
import { V1DeploymentStatus } from '../models/V1DeploymentStatus';
import { V1DeploymentStrategy } from '../models/V1DeploymentStrategy';
import { V1DownwardAPIProjection } from '../models/V1DownwardAPIProjection';
import { V1DownwardAPIVolumeFile } from '../models/V1DownwardAPIVolumeFile';
import { V1DownwardAPIVolumeSource } from '../models/V1DownwardAPIVolumeSource';
import { V1EmptyDirVolumeSource } from '../models/V1EmptyDirVolumeSource';
import { V1Endpoint } from '../models/V1Endpoint';
import { V1EndpointAddress } from '../models/V1EndpointAddress';
import { V1EndpointConditions } from '../models/V1EndpointConditions';
import { V1EndpointHints } from '../models/V1EndpointHints';
import { V1EndpointSlice } from '../models/V1EndpointSlice';
import { V1EndpointSliceList } from '../models/V1EndpointSliceList';
import { V1EndpointSubset } from '../models/V1EndpointSubset';
import { V1Endpoints } from '../models/V1Endpoints';
import { V1EndpointsList } from '../models/V1EndpointsList';
import { V1EnvFromSource } from '../models/V1EnvFromSource';
import { V1EnvVar } from '../models/V1EnvVar';
import { V1EnvVarSource } from '../models/V1EnvVarSource';
import { V1EphemeralContainer } from '../models/V1EphemeralContainer';
import { V1EphemeralVolumeSource } from '../models/V1EphemeralVolumeSource';
import { V1EventSource } from '../models/V1EventSource';
import { V1Eviction } from '../models/V1Eviction';
import { V1ExecAction } from '../models/V1ExecAction';
import { V1ExternalDocumentation } from '../models/V1ExternalDocumentation';
import { V1FCVolumeSource } from '../models/V1FCVolumeSource';
import { V1FlexPersistentVolumeSource } from '../models/V1FlexPersistentVolumeSource';
import { V1FlexVolumeSource } from '../models/V1FlexVolumeSource';
import { V1FlockerVolumeSource } from '../models/V1FlockerVolumeSource';
import { V1ForZone } from '../models/V1ForZone';
import { V1GCEPersistentDiskVolumeSource } from '../models/V1GCEPersistentDiskVolumeSource';
import { V1GitRepoVolumeSource } from '../models/V1GitRepoVolumeSource';
import { V1GlusterfsPersistentVolumeSource } from '../models/V1GlusterfsPersistentVolumeSource';
import { V1GlusterfsVolumeSource } from '../models/V1GlusterfsVolumeSource';
import { V1GroupVersionForDiscovery } from '../models/V1GroupVersionForDiscovery';
import { V1HTTPGetAction } from '../models/V1HTTPGetAction';
import { V1HTTPHeader } from '../models/V1HTTPHeader';
import { V1HTTPIngressPath } from '../models/V1HTTPIngressPath';
import { V1HTTPIngressRuleValue } from '../models/V1HTTPIngressRuleValue';
import { V1Handler } from '../models/V1Handler';
import { V1HorizontalPodAutoscaler } from '../models/V1HorizontalPodAutoscaler';
import { V1HorizontalPodAutoscalerList } from '../models/V1HorizontalPodAutoscalerList';
import { V1HorizontalPodAutoscalerSpec } from '../models/V1HorizontalPodAutoscalerSpec';
import { V1HorizontalPodAutoscalerStatus } from '../models/V1HorizontalPodAutoscalerStatus';
import { V1HostAlias } from '../models/V1HostAlias';
import { V1HostPathVolumeSource } from '../models/V1HostPathVolumeSource';
import { V1IPBlock } from '../models/V1IPBlock';
import { V1ISCSIPersistentVolumeSource } from '../models/V1ISCSIPersistentVolumeSource';
import { V1ISCSIVolumeSource } from '../models/V1ISCSIVolumeSource';
import { V1Ingress } from '../models/V1Ingress';
import { V1IngressBackend } from '../models/V1IngressBackend';
import { V1IngressClass } from '../models/V1IngressClass';
import { V1IngressClassList } from '../models/V1IngressClassList';
import { V1IngressClassParametersReference } from '../models/V1IngressClassParametersReference';
import { V1IngressClassSpec } from '../models/V1IngressClassSpec';
import { V1IngressList } from '../models/V1IngressList';
import { V1IngressRule } from '../models/V1IngressRule';
import { V1IngressServiceBackend } from '../models/V1IngressServiceBackend';
import { V1IngressSpec } from '../models/V1IngressSpec';
import { V1IngressStatus } from '../models/V1IngressStatus';
import { V1IngressTLS } from '../models/V1IngressTLS';
import { V1JSONSchemaProps } from '../models/V1JSONSchemaProps';
import { V1Job } from '../models/V1Job';
import { V1JobCondition } from '../models/V1JobCondition';
import { V1JobList } from '../models/V1JobList';
import { V1JobSpec } from '../models/V1JobSpec';
import { V1JobStatus } from '../models/V1JobStatus';
import { V1JobTemplateSpec } from '../models/V1JobTemplateSpec';
import { V1KeyToPath } from '../models/V1KeyToPath';
import { V1LabelSelector } from '../models/V1LabelSelector';
import { V1LabelSelectorRequirement } from '../models/V1LabelSelectorRequirement';
import { V1Lease } from '../models/V1Lease';
import { V1LeaseList } from '../models/V1LeaseList';
import { V1LeaseSpec } from '../models/V1LeaseSpec';
import { V1Lifecycle } from '../models/V1Lifecycle';
import { V1LimitRange } from '../models/V1LimitRange';
import { V1LimitRangeItem } from '../models/V1LimitRangeItem';
import { V1LimitRangeList } from '../models/V1LimitRangeList';
import { V1LimitRangeSpec } from '../models/V1LimitRangeSpec';
import { V1ListMeta } from '../models/V1ListMeta';
import { V1LoadBalancerIngress } from '../models/V1LoadBalancerIngress';
import { V1LoadBalancerStatus } from '../models/V1LoadBalancerStatus';
import { V1LocalObjectReference } from '../models/V1LocalObjectReference';
import { V1LocalSubjectAccessReview } from '../models/V1LocalSubjectAccessReview';
import { V1LocalVolumeSource } from '../models/V1LocalVolumeSource';
import { V1ManagedFieldsEntry } from '../models/V1ManagedFieldsEntry';
import { V1MutatingWebhook } from '../models/V1MutatingWebhook';
import { V1MutatingWebhookConfiguration } from '../models/V1MutatingWebhookConfiguration';
import { V1MutatingWebhookConfigurationList } from '../models/V1MutatingWebhookConfigurationList';
import { V1NFSVolumeSource } from '../models/V1NFSVolumeSource';
import { V1Namespace } from '../models/V1Namespace';
import { V1NamespaceCondition } from '../models/V1NamespaceCondition';
import { V1NamespaceList } from '../models/V1NamespaceList';
import { V1NamespaceSpec } from '../models/V1NamespaceSpec';
import { V1NamespaceStatus } from '../models/V1NamespaceStatus';
import { V1NetworkPolicy } from '../models/V1NetworkPolicy';
import { V1NetworkPolicyEgressRule } from '../models/V1NetworkPolicyEgressRule';
import { V1NetworkPolicyIngressRule } from '../models/V1NetworkPolicyIngressRule';
import { V1NetworkPolicyList } from '../models/V1NetworkPolicyList';
import { V1NetworkPolicyPeer } from '../models/V1NetworkPolicyPeer';
import { V1NetworkPolicyPort } from '../models/V1NetworkPolicyPort';
import { V1NetworkPolicySpec } from '../models/V1NetworkPolicySpec';
import { V1Node } from '../models/V1Node';
import { V1NodeAddress } from '../models/V1NodeAddress';
import { V1NodeAffinity } from '../models/V1NodeAffinity';
import { V1NodeCondition } from '../models/V1NodeCondition';
import { V1NodeConfigSource } from '../models/V1NodeConfigSource';
import { V1NodeConfigStatus } from '../models/V1NodeConfigStatus';
import { V1NodeDaemonEndpoints } from '../models/V1NodeDaemonEndpoints';
import { V1NodeList } from '../models/V1NodeList';
import { V1NodeSelector } from '../models/V1NodeSelector';
import { V1NodeSelectorRequirement } from '../models/V1NodeSelectorRequirement';
import { V1NodeSelectorTerm } from '../models/V1NodeSelectorTerm';
import { V1NodeSpec } from '../models/V1NodeSpec';
import { V1NodeStatus } from '../models/V1NodeStatus';
import { V1NodeSystemInfo } from '../models/V1NodeSystemInfo';
import { V1NonResourceAttributes } from '../models/V1NonResourceAttributes';
import { V1NonResourceRule } from '../models/V1NonResourceRule';
import { V1ObjectFieldSelector } from '../models/V1ObjectFieldSelector';
import { V1ObjectMeta } from '../models/V1ObjectMeta';
import { V1ObjectReference } from '../models/V1ObjectReference';
import { V1Overhead } from '../models/V1Overhead';
import { V1OwnerReference } from '../models/V1OwnerReference';
import { V1PersistentVolume } from '../models/V1PersistentVolume';
import { V1PersistentVolumeClaim } from '../models/V1PersistentVolumeClaim';
import { V1PersistentVolumeClaimCondition } from '../models/V1PersistentVolumeClaimCondition';
import { V1PersistentVolumeClaimList } from '../models/V1PersistentVolumeClaimList';
import { V1PersistentVolumeClaimSpec } from '../models/V1PersistentVolumeClaimSpec';
import { V1PersistentVolumeClaimStatus } from '../models/V1PersistentVolumeClaimStatus';
import { V1PersistentVolumeClaimTemplate } from '../models/V1PersistentVolumeClaimTemplate';
import { V1PersistentVolumeClaimVolumeSource } from '../models/V1PersistentVolumeClaimVolumeSource';
import { V1PersistentVolumeList } from '../models/V1PersistentVolumeList';
import { V1PersistentVolumeSpec } from '../models/V1PersistentVolumeSpec';
import { V1PersistentVolumeStatus } from '../models/V1PersistentVolumeStatus';
import { V1PhotonPersistentDiskVolumeSource } from '../models/V1PhotonPersistentDiskVolumeSource';
import { V1Pod } from '../models/V1Pod';
import { V1PodAffinity } from '../models/V1PodAffinity';
import { V1PodAffinityTerm } from '../models/V1PodAffinityTerm';
import { V1PodAntiAffinity } from '../models/V1PodAntiAffinity';
import { V1PodCondition } from '../models/V1PodCondition';
import { V1PodDNSConfig } from '../models/V1PodDNSConfig';
import { V1PodDNSConfigOption } from '../models/V1PodDNSConfigOption';
import { V1PodDisruptionBudget } from '../models/V1PodDisruptionBudget';
import { V1PodDisruptionBudgetList } from '../models/V1PodDisruptionBudgetList';
import { V1PodDisruptionBudgetSpec } from '../models/V1PodDisruptionBudgetSpec';
import { V1PodDisruptionBudgetStatus } from '../models/V1PodDisruptionBudgetStatus';
import { V1PodIP } from '../models/V1PodIP';
import { V1PodList } from '../models/V1PodList';
import { V1PodReadinessGate } from '../models/V1PodReadinessGate';
import { V1PodSecurityContext } from '../models/V1PodSecurityContext';
import { V1PodSpec } from '../models/V1PodSpec';
import { V1PodStatus } from '../models/V1PodStatus';
import { V1PodTemplate } from '../models/V1PodTemplate';
import { V1PodTemplateList } from '../models/V1PodTemplateList';
import { V1PodTemplateSpec } from '../models/V1PodTemplateSpec';
import { V1PolicyRule } from '../models/V1PolicyRule';
import { V1PortStatus } from '../models/V1PortStatus';
import { V1PortworxVolumeSource } from '../models/V1PortworxVolumeSource';
import { V1Preconditions } from '../models/V1Preconditions';
import { V1PreferredSchedulingTerm } from '../models/V1PreferredSchedulingTerm';
import { V1PriorityClass } from '../models/V1PriorityClass';
import { V1PriorityClassList } from '../models/V1PriorityClassList';
import { V1Probe } from '../models/V1Probe';
import { V1ProjectedVolumeSource } from '../models/V1ProjectedVolumeSource';
import { V1QuobyteVolumeSource } from '../models/V1QuobyteVolumeSource';
import { V1RBDPersistentVolumeSource } from '../models/V1RBDPersistentVolumeSource';
import { V1RBDVolumeSource } from '../models/V1RBDVolumeSource';
import { V1ReplicaSet } from '../models/V1ReplicaSet';
import { V1ReplicaSetCondition } from '../models/V1ReplicaSetCondition';
import { V1ReplicaSetList } from '../models/V1ReplicaSetList';
import { V1ReplicaSetSpec } from '../models/V1ReplicaSetSpec';
import { V1ReplicaSetStatus } from '../models/V1ReplicaSetStatus';
import { V1ReplicationController } from '../models/V1ReplicationController';
import { V1ReplicationControllerCondition } from '../models/V1ReplicationControllerCondition';
import { V1ReplicationControllerList } from '../models/V1ReplicationControllerList';
import { V1ReplicationControllerSpec } from '../models/V1ReplicationControllerSpec';
import { V1ReplicationControllerStatus } from '../models/V1ReplicationControllerStatus';
import { V1ResourceAttributes } from '../models/V1ResourceAttributes';
import { V1ResourceFieldSelector } from '../models/V1ResourceFieldSelector';
import { V1ResourceQuota } from '../models/V1ResourceQuota';
import { V1ResourceQuotaList } from '../models/V1ResourceQuotaList';
import { V1ResourceQuotaSpec } from '../models/V1ResourceQuotaSpec';
import { V1ResourceQuotaStatus } from '../models/V1ResourceQuotaStatus';
import { V1ResourceRequirements } from '../models/V1ResourceRequirements';
import { V1ResourceRule } from '../models/V1ResourceRule';
import { V1Role } from '../models/V1Role';
import { V1RoleBinding } from '../models/V1RoleBinding';
import { V1RoleBindingList } from '../models/V1RoleBindingList';
import { V1RoleList } from '../models/V1RoleList';
import { V1RoleRef } from '../models/V1RoleRef';
import { V1RollingUpdateDaemonSet } from '../models/V1RollingUpdateDaemonSet';
import { V1RollingUpdateDeployment } from '../models/V1RollingUpdateDeployment';
import { V1RollingUpdateStatefulSetStrategy } from '../models/V1RollingUpdateStatefulSetStrategy';
import { V1RuleWithOperations } from '../models/V1RuleWithOperations';
import { V1RuntimeClass } from '../models/V1RuntimeClass';
import { V1RuntimeClassList } from '../models/V1RuntimeClassList';
import { V1SELinuxOptions } from '../models/V1SELinuxOptions';
import { V1Scale } from '../models/V1Scale';
import { V1ScaleIOPersistentVolumeSource } from '../models/V1ScaleIOPersistentVolumeSource';
import { V1ScaleIOVolumeSource } from '../models/V1ScaleIOVolumeSource';
import { V1ScaleSpec } from '../models/V1ScaleSpec';
import { V1ScaleStatus } from '../models/V1ScaleStatus';
import { V1Scheduling } from '../models/V1Scheduling';
import { V1ScopeSelector } from '../models/V1ScopeSelector';
import { V1ScopedResourceSelectorRequirement } from '../models/V1ScopedResourceSelectorRequirement';
import { V1SeccompProfile } from '../models/V1SeccompProfile';
import { V1Secret } from '../models/V1Secret';
import { V1SecretEnvSource } from '../models/V1SecretEnvSource';
import { V1SecretKeySelector } from '../models/V1SecretKeySelector';
import { V1SecretList } from '../models/V1SecretList';
import { V1SecretProjection } from '../models/V1SecretProjection';
import { V1SecretReference } from '../models/V1SecretReference';
import { V1SecretVolumeSource } from '../models/V1SecretVolumeSource';
import { V1SecurityContext } from '../models/V1SecurityContext';
import { V1SelfSubjectAccessReview } from '../models/V1SelfSubjectAccessReview';
import { V1SelfSubjectAccessReviewSpec } from '../models/V1SelfSubjectAccessReviewSpec';
import { V1SelfSubjectRulesReview } from '../models/V1SelfSubjectRulesReview';
import { V1SelfSubjectRulesReviewSpec } from '../models/V1SelfSubjectRulesReviewSpec';
import { V1ServerAddressByClientCIDR } from '../models/V1ServerAddressByClientCIDR';
import { V1Service } from '../models/V1Service';
import { V1ServiceAccount } from '../models/V1ServiceAccount';
import { V1ServiceAccountList } from '../models/V1ServiceAccountList';
import { V1ServiceAccountTokenProjection } from '../models/V1ServiceAccountTokenProjection';
import { V1ServiceBackendPort } from '../models/V1ServiceBackendPort';
import { V1ServiceList } from '../models/V1ServiceList';
import { V1ServicePort } from '../models/V1ServicePort';
import { V1ServiceSpec } from '../models/V1ServiceSpec';
import { V1ServiceStatus } from '../models/V1ServiceStatus';
import { V1SessionAffinityConfig } from '../models/V1SessionAffinityConfig';
import { V1StatefulSet } from '../models/V1StatefulSet';
import { V1StatefulSetCondition } from '../models/V1StatefulSetCondition';
import { V1StatefulSetList } from '../models/V1StatefulSetList';
import { V1StatefulSetSpec } from '../models/V1StatefulSetSpec';
import { V1StatefulSetStatus } from '../models/V1StatefulSetStatus';
import { V1StatefulSetUpdateStrategy } from '../models/V1StatefulSetUpdateStrategy';
import { V1Status } from '../models/V1Status';
import { V1StatusCause } from '../models/V1StatusCause';
import { V1StatusDetails } from '../models/V1StatusDetails';
import { V1StorageClass } from '../models/V1StorageClass';
import { V1StorageClassList } from '../models/V1StorageClassList';
import { V1StorageOSPersistentVolumeSource } from '../models/V1StorageOSPersistentVolumeSource';
import { V1StorageOSVolumeSource } from '../models/V1StorageOSVolumeSource';
import { V1Subject } from '../models/V1Subject';
import { V1SubjectAccessReview } from '../models/V1SubjectAccessReview';
import { V1SubjectAccessReviewSpec } from '../models/V1SubjectAccessReviewSpec';
import { V1SubjectAccessReviewStatus } from '../models/V1SubjectAccessReviewStatus';
import { V1SubjectRulesReviewStatus } from '../models/V1SubjectRulesReviewStatus';
import { V1Sysctl } from '../models/V1Sysctl';
import { V1TCPSocketAction } from '../models/V1TCPSocketAction';
import { V1Taint } from '../models/V1Taint';
import { V1TokenRequestSpec } from '../models/V1TokenRequestSpec';
import { V1TokenRequestStatus } from '../models/V1TokenRequestStatus';
import { V1TokenReview } from '../models/V1TokenReview';
import { V1TokenReviewSpec } from '../models/V1TokenReviewSpec';
import { V1TokenReviewStatus } from '../models/V1TokenReviewStatus';
import { V1Toleration } from '../models/V1Toleration';
import { V1TopologySelectorLabelRequirement } from '../models/V1TopologySelectorLabelRequirement';
import { V1TopologySelectorTerm } from '../models/V1TopologySelectorTerm';
import { V1TopologySpreadConstraint } from '../models/V1TopologySpreadConstraint';
import { V1TypedLocalObjectReference } from '../models/V1TypedLocalObjectReference';
import { V1UncountedTerminatedPods } from '../models/V1UncountedTerminatedPods';
import { V1UserInfo } from '../models/V1UserInfo';
import { V1ValidatingWebhook } from '../models/V1ValidatingWebhook';
import { V1ValidatingWebhookConfiguration } from '../models/V1ValidatingWebhookConfiguration';
import { V1ValidatingWebhookConfigurationList } from '../models/V1ValidatingWebhookConfigurationList';
import { V1Volume } from '../models/V1Volume';
import { V1VolumeAttachment } from '../models/V1VolumeAttachment';
import { V1VolumeAttachmentList } from '../models/V1VolumeAttachmentList';
import { V1VolumeAttachmentSource } from '../models/V1VolumeAttachmentSource';
import { V1VolumeAttachmentSpec } from '../models/V1VolumeAttachmentSpec';
import { V1VolumeAttachmentStatus } from '../models/V1VolumeAttachmentStatus';
import { V1VolumeDevice } from '../models/V1VolumeDevice';
import { V1VolumeError } from '../models/V1VolumeError';
import { V1VolumeMount } from '../models/V1VolumeMount';
import { V1VolumeNodeAffinity } from '../models/V1VolumeNodeAffinity';
import { V1VolumeNodeResources } from '../models/V1VolumeNodeResources';
import { V1VolumeProjection } from '../models/V1VolumeProjection';
import { V1VsphereVirtualDiskVolumeSource } from '../models/V1VsphereVirtualDiskVolumeSource';
import { V1WatchEvent } from '../models/V1WatchEvent';
import { V1WebhookConversion } from '../models/V1WebhookConversion';
import { V1WeightedPodAffinityTerm } from '../models/V1WeightedPodAffinityTerm';
import { V1WindowsSecurityContextOptions } from '../models/V1WindowsSecurityContextOptions';
import { V1alpha1AggregationRule } from '../models/V1alpha1AggregationRule';
import { V1alpha1CSIStorageCapacity } from '../models/V1alpha1CSIStorageCapacity';
import { V1alpha1CSIStorageCapacityList } from '../models/V1alpha1CSIStorageCapacityList';
import { V1alpha1ClusterRole } from '../models/V1alpha1ClusterRole';
import { V1alpha1ClusterRoleBinding } from '../models/V1alpha1ClusterRoleBinding';
import { V1alpha1ClusterRoleBindingList } from '../models/V1alpha1ClusterRoleBindingList';
import { V1alpha1ClusterRoleList } from '../models/V1alpha1ClusterRoleList';
import { V1alpha1Overhead } from '../models/V1alpha1Overhead';
import { V1alpha1PolicyRule } from '../models/V1alpha1PolicyRule';
import { V1alpha1PriorityClass } from '../models/V1alpha1PriorityClass';
import { V1alpha1PriorityClassList } from '../models/V1alpha1PriorityClassList';
import { V1alpha1Role } from '../models/V1alpha1Role';
import { V1alpha1RoleBinding } from '../models/V1alpha1RoleBinding';
import { V1alpha1RoleBindingList } from '../models/V1alpha1RoleBindingList';
import { V1alpha1RoleList } from '../models/V1alpha1RoleList';
import { V1alpha1RoleRef } from '../models/V1alpha1RoleRef';
import { V1alpha1RuntimeClass } from '../models/V1alpha1RuntimeClass';
import { V1alpha1RuntimeClassList } from '../models/V1alpha1RuntimeClassList';
import { V1alpha1RuntimeClassSpec } from '../models/V1alpha1RuntimeClassSpec';
import { V1alpha1Scheduling } from '../models/V1alpha1Scheduling';
import { V1alpha1ServerStorageVersion } from '../models/V1alpha1ServerStorageVersion';
import { V1alpha1StorageVersion } from '../models/V1alpha1StorageVersion';
import { V1alpha1StorageVersionCondition } from '../models/V1alpha1StorageVersionCondition';
import { V1alpha1StorageVersionList } from '../models/V1alpha1StorageVersionList';
import { V1alpha1StorageVersionStatus } from '../models/V1alpha1StorageVersionStatus';
import { V1alpha1Subject } from '../models/V1alpha1Subject';
import { V1alpha1VolumeAttachment } from '../models/V1alpha1VolumeAttachment';
import { V1alpha1VolumeAttachmentList } from '../models/V1alpha1VolumeAttachmentList';
import { V1alpha1VolumeAttachmentSource } from '../models/V1alpha1VolumeAttachmentSource';
import { V1alpha1VolumeAttachmentSpec } from '../models/V1alpha1VolumeAttachmentSpec';
import { V1alpha1VolumeAttachmentStatus } from '../models/V1alpha1VolumeAttachmentStatus';
import { V1alpha1VolumeError } from '../models/V1alpha1VolumeError';
import { V1beta1AllowedCSIDriver } from '../models/V1beta1AllowedCSIDriver';
import { V1beta1AllowedFlexVolume } from '../models/V1beta1AllowedFlexVolume';
import { V1beta1AllowedHostPath } from '../models/V1beta1AllowedHostPath';
import { V1beta1CSIStorageCapacity } from '../models/V1beta1CSIStorageCapacity';
import { V1beta1CSIStorageCapacityList } from '../models/V1beta1CSIStorageCapacityList';
import { V1beta1CronJob } from '../models/V1beta1CronJob';
import { V1beta1CronJobList } from '../models/V1beta1CronJobList';
import { V1beta1CronJobSpec } from '../models/V1beta1CronJobSpec';
import { V1beta1CronJobStatus } from '../models/V1beta1CronJobStatus';
import { V1beta1Endpoint } from '../models/V1beta1Endpoint';
import { V1beta1EndpointConditions } from '../models/V1beta1EndpointConditions';
import { V1beta1EndpointHints } from '../models/V1beta1EndpointHints';
import { V1beta1EndpointPort } from '../models/V1beta1EndpointPort';
import { V1beta1EndpointSlice } from '../models/V1beta1EndpointSlice';
import { V1beta1EndpointSliceList } from '../models/V1beta1EndpointSliceList';
import { V1beta1Event } from '../models/V1beta1Event';
import { V1beta1EventList } from '../models/V1beta1EventList';
import { V1beta1EventSeries } from '../models/V1beta1EventSeries';
import { V1beta1FSGroupStrategyOptions } from '../models/V1beta1FSGroupStrategyOptions';
import { V1beta1FlowDistinguisherMethod } from '../models/V1beta1FlowDistinguisherMethod';
import { V1beta1FlowSchema } from '../models/V1beta1FlowSchema';
import { V1beta1FlowSchemaCondition } from '../models/V1beta1FlowSchemaCondition';
import { V1beta1FlowSchemaList } from '../models/V1beta1FlowSchemaList';
import { V1beta1FlowSchemaSpec } from '../models/V1beta1FlowSchemaSpec';
import { V1beta1FlowSchemaStatus } from '../models/V1beta1FlowSchemaStatus';
import { V1beta1ForZone } from '../models/V1beta1ForZone';
import { V1beta1GroupSubject } from '../models/V1beta1GroupSubject';
import { V1beta1HostPortRange } from '../models/V1beta1HostPortRange';
import { V1beta1IDRange } from '../models/V1beta1IDRange';
import { V1beta1JobTemplateSpec } from '../models/V1beta1JobTemplateSpec';
import { V1beta1LimitResponse } from '../models/V1beta1LimitResponse';
import { V1beta1LimitedPriorityLevelConfiguration } from '../models/V1beta1LimitedPriorityLevelConfiguration';
import { V1beta1NonResourcePolicyRule } from '../models/V1beta1NonResourcePolicyRule';
import { V1beta1Overhead } from '../models/V1beta1Overhead';
import { V1beta1PodDisruptionBudget } from '../models/V1beta1PodDisruptionBudget';
import { V1beta1PodDisruptionBudgetList } from '../models/V1beta1PodDisruptionBudgetList';
import { V1beta1PodDisruptionBudgetSpec } from '../models/V1beta1PodDisruptionBudgetSpec';
import { V1beta1PodDisruptionBudgetStatus } from '../models/V1beta1PodDisruptionBudgetStatus';
import { V1beta1PodSecurityPolicy } from '../models/V1beta1PodSecurityPolicy';
import { V1beta1PodSecurityPolicyList } from '../models/V1beta1PodSecurityPolicyList';
import { V1beta1PodSecurityPolicySpec } from '../models/V1beta1PodSecurityPolicySpec';
import { V1beta1PolicyRulesWithSubjects } from '../models/V1beta1PolicyRulesWithSubjects';
import { V1beta1PriorityLevelConfiguration } from '../models/V1beta1PriorityLevelConfiguration';
import { V1beta1PriorityLevelConfigurationCondition } from '../models/V1beta1PriorityLevelConfigurationCondition';
import { V1beta1PriorityLevelConfigurationList } from '../models/V1beta1PriorityLevelConfigurationList';
import { V1beta1PriorityLevelConfigurationReference } from '../models/V1beta1PriorityLevelConfigurationReference';
import { V1beta1PriorityLevelConfigurationSpec } from '../models/V1beta1PriorityLevelConfigurationSpec';
import { V1beta1PriorityLevelConfigurationStatus } from '../models/V1beta1PriorityLevelConfigurationStatus';
import { V1beta1QueuingConfiguration } from '../models/V1beta1QueuingConfiguration';
import { V1beta1ResourcePolicyRule } from '../models/V1beta1ResourcePolicyRule';
import { V1beta1RunAsGroupStrategyOptions } from '../models/V1beta1RunAsGroupStrategyOptions';
import { V1beta1RunAsUserStrategyOptions } from '../models/V1beta1RunAsUserStrategyOptions';
import { V1beta1RuntimeClass } from '../models/V1beta1RuntimeClass';
import { V1beta1RuntimeClassList } from '../models/V1beta1RuntimeClassList';
import { V1beta1RuntimeClassStrategyOptions } from '../models/V1beta1RuntimeClassStrategyOptions';
import { V1beta1SELinuxStrategyOptions } from '../models/V1beta1SELinuxStrategyOptions';
import { V1beta1Scheduling } from '../models/V1beta1Scheduling';
import { V1beta1ServiceAccountSubject } from '../models/V1beta1ServiceAccountSubject';
import { V1beta1Subject } from '../models/V1beta1Subject';
import { V1beta1SupplementalGroupsStrategyOptions } from '../models/V1beta1SupplementalGroupsStrategyOptions';
import { V1beta1UserSubject } from '../models/V1beta1UserSubject';
import { V2beta1ContainerResourceMetricSource } from '../models/V2beta1ContainerResourceMetricSource';
import { V2beta1ContainerResourceMetricStatus } from '../models/V2beta1ContainerResourceMetricStatus';
import { V2beta1CrossVersionObjectReference } from '../models/V2beta1CrossVersionObjectReference';
import { V2beta1ExternalMetricSource } from '../models/V2beta1ExternalMetricSource';
import { V2beta1ExternalMetricStatus } from '../models/V2beta1ExternalMetricStatus';
import { V2beta1HorizontalPodAutoscaler } from '../models/V2beta1HorizontalPodAutoscaler';
import { V2beta1HorizontalPodAutoscalerCondition } from '../models/V2beta1HorizontalPodAutoscalerCondition';
import { V2beta1HorizontalPodAutoscalerList } from '../models/V2beta1HorizontalPodAutoscalerList';
import { V2beta1HorizontalPodAutoscalerSpec } from '../models/V2beta1HorizontalPodAutoscalerSpec';
import { V2beta1HorizontalPodAutoscalerStatus } from '../models/V2beta1HorizontalPodAutoscalerStatus';
import { V2beta1MetricSpec } from '../models/V2beta1MetricSpec';
import { V2beta1MetricStatus } from '../models/V2beta1MetricStatus';
import { V2beta1ObjectMetricSource } from '../models/V2beta1ObjectMetricSource';
import { V2beta1ObjectMetricStatus } from '../models/V2beta1ObjectMetricStatus';
import { V2beta1PodsMetricSource } from '../models/V2beta1PodsMetricSource';
import { V2beta1PodsMetricStatus } from '../models/V2beta1PodsMetricStatus';
import { V2beta1ResourceMetricSource } from '../models/V2beta1ResourceMetricSource';
import { V2beta1ResourceMetricStatus } from '../models/V2beta1ResourceMetricStatus';
import { V2beta2ContainerResourceMetricSource } from '../models/V2beta2ContainerResourceMetricSource';
import { V2beta2ContainerResourceMetricStatus } from '../models/V2beta2ContainerResourceMetricStatus';
import { V2beta2CrossVersionObjectReference } from '../models/V2beta2CrossVersionObjectReference';
import { V2beta2ExternalMetricSource } from '../models/V2beta2ExternalMetricSource';
import { V2beta2ExternalMetricStatus } from '../models/V2beta2ExternalMetricStatus';
import { V2beta2HPAScalingPolicy } from '../models/V2beta2HPAScalingPolicy';
import { V2beta2HPAScalingRules } from '../models/V2beta2HPAScalingRules';
import { V2beta2HorizontalPodAutoscaler } from '../models/V2beta2HorizontalPodAutoscaler';
import { V2beta2HorizontalPodAutoscalerBehavior } from '../models/V2beta2HorizontalPodAutoscalerBehavior';
import { V2beta2HorizontalPodAutoscalerCondition } from '../models/V2beta2HorizontalPodAutoscalerCondition';
import { V2beta2HorizontalPodAutoscalerList } from '../models/V2beta2HorizontalPodAutoscalerList';
import { V2beta2HorizontalPodAutoscalerSpec } from '../models/V2beta2HorizontalPodAutoscalerSpec';
import { V2beta2HorizontalPodAutoscalerStatus } from '../models/V2beta2HorizontalPodAutoscalerStatus';
import { V2beta2MetricIdentifier } from '../models/V2beta2MetricIdentifier';
import { V2beta2MetricSpec } from '../models/V2beta2MetricSpec';
import { V2beta2MetricStatus } from '../models/V2beta2MetricStatus';
import { V2beta2MetricTarget } from '../models/V2beta2MetricTarget';
import { V2beta2MetricValueStatus } from '../models/V2beta2MetricValueStatus';
import { V2beta2ObjectMetricSource } from '../models/V2beta2ObjectMetricSource';
import { V2beta2ObjectMetricStatus } from '../models/V2beta2ObjectMetricStatus';
import { V2beta2PodsMetricSource } from '../models/V2beta2PodsMetricSource';
import { V2beta2PodsMetricStatus } from '../models/V2beta2PodsMetricStatus';
import { V2beta2ResourceMetricSource } from '../models/V2beta2ResourceMetricSource';
import { V2beta2ResourceMetricStatus } from '../models/V2beta2ResourceMetricStatus';
import { VersionInfo } from '../models/VersionInfo';

import { ObservableAdmissionregistrationApi } from "./ObservableAPI";
import { AdmissionregistrationApiRequestFactory, AdmissionregistrationApiResponseProcessor} from "../apis/AdmissionregistrationApi";

export interface AdmissionregistrationApiGetAPIGroupRequest {
}

export class ObjectAdmissionregistrationApi {
    private api: ObservableAdmissionregistrationApi

    public constructor(configuration: Configuration, requestFactory?: AdmissionregistrationApiRequestFactory, responseProcessor?: AdmissionregistrationApiResponseProcessor) {
        this.api = new ObservableAdmissionregistrationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: AdmissionregistrationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: AdmissionregistrationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableAdmissionregistrationV1Api } from "./ObservableAPI";
import { AdmissionregistrationV1ApiRequestFactory, AdmissionregistrationV1ApiResponseProcessor} from "../apis/AdmissionregistrationV1Api";

export interface AdmissionregistrationV1ApiCreateMutatingWebhookConfigurationRequest {
    /**
     * 
     * @type V1MutatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApicreateMutatingWebhookConfiguration
     */
    body: V1MutatingWebhookConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApicreateMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApicreateMutatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1ApicreateMutatingWebhookConfiguration
     */
    fieldManager?: string
}

export interface AdmissionregistrationV1ApiCreateValidatingWebhookConfigurationRequest {
    /**
     * 
     * @type V1ValidatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApicreateValidatingWebhookConfiguration
     */
    body: V1ValidatingWebhookConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingWebhookConfiguration
     */
    fieldManager?: string
}

export interface AdmissionregistrationV1ApiDeleteCollectionMutatingWebhookConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiDeleteCollectionValidatingWebhookConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiDeleteMutatingWebhookConfigurationRequest {
    /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiDeleteValidatingWebhookConfigurationRequest {
    /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiGetAPIResourcesRequest {
}

export interface AdmissionregistrationV1ApiListMutatingWebhookConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    watch?: boolean
}

export interface AdmissionregistrationV1ApiListValidatingWebhookConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    watch?: boolean
}

export interface AdmissionregistrationV1ApiPatchMutatingWebhookConfigurationRequest {
    /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    force?: boolean
}

export interface AdmissionregistrationV1ApiPatchValidatingWebhookConfigurationRequest {
    /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    force?: boolean
}

export interface AdmissionregistrationV1ApiReadMutatingWebhookConfigurationRequest {
    /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApireadMutatingWebhookConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApireadMutatingWebhookConfiguration
     */
    pretty?: string
}

export interface AdmissionregistrationV1ApiReadValidatingWebhookConfigurationRequest {
    /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApireadValidatingWebhookConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApireadValidatingWebhookConfiguration
     */
    pretty?: string
}

export interface AdmissionregistrationV1ApiReplaceMutatingWebhookConfigurationRequest {
    /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceMutatingWebhookConfiguration
     */
    name: string
    /**
     * 
     * @type V1MutatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApireplaceMutatingWebhookConfiguration
     */
    body: V1MutatingWebhookConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceMutatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceMutatingWebhookConfiguration
     */
    fieldManager?: string
}

export interface AdmissionregistrationV1ApiReplaceValidatingWebhookConfigurationRequest {
    /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingWebhookConfiguration
     */
    name: string
    /**
     * 
     * @type V1ValidatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApireplaceValidatingWebhookConfiguration
     */
    body: V1ValidatingWebhookConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingWebhookConfiguration
     */
    fieldManager?: string
}

export class ObjectAdmissionregistrationV1Api {
    private api: ObservableAdmissionregistrationV1Api

    public constructor(configuration: Configuration, requestFactory?: AdmissionregistrationV1ApiRequestFactory, responseProcessor?: AdmissionregistrationV1ApiResponseProcessor) {
        this.api = new ObservableAdmissionregistrationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a MutatingWebhookConfiguration
     * @param param the request object
     */
    public createMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiCreateMutatingWebhookConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1MutatingWebhookConfiguration>> {
        return this.api.createMutatingWebhookConfigurationWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a MutatingWebhookConfiguration
     * @param param the request object
     */
    public createMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiCreateMutatingWebhookConfigurationRequest, options?: Configuration): Promise<V1MutatingWebhookConfiguration> {
        return this.api.createMutatingWebhookConfiguration(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ValidatingWebhookConfiguration
     * @param param the request object
     */
    public createValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiCreateValidatingWebhookConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1ValidatingWebhookConfiguration>> {
        return this.api.createValidatingWebhookConfigurationWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ValidatingWebhookConfiguration
     * @param param the request object
     */
    public createValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiCreateValidatingWebhookConfigurationRequest, options?: Configuration): Promise<V1ValidatingWebhookConfiguration> {
        return this.api.createValidatingWebhookConfiguration(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of MutatingWebhookConfiguration
     * @param param the request object
     */
    public deleteCollectionMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiDeleteCollectionMutatingWebhookConfigurationRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionMutatingWebhookConfigurationWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of MutatingWebhookConfiguration
     * @param param the request object
     */
    public deleteCollectionMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiDeleteCollectionMutatingWebhookConfigurationRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionMutatingWebhookConfiguration(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ValidatingWebhookConfiguration
     * @param param the request object
     */
    public deleteCollectionValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiDeleteCollectionValidatingWebhookConfigurationRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionValidatingWebhookConfigurationWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ValidatingWebhookConfiguration
     * @param param the request object
     */
    public deleteCollectionValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiDeleteCollectionValidatingWebhookConfigurationRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionValidatingWebhookConfiguration(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a MutatingWebhookConfiguration
     * @param param the request object
     */
    public deleteMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiDeleteMutatingWebhookConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteMutatingWebhookConfigurationWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a MutatingWebhookConfiguration
     * @param param the request object
     */
    public deleteMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiDeleteMutatingWebhookConfigurationRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteMutatingWebhookConfiguration(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingWebhookConfiguration
     * @param param the request object
     */
    public deleteValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiDeleteValidatingWebhookConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteValidatingWebhookConfigurationWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingWebhookConfiguration
     * @param param the request object
     */
    public deleteValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiDeleteValidatingWebhookConfigurationRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteValidatingWebhookConfiguration(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AdmissionregistrationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AdmissionregistrationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind MutatingWebhookConfiguration
     * @param param the request object
     */
    public listMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiListMutatingWebhookConfigurationRequest = {}, options?: Configuration): Promise<HttpInfo<V1MutatingWebhookConfigurationList>> {
        return this.api.listMutatingWebhookConfigurationWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind MutatingWebhookConfiguration
     * @param param the request object
     */
    public listMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiListMutatingWebhookConfigurationRequest = {}, options?: Configuration): Promise<V1MutatingWebhookConfigurationList> {
        return this.api.listMutatingWebhookConfiguration(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingWebhookConfiguration
     * @param param the request object
     */
    public listValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiListValidatingWebhookConfigurationRequest = {}, options?: Configuration): Promise<HttpInfo<V1ValidatingWebhookConfigurationList>> {
        return this.api.listValidatingWebhookConfigurationWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingWebhookConfiguration
     * @param param the request object
     */
    public listValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiListValidatingWebhookConfigurationRequest = {}, options?: Configuration): Promise<V1ValidatingWebhookConfigurationList> {
        return this.api.listValidatingWebhookConfiguration(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public patchMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiPatchMutatingWebhookConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1MutatingWebhookConfiguration>> {
        return this.api.patchMutatingWebhookConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public patchMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiPatchMutatingWebhookConfigurationRequest, options?: Configuration): Promise<V1MutatingWebhookConfiguration> {
        return this.api.patchMutatingWebhookConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public patchValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiPatchValidatingWebhookConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1ValidatingWebhookConfiguration>> {
        return this.api.patchValidatingWebhookConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public patchValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiPatchValidatingWebhookConfigurationRequest, options?: Configuration): Promise<V1ValidatingWebhookConfiguration> {
        return this.api.patchValidatingWebhookConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public readMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiReadMutatingWebhookConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1MutatingWebhookConfiguration>> {
        return this.api.readMutatingWebhookConfigurationWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public readMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiReadMutatingWebhookConfigurationRequest, options?: Configuration): Promise<V1MutatingWebhookConfiguration> {
        return this.api.readMutatingWebhookConfiguration(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public readValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiReadValidatingWebhookConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1ValidatingWebhookConfiguration>> {
        return this.api.readValidatingWebhookConfigurationWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public readValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiReadValidatingWebhookConfigurationRequest, options?: Configuration): Promise<V1ValidatingWebhookConfiguration> {
        return this.api.readValidatingWebhookConfiguration(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public replaceMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiReplaceMutatingWebhookConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1MutatingWebhookConfiguration>> {
        return this.api.replaceMutatingWebhookConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public replaceMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiReplaceMutatingWebhookConfigurationRequest, options?: Configuration): Promise<V1MutatingWebhookConfiguration> {
        return this.api.replaceMutatingWebhookConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public replaceValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiReplaceValidatingWebhookConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1ValidatingWebhookConfiguration>> {
        return this.api.replaceValidatingWebhookConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public replaceValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiReplaceValidatingWebhookConfigurationRequest, options?: Configuration): Promise<V1ValidatingWebhookConfiguration> {
        return this.api.replaceValidatingWebhookConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableApiextensionsApi } from "./ObservableAPI";
import { ApiextensionsApiRequestFactory, ApiextensionsApiResponseProcessor} from "../apis/ApiextensionsApi";

export interface ApiextensionsApiGetAPIGroupRequest {
}

export class ObjectApiextensionsApi {
    private api: ObservableApiextensionsApi

    public constructor(configuration: Configuration, requestFactory?: ApiextensionsApiRequestFactory, responseProcessor?: ApiextensionsApiResponseProcessor) {
        this.api = new ObservableApiextensionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: ApiextensionsApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: ApiextensionsApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableApiextensionsV1Api } from "./ObservableAPI";
import { ApiextensionsV1ApiRequestFactory, ApiextensionsV1ApiResponseProcessor} from "../apis/ApiextensionsV1Api";

export interface ApiextensionsV1ApiCreateCustomResourceDefinitionRequest {
    /**
     * 
     * @type V1CustomResourceDefinition
     * @memberof ApiextensionsV1ApicreateCustomResourceDefinition
     */
    body: V1CustomResourceDefinition
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApicreateCustomResourceDefinition
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApicreateCustomResourceDefinition
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiextensionsV1ApicreateCustomResourceDefinition
     */
    fieldManager?: string
}

export interface ApiextensionsV1ApiDeleteCollectionCustomResourceDefinitionRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    body?: V1DeleteOptions
}

export interface ApiextensionsV1ApiDeleteCustomResourceDefinitionRequest {
    /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    body?: V1DeleteOptions
}

export interface ApiextensionsV1ApiGetAPIResourcesRequest {
}

export interface ApiextensionsV1ApiListCustomResourceDefinitionRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    watch?: boolean
}

export interface ApiextensionsV1ApiPatchCustomResourceDefinitionRequest {
    /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    force?: boolean
}

export interface ApiextensionsV1ApiPatchCustomResourceDefinitionStatusRequest {
    /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    force?: boolean
}

export interface ApiextensionsV1ApiReadCustomResourceDefinitionRequest {
    /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApireadCustomResourceDefinition
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApireadCustomResourceDefinition
     */
    pretty?: string
}

export interface ApiextensionsV1ApiReadCustomResourceDefinitionStatusRequest {
    /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApireadCustomResourceDefinitionStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApireadCustomResourceDefinitionStatus
     */
    pretty?: string
}

export interface ApiextensionsV1ApiReplaceCustomResourceDefinitionRequest {
    /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinition
     */
    name: string
    /**
     * 
     * @type V1CustomResourceDefinition
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinition
     */
    body: V1CustomResourceDefinition
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinition
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinition
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinition
     */
    fieldManager?: string
}

export interface ApiextensionsV1ApiReplaceCustomResourceDefinitionStatusRequest {
    /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinitionStatus
     */
    name: string
    /**
     * 
     * @type V1CustomResourceDefinition
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinitionStatus
     */
    body: V1CustomResourceDefinition
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinitionStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinitionStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinitionStatus
     */
    fieldManager?: string
}

export class ObjectApiextensionsV1Api {
    private api: ObservableApiextensionsV1Api

    public constructor(configuration: Configuration, requestFactory?: ApiextensionsV1ApiRequestFactory, responseProcessor?: ApiextensionsV1ApiResponseProcessor) {
        this.api = new ObservableApiextensionsV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a CustomResourceDefinition
     * @param param the request object
     */
    public createCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiCreateCustomResourceDefinitionRequest, options?: Configuration): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.createCustomResourceDefinitionWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a CustomResourceDefinition
     * @param param the request object
     */
    public createCustomResourceDefinition(param: ApiextensionsV1ApiCreateCustomResourceDefinitionRequest, options?: Configuration): Promise<V1CustomResourceDefinition> {
        return this.api.createCustomResourceDefinition(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of CustomResourceDefinition
     * @param param the request object
     */
    public deleteCollectionCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiDeleteCollectionCustomResourceDefinitionRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionCustomResourceDefinitionWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CustomResourceDefinition
     * @param param the request object
     */
    public deleteCollectionCustomResourceDefinition(param: ApiextensionsV1ApiDeleteCollectionCustomResourceDefinitionRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionCustomResourceDefinition(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a CustomResourceDefinition
     * @param param the request object
     */
    public deleteCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiDeleteCustomResourceDefinitionRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCustomResourceDefinitionWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CustomResourceDefinition
     * @param param the request object
     */
    public deleteCustomResourceDefinition(param: ApiextensionsV1ApiDeleteCustomResourceDefinitionRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCustomResourceDefinition(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: ApiextensionsV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: ApiextensionsV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind CustomResourceDefinition
     * @param param the request object
     */
    public listCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiListCustomResourceDefinitionRequest = {}, options?: Configuration): Promise<HttpInfo<V1CustomResourceDefinitionList>> {
        return this.api.listCustomResourceDefinitionWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CustomResourceDefinition
     * @param param the request object
     */
    public listCustomResourceDefinition(param: ApiextensionsV1ApiListCustomResourceDefinitionRequest = {}, options?: Configuration): Promise<V1CustomResourceDefinitionList> {
        return this.api.listCustomResourceDefinition(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified CustomResourceDefinition
     * @param param the request object
     */
    public patchCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiPatchCustomResourceDefinitionRequest, options?: Configuration): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.patchCustomResourceDefinitionWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CustomResourceDefinition
     * @param param the request object
     */
    public patchCustomResourceDefinition(param: ApiextensionsV1ApiPatchCustomResourceDefinitionRequest, options?: Configuration): Promise<V1CustomResourceDefinition> {
        return this.api.patchCustomResourceDefinition(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public patchCustomResourceDefinitionStatusWithHttpInfo(param: ApiextensionsV1ApiPatchCustomResourceDefinitionStatusRequest, options?: Configuration): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.patchCustomResourceDefinitionStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public patchCustomResourceDefinitionStatus(param: ApiextensionsV1ApiPatchCustomResourceDefinitionStatusRequest, options?: Configuration): Promise<V1CustomResourceDefinition> {
        return this.api.patchCustomResourceDefinitionStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified CustomResourceDefinition
     * @param param the request object
     */
    public readCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiReadCustomResourceDefinitionRequest, options?: Configuration): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.readCustomResourceDefinitionWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CustomResourceDefinition
     * @param param the request object
     */
    public readCustomResourceDefinition(param: ApiextensionsV1ApiReadCustomResourceDefinitionRequest, options?: Configuration): Promise<V1CustomResourceDefinition> {
        return this.api.readCustomResourceDefinition(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public readCustomResourceDefinitionStatusWithHttpInfo(param: ApiextensionsV1ApiReadCustomResourceDefinitionStatusRequest, options?: Configuration): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.readCustomResourceDefinitionStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public readCustomResourceDefinitionStatus(param: ApiextensionsV1ApiReadCustomResourceDefinitionStatusRequest, options?: Configuration): Promise<V1CustomResourceDefinition> {
        return this.api.readCustomResourceDefinitionStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified CustomResourceDefinition
     * @param param the request object
     */
    public replaceCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiReplaceCustomResourceDefinitionRequest, options?: Configuration): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.replaceCustomResourceDefinitionWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified CustomResourceDefinition
     * @param param the request object
     */
    public replaceCustomResourceDefinition(param: ApiextensionsV1ApiReplaceCustomResourceDefinitionRequest, options?: Configuration): Promise<V1CustomResourceDefinition> {
        return this.api.replaceCustomResourceDefinition(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public replaceCustomResourceDefinitionStatusWithHttpInfo(param: ApiextensionsV1ApiReplaceCustomResourceDefinitionStatusRequest, options?: Configuration): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.replaceCustomResourceDefinitionStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public replaceCustomResourceDefinitionStatus(param: ApiextensionsV1ApiReplaceCustomResourceDefinitionStatusRequest, options?: Configuration): Promise<V1CustomResourceDefinition> {
        return this.api.replaceCustomResourceDefinitionStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableApiregistrationApi } from "./ObservableAPI";
import { ApiregistrationApiRequestFactory, ApiregistrationApiResponseProcessor} from "../apis/ApiregistrationApi";

export interface ApiregistrationApiGetAPIGroupRequest {
}

export class ObjectApiregistrationApi {
    private api: ObservableApiregistrationApi

    public constructor(configuration: Configuration, requestFactory?: ApiregistrationApiRequestFactory, responseProcessor?: ApiregistrationApiResponseProcessor) {
        this.api = new ObservableApiregistrationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: ApiregistrationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: ApiregistrationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableApiregistrationV1Api } from "./ObservableAPI";
import { ApiregistrationV1ApiRequestFactory, ApiregistrationV1ApiResponseProcessor} from "../apis/ApiregistrationV1Api";

export interface ApiregistrationV1ApiCreateAPIServiceRequest {
    /**
     * 
     * @type V1APIService
     * @memberof ApiregistrationV1ApicreateAPIService
     */
    body: V1APIService
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApicreateAPIService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApicreateAPIService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiregistrationV1ApicreateAPIService
     */
    fieldManager?: string
}

export interface ApiregistrationV1ApiDeleteAPIServiceRequest {
    /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    body?: V1DeleteOptions
}

export interface ApiregistrationV1ApiDeleteCollectionAPIServiceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    body?: V1DeleteOptions
}

export interface ApiregistrationV1ApiGetAPIResourcesRequest {
}

export interface ApiregistrationV1ApiListAPIServiceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof ApiregistrationV1ApilistAPIService
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiregistrationV1ApilistAPIService
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiregistrationV1ApilistAPIService
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiregistrationV1ApilistAPIService
     */
    watch?: boolean
}

export interface ApiregistrationV1ApiPatchAPIServiceRequest {
    /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    force?: boolean
}

export interface ApiregistrationV1ApiPatchAPIServiceStatusRequest {
    /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    force?: boolean
}

export interface ApiregistrationV1ApiReadAPIServiceRequest {
    /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApireadAPIService
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApireadAPIService
     */
    pretty?: string
}

export interface ApiregistrationV1ApiReadAPIServiceStatusRequest {
    /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApireadAPIServiceStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApireadAPIServiceStatus
     */
    pretty?: string
}

export interface ApiregistrationV1ApiReplaceAPIServiceRequest {
    /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIService
     */
    name: string
    /**
     * 
     * @type V1APIService
     * @memberof ApiregistrationV1ApireplaceAPIService
     */
    body: V1APIService
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIService
     */
    fieldManager?: string
}

export interface ApiregistrationV1ApiReplaceAPIServiceStatusRequest {
    /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIServiceStatus
     */
    name: string
    /**
     * 
     * @type V1APIService
     * @memberof ApiregistrationV1ApireplaceAPIServiceStatus
     */
    body: V1APIService
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIServiceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIServiceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIServiceStatus
     */
    fieldManager?: string
}

export class ObjectApiregistrationV1Api {
    private api: ObservableApiregistrationV1Api

    public constructor(configuration: Configuration, requestFactory?: ApiregistrationV1ApiRequestFactory, responseProcessor?: ApiregistrationV1ApiResponseProcessor) {
        this.api = new ObservableApiregistrationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create an APIService
     * @param param the request object
     */
    public createAPIServiceWithHttpInfo(param: ApiregistrationV1ApiCreateAPIServiceRequest, options?: Configuration): Promise<HttpInfo<V1APIService>> {
        return this.api.createAPIServiceWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create an APIService
     * @param param the request object
     */
    public createAPIService(param: ApiregistrationV1ApiCreateAPIServiceRequest, options?: Configuration): Promise<V1APIService> {
        return this.api.createAPIService(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete an APIService
     * @param param the request object
     */
    public deleteAPIServiceWithHttpInfo(param: ApiregistrationV1ApiDeleteAPIServiceRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteAPIServiceWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an APIService
     * @param param the request object
     */
    public deleteAPIService(param: ApiregistrationV1ApiDeleteAPIServiceRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteAPIService(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete collection of APIService
     * @param param the request object
     */
    public deleteCollectionAPIServiceWithHttpInfo(param: ApiregistrationV1ApiDeleteCollectionAPIServiceRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionAPIServiceWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of APIService
     * @param param the request object
     */
    public deleteCollectionAPIService(param: ApiregistrationV1ApiDeleteCollectionAPIServiceRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionAPIService(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: ApiregistrationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: ApiregistrationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind APIService
     * @param param the request object
     */
    public listAPIServiceWithHttpInfo(param: ApiregistrationV1ApiListAPIServiceRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIServiceList>> {
        return this.api.listAPIServiceWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind APIService
     * @param param the request object
     */
    public listAPIService(param: ApiregistrationV1ApiListAPIServiceRequest = {}, options?: Configuration): Promise<V1APIServiceList> {
        return this.api.listAPIService(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified APIService
     * @param param the request object
     */
    public patchAPIServiceWithHttpInfo(param: ApiregistrationV1ApiPatchAPIServiceRequest, options?: Configuration): Promise<HttpInfo<V1APIService>> {
        return this.api.patchAPIServiceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified APIService
     * @param param the request object
     */
    public patchAPIService(param: ApiregistrationV1ApiPatchAPIServiceRequest, options?: Configuration): Promise<V1APIService> {
        return this.api.patchAPIService(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified APIService
     * @param param the request object
     */
    public patchAPIServiceStatusWithHttpInfo(param: ApiregistrationV1ApiPatchAPIServiceStatusRequest, options?: Configuration): Promise<HttpInfo<V1APIService>> {
        return this.api.patchAPIServiceStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified APIService
     * @param param the request object
     */
    public patchAPIServiceStatus(param: ApiregistrationV1ApiPatchAPIServiceStatusRequest, options?: Configuration): Promise<V1APIService> {
        return this.api.patchAPIServiceStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified APIService
     * @param param the request object
     */
    public readAPIServiceWithHttpInfo(param: ApiregistrationV1ApiReadAPIServiceRequest, options?: Configuration): Promise<HttpInfo<V1APIService>> {
        return this.api.readAPIServiceWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified APIService
     * @param param the request object
     */
    public readAPIService(param: ApiregistrationV1ApiReadAPIServiceRequest, options?: Configuration): Promise<V1APIService> {
        return this.api.readAPIService(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified APIService
     * @param param the request object
     */
    public readAPIServiceStatusWithHttpInfo(param: ApiregistrationV1ApiReadAPIServiceStatusRequest, options?: Configuration): Promise<HttpInfo<V1APIService>> {
        return this.api.readAPIServiceStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified APIService
     * @param param the request object
     */
    public readAPIServiceStatus(param: ApiregistrationV1ApiReadAPIServiceStatusRequest, options?: Configuration): Promise<V1APIService> {
        return this.api.readAPIServiceStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified APIService
     * @param param the request object
     */
    public replaceAPIServiceWithHttpInfo(param: ApiregistrationV1ApiReplaceAPIServiceRequest, options?: Configuration): Promise<HttpInfo<V1APIService>> {
        return this.api.replaceAPIServiceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified APIService
     * @param param the request object
     */
    public replaceAPIService(param: ApiregistrationV1ApiReplaceAPIServiceRequest, options?: Configuration): Promise<V1APIService> {
        return this.api.replaceAPIService(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified APIService
     * @param param the request object
     */
    public replaceAPIServiceStatusWithHttpInfo(param: ApiregistrationV1ApiReplaceAPIServiceStatusRequest, options?: Configuration): Promise<HttpInfo<V1APIService>> {
        return this.api.replaceAPIServiceStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified APIService
     * @param param the request object
     */
    public replaceAPIServiceStatus(param: ApiregistrationV1ApiReplaceAPIServiceStatusRequest, options?: Configuration): Promise<V1APIService> {
        return this.api.replaceAPIServiceStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableApisApi } from "./ObservableAPI";
import { ApisApiRequestFactory, ApisApiResponseProcessor} from "../apis/ApisApi";

export interface ApisApiGetAPIVersionsRequest {
}

export class ObjectApisApi {
    private api: ObservableApisApi

    public constructor(configuration: Configuration, requestFactory?: ApisApiRequestFactory, responseProcessor?: ApisApiResponseProcessor) {
        this.api = new ObservableApisApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get available API versions
     * @param param the request object
     */
    public getAPIVersionsWithHttpInfo(param: ApisApiGetAPIVersionsRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroupList>> {
        return this.api.getAPIVersionsWithHttpInfo( options).toPromise();
    }

    /**
     * get available API versions
     * @param param the request object
     */
    public getAPIVersions(param: ApisApiGetAPIVersionsRequest = {}, options?: Configuration): Promise<V1APIGroupList> {
        return this.api.getAPIVersions( options).toPromise();
    }

}

import { ObservableAppsApi } from "./ObservableAPI";
import { AppsApiRequestFactory, AppsApiResponseProcessor} from "../apis/AppsApi";

export interface AppsApiGetAPIGroupRequest {
}

export class ObjectAppsApi {
    private api: ObservableAppsApi

    public constructor(configuration: Configuration, requestFactory?: AppsApiRequestFactory, responseProcessor?: AppsApiResponseProcessor) {
        this.api = new ObservableAppsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: AppsApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: AppsApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableAppsV1Api } from "./ObservableAPI";
import { AppsV1ApiRequestFactory, AppsV1ApiResponseProcessor} from "../apis/AppsV1Api";

export interface AppsV1ApiCreateNamespacedControllerRevisionRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApicreateNamespacedControllerRevision
     */
    namespace: string
    /**
     * 
     * @type V1ControllerRevision
     * @memberof AppsV1ApicreateNamespacedControllerRevision
     */
    body: V1ControllerRevision
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApicreateNamespacedControllerRevision
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApicreateNamespacedControllerRevision
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApicreateNamespacedControllerRevision
     */
    fieldManager?: string
}

export interface AppsV1ApiCreateNamespacedDaemonSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApicreateNamespacedDaemonSet
     */
    namespace: string
    /**
     * 
     * @type V1DaemonSet
     * @memberof AppsV1ApicreateNamespacedDaemonSet
     */
    body: V1DaemonSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApicreateNamespacedDaemonSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApicreateNamespacedDaemonSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApicreateNamespacedDaemonSet
     */
    fieldManager?: string
}

export interface AppsV1ApiCreateNamespacedDeploymentRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApicreateNamespacedDeployment
     */
    namespace: string
    /**
     * 
     * @type V1Deployment
     * @memberof AppsV1ApicreateNamespacedDeployment
     */
    body: V1Deployment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApicreateNamespacedDeployment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApicreateNamespacedDeployment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApicreateNamespacedDeployment
     */
    fieldManager?: string
}

export interface AppsV1ApiCreateNamespacedReplicaSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApicreateNamespacedReplicaSet
     */
    namespace: string
    /**
     * 
     * @type V1ReplicaSet
     * @memberof AppsV1ApicreateNamespacedReplicaSet
     */
    body: V1ReplicaSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApicreateNamespacedReplicaSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApicreateNamespacedReplicaSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApicreateNamespacedReplicaSet
     */
    fieldManager?: string
}

export interface AppsV1ApiCreateNamespacedStatefulSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApicreateNamespacedStatefulSet
     */
    namespace: string
    /**
     * 
     * @type V1StatefulSet
     * @memberof AppsV1ApicreateNamespacedStatefulSet
     */
    body: V1StatefulSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApicreateNamespacedStatefulSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApicreateNamespacedStatefulSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApicreateNamespacedStatefulSet
     */
    fieldManager?: string
}

export interface AppsV1ApiDeleteCollectionNamespacedControllerRevisionRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteCollectionNamespacedDaemonSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteCollectionNamespacedDeploymentRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteCollectionNamespacedReplicaSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteCollectionNamespacedStatefulSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteNamespacedControllerRevisionRequest {
    /**
     * name of the ControllerRevision
     * @type string
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteNamespacedDaemonSetRequest {
    /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteNamespacedDeploymentRequest {
    /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteNamespacedReplicaSetRequest {
    /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteNamespacedStatefulSetRequest {
    /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiGetAPIResourcesRequest {
}

export interface AppsV1ApiListControllerRevisionForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    watch?: boolean
}

export interface AppsV1ApiListDaemonSetForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    watch?: boolean
}

export interface AppsV1ApiListDeploymentForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    watch?: boolean
}

export interface AppsV1ApiListNamespacedControllerRevisionRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    watch?: boolean
}

export interface AppsV1ApiListNamespacedDaemonSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    watch?: boolean
}

export interface AppsV1ApiListNamespacedDeploymentRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    watch?: boolean
}

export interface AppsV1ApiListNamespacedReplicaSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    watch?: boolean
}

export interface AppsV1ApiListNamespacedStatefulSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    watch?: boolean
}

export interface AppsV1ApiListReplicaSetForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    watch?: boolean
}

export interface AppsV1ApiListStatefulSetForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    watch?: boolean
}

export interface AppsV1ApiPatchNamespacedControllerRevisionRequest {
    /**
     * name of the ControllerRevision
     * @type string
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedDaemonSetRequest {
    /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedDaemonSetStatusRequest {
    /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedDeploymentRequest {
    /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedDeploymentScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedDeploymentStatusRequest {
    /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedReplicaSetRequest {
    /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedReplicaSetScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedReplicaSetStatusRequest {
    /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedStatefulSetRequest {
    /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedStatefulSetScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedStatefulSetStatusRequest {
    /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    force?: boolean
}

export interface AppsV1ApiReadNamespacedControllerRevisionRequest {
    /**
     * name of the ControllerRevision
     * @type string
     * @memberof AppsV1ApireadNamespacedControllerRevision
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedControllerRevision
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedControllerRevision
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedDaemonSetRequest {
    /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSet
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedDaemonSetStatusRequest {
    /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSetStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSetStatus
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedDeploymentRequest {
    /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApireadNamespacedDeployment
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedDeployment
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedDeployment
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedDeploymentScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentScale
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentScale
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedDeploymentStatusRequest {
    /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentStatus
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedReplicaSetRequest {
    /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSet
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedReplicaSetScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetScale
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetScale
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedReplicaSetStatusRequest {
    /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetStatus
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedStatefulSetRequest {
    /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSet
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedStatefulSetScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetScale
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetScale
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedStatefulSetStatusRequest {
    /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetStatus
     */
    pretty?: string
}

export interface AppsV1ApiReplaceNamespacedControllerRevisionRequest {
    /**
     * name of the ControllerRevision
     * @type string
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    namespace: string
    /**
     * 
     * @type V1ControllerRevision
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    body: V1ControllerRevision
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    fieldManager?: string
}

export interface AppsV1ApiReplaceNamespacedDaemonSetRequest {
    /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    namespace: string
    /**
     * 
     * @type V1DaemonSet
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    body: V1DaemonSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    fieldManager?: string
}

export interface AppsV1ApiReplaceNamespacedDaemonSetStatusRequest {
    /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    namespace: string
    /**
     * 
     * @type V1DaemonSet
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    body: V1DaemonSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    fieldManager?: string
}

export interface AppsV1ApiReplaceNamespacedDeploymentRequest {
    /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    namespace: string
    /**
     * 
     * @type V1Deployment
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    body: V1Deployment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    fieldManager?: string
}

export interface AppsV1ApiReplaceNamespacedDeploymentScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    namespace: string
    /**
     * 
     * @type V1Scale
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    body: V1Scale
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    fieldManager?: string
}

export interface AppsV1ApiReplaceNamespacedDeploymentStatusRequest {
    /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    namespace: string
    /**
     * 
     * @type V1Deployment
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    body: V1Deployment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    fieldManager?: string
}

export interface AppsV1ApiReplaceNamespacedReplicaSetRequest {
    /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    namespace: string
    /**
     * 
     * @type V1ReplicaSet
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    body: V1ReplicaSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    fieldManager?: string
}

export interface AppsV1ApiReplaceNamespacedReplicaSetScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    namespace: string
    /**
     * 
     * @type V1Scale
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    body: V1Scale
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    fieldManager?: string
}

export interface AppsV1ApiReplaceNamespacedReplicaSetStatusRequest {
    /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    namespace: string
    /**
     * 
     * @type V1ReplicaSet
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    body: V1ReplicaSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    fieldManager?: string
}

export interface AppsV1ApiReplaceNamespacedStatefulSetRequest {
    /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    namespace: string
    /**
     * 
     * @type V1StatefulSet
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    body: V1StatefulSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    fieldManager?: string
}

export interface AppsV1ApiReplaceNamespacedStatefulSetScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    namespace: string
    /**
     * 
     * @type V1Scale
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    body: V1Scale
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    fieldManager?: string
}

export interface AppsV1ApiReplaceNamespacedStatefulSetStatusRequest {
    /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    namespace: string
    /**
     * 
     * @type V1StatefulSet
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    body: V1StatefulSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    fieldManager?: string
}

export class ObjectAppsV1Api {
    private api: ObservableAppsV1Api

    public constructor(configuration: Configuration, requestFactory?: AppsV1ApiRequestFactory, responseProcessor?: AppsV1ApiResponseProcessor) {
        this.api = new ObservableAppsV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a ControllerRevision
     * @param param the request object
     */
    public createNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiCreateNamespacedControllerRevisionRequest, options?: Configuration): Promise<HttpInfo<V1ControllerRevision>> {
        return this.api.createNamespacedControllerRevisionWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ControllerRevision
     * @param param the request object
     */
    public createNamespacedControllerRevision(param: AppsV1ApiCreateNamespacedControllerRevisionRequest, options?: Configuration): Promise<V1ControllerRevision> {
        return this.api.createNamespacedControllerRevision(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a DaemonSet
     * @param param the request object
     */
    public createNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiCreateNamespacedDaemonSetRequest, options?: Configuration): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.createNamespacedDaemonSetWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a DaemonSet
     * @param param the request object
     */
    public createNamespacedDaemonSet(param: AppsV1ApiCreateNamespacedDaemonSetRequest, options?: Configuration): Promise<V1DaemonSet> {
        return this.api.createNamespacedDaemonSet(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Deployment
     * @param param the request object
     */
    public createNamespacedDeploymentWithHttpInfo(param: AppsV1ApiCreateNamespacedDeploymentRequest, options?: Configuration): Promise<HttpInfo<V1Deployment>> {
        return this.api.createNamespacedDeploymentWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Deployment
     * @param param the request object
     */
    public createNamespacedDeployment(param: AppsV1ApiCreateNamespacedDeploymentRequest, options?: Configuration): Promise<V1Deployment> {
        return this.api.createNamespacedDeployment(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ReplicaSet
     * @param param the request object
     */
    public createNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiCreateNamespacedReplicaSetRequest, options?: Configuration): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.createNamespacedReplicaSetWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ReplicaSet
     * @param param the request object
     */
    public createNamespacedReplicaSet(param: AppsV1ApiCreateNamespacedReplicaSetRequest, options?: Configuration): Promise<V1ReplicaSet> {
        return this.api.createNamespacedReplicaSet(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a StatefulSet
     * @param param the request object
     */
    public createNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiCreateNamespacedStatefulSetRequest, options?: Configuration): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.createNamespacedStatefulSetWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a StatefulSet
     * @param param the request object
     */
    public createNamespacedStatefulSet(param: AppsV1ApiCreateNamespacedStatefulSetRequest, options?: Configuration): Promise<V1StatefulSet> {
        return this.api.createNamespacedStatefulSet(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of ControllerRevision
     * @param param the request object
     */
    public deleteCollectionNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiDeleteCollectionNamespacedControllerRevisionRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedControllerRevisionWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ControllerRevision
     * @param param the request object
     */
    public deleteCollectionNamespacedControllerRevision(param: AppsV1ApiDeleteCollectionNamespacedControllerRevisionRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedControllerRevision(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of DaemonSet
     * @param param the request object
     */
    public deleteCollectionNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiDeleteCollectionNamespacedDaemonSetRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedDaemonSetWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of DaemonSet
     * @param param the request object
     */
    public deleteCollectionNamespacedDaemonSet(param: AppsV1ApiDeleteCollectionNamespacedDaemonSetRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedDaemonSet(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Deployment
     * @param param the request object
     */
    public deleteCollectionNamespacedDeploymentWithHttpInfo(param: AppsV1ApiDeleteCollectionNamespacedDeploymentRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedDeploymentWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Deployment
     * @param param the request object
     */
    public deleteCollectionNamespacedDeployment(param: AppsV1ApiDeleteCollectionNamespacedDeploymentRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedDeployment(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ReplicaSet
     * @param param the request object
     */
    public deleteCollectionNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiDeleteCollectionNamespacedReplicaSetRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedReplicaSetWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ReplicaSet
     * @param param the request object
     */
    public deleteCollectionNamespacedReplicaSet(param: AppsV1ApiDeleteCollectionNamespacedReplicaSetRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedReplicaSet(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of StatefulSet
     * @param param the request object
     */
    public deleteCollectionNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiDeleteCollectionNamespacedStatefulSetRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedStatefulSetWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of StatefulSet
     * @param param the request object
     */
    public deleteCollectionNamespacedStatefulSet(param: AppsV1ApiDeleteCollectionNamespacedStatefulSetRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedStatefulSet(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a ControllerRevision
     * @param param the request object
     */
    public deleteNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiDeleteNamespacedControllerRevisionRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedControllerRevisionWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ControllerRevision
     * @param param the request object
     */
    public deleteNamespacedControllerRevision(param: AppsV1ApiDeleteNamespacedControllerRevisionRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedControllerRevision(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a DaemonSet
     * @param param the request object
     */
    public deleteNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiDeleteNamespacedDaemonSetRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedDaemonSetWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a DaemonSet
     * @param param the request object
     */
    public deleteNamespacedDaemonSet(param: AppsV1ApiDeleteNamespacedDaemonSetRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedDaemonSet(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Deployment
     * @param param the request object
     */
    public deleteNamespacedDeploymentWithHttpInfo(param: AppsV1ApiDeleteNamespacedDeploymentRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedDeploymentWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Deployment
     * @param param the request object
     */
    public deleteNamespacedDeployment(param: AppsV1ApiDeleteNamespacedDeploymentRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedDeployment(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ReplicaSet
     * @param param the request object
     */
    public deleteNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiDeleteNamespacedReplicaSetRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedReplicaSetWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ReplicaSet
     * @param param the request object
     */
    public deleteNamespacedReplicaSet(param: AppsV1ApiDeleteNamespacedReplicaSetRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedReplicaSet(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a StatefulSet
     * @param param the request object
     */
    public deleteNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiDeleteNamespacedStatefulSetRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedStatefulSetWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a StatefulSet
     * @param param the request object
     */
    public deleteNamespacedStatefulSet(param: AppsV1ApiDeleteNamespacedStatefulSetRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedStatefulSet(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AppsV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AppsV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind ControllerRevision
     * @param param the request object
     */
    public listControllerRevisionForAllNamespacesWithHttpInfo(param: AppsV1ApiListControllerRevisionForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1ControllerRevisionList>> {
        return this.api.listControllerRevisionForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ControllerRevision
     * @param param the request object
     */
    public listControllerRevisionForAllNamespaces(param: AppsV1ApiListControllerRevisionForAllNamespacesRequest = {}, options?: Configuration): Promise<V1ControllerRevisionList> {
        return this.api.listControllerRevisionForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DaemonSet
     * @param param the request object
     */
    public listDaemonSetForAllNamespacesWithHttpInfo(param: AppsV1ApiListDaemonSetForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1DaemonSetList>> {
        return this.api.listDaemonSetForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DaemonSet
     * @param param the request object
     */
    public listDaemonSetForAllNamespaces(param: AppsV1ApiListDaemonSetForAllNamespacesRequest = {}, options?: Configuration): Promise<V1DaemonSetList> {
        return this.api.listDaemonSetForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Deployment
     * @param param the request object
     */
    public listDeploymentForAllNamespacesWithHttpInfo(param: AppsV1ApiListDeploymentForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1DeploymentList>> {
        return this.api.listDeploymentForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Deployment
     * @param param the request object
     */
    public listDeploymentForAllNamespaces(param: AppsV1ApiListDeploymentForAllNamespacesRequest = {}, options?: Configuration): Promise<V1DeploymentList> {
        return this.api.listDeploymentForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ControllerRevision
     * @param param the request object
     */
    public listNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiListNamespacedControllerRevisionRequest, options?: Configuration): Promise<HttpInfo<V1ControllerRevisionList>> {
        return this.api.listNamespacedControllerRevisionWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ControllerRevision
     * @param param the request object
     */
    public listNamespacedControllerRevision(param: AppsV1ApiListNamespacedControllerRevisionRequest, options?: Configuration): Promise<V1ControllerRevisionList> {
        return this.api.listNamespacedControllerRevision(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DaemonSet
     * @param param the request object
     */
    public listNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiListNamespacedDaemonSetRequest, options?: Configuration): Promise<HttpInfo<V1DaemonSetList>> {
        return this.api.listNamespacedDaemonSetWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DaemonSet
     * @param param the request object
     */
    public listNamespacedDaemonSet(param: AppsV1ApiListNamespacedDaemonSetRequest, options?: Configuration): Promise<V1DaemonSetList> {
        return this.api.listNamespacedDaemonSet(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Deployment
     * @param param the request object
     */
    public listNamespacedDeploymentWithHttpInfo(param: AppsV1ApiListNamespacedDeploymentRequest, options?: Configuration): Promise<HttpInfo<V1DeploymentList>> {
        return this.api.listNamespacedDeploymentWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Deployment
     * @param param the request object
     */
    public listNamespacedDeployment(param: AppsV1ApiListNamespacedDeploymentRequest, options?: Configuration): Promise<V1DeploymentList> {
        return this.api.listNamespacedDeployment(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicaSet
     * @param param the request object
     */
    public listNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiListNamespacedReplicaSetRequest, options?: Configuration): Promise<HttpInfo<V1ReplicaSetList>> {
        return this.api.listNamespacedReplicaSetWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicaSet
     * @param param the request object
     */
    public listNamespacedReplicaSet(param: AppsV1ApiListNamespacedReplicaSetRequest, options?: Configuration): Promise<V1ReplicaSetList> {
        return this.api.listNamespacedReplicaSet(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StatefulSet
     * @param param the request object
     */
    public listNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiListNamespacedStatefulSetRequest, options?: Configuration): Promise<HttpInfo<V1StatefulSetList>> {
        return this.api.listNamespacedStatefulSetWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StatefulSet
     * @param param the request object
     */
    public listNamespacedStatefulSet(param: AppsV1ApiListNamespacedStatefulSetRequest, options?: Configuration): Promise<V1StatefulSetList> {
        return this.api.listNamespacedStatefulSet(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicaSet
     * @param param the request object
     */
    public listReplicaSetForAllNamespacesWithHttpInfo(param: AppsV1ApiListReplicaSetForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1ReplicaSetList>> {
        return this.api.listReplicaSetForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicaSet
     * @param param the request object
     */
    public listReplicaSetForAllNamespaces(param: AppsV1ApiListReplicaSetForAllNamespacesRequest = {}, options?: Configuration): Promise<V1ReplicaSetList> {
        return this.api.listReplicaSetForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StatefulSet
     * @param param the request object
     */
    public listStatefulSetForAllNamespacesWithHttpInfo(param: AppsV1ApiListStatefulSetForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1StatefulSetList>> {
        return this.api.listStatefulSetForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StatefulSet
     * @param param the request object
     */
    public listStatefulSetForAllNamespaces(param: AppsV1ApiListStatefulSetForAllNamespacesRequest = {}, options?: Configuration): Promise<V1StatefulSetList> {
        return this.api.listStatefulSetForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified ControllerRevision
     * @param param the request object
     */
    public patchNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiPatchNamespacedControllerRevisionRequest, options?: Configuration): Promise<HttpInfo<V1ControllerRevision>> {
        return this.api.patchNamespacedControllerRevisionWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ControllerRevision
     * @param param the request object
     */
    public patchNamespacedControllerRevision(param: AppsV1ApiPatchNamespacedControllerRevisionRequest, options?: Configuration): Promise<V1ControllerRevision> {
        return this.api.patchNamespacedControllerRevision(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified DaemonSet
     * @param param the request object
     */
    public patchNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiPatchNamespacedDaemonSetRequest, options?: Configuration): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.patchNamespacedDaemonSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified DaemonSet
     * @param param the request object
     */
    public patchNamespacedDaemonSet(param: AppsV1ApiPatchNamespacedDaemonSetRequest, options?: Configuration): Promise<V1DaemonSet> {
        return this.api.patchNamespacedDaemonSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified DaemonSet
     * @param param the request object
     */
    public patchNamespacedDaemonSetStatusWithHttpInfo(param: AppsV1ApiPatchNamespacedDaemonSetStatusRequest, options?: Configuration): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.patchNamespacedDaemonSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified DaemonSet
     * @param param the request object
     */
    public patchNamespacedDaemonSetStatus(param: AppsV1ApiPatchNamespacedDaemonSetStatusRequest, options?: Configuration): Promise<V1DaemonSet> {
        return this.api.patchNamespacedDaemonSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeploymentWithHttpInfo(param: AppsV1ApiPatchNamespacedDeploymentRequest, options?: Configuration): Promise<HttpInfo<V1Deployment>> {
        return this.api.patchNamespacedDeploymentWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeployment(param: AppsV1ApiPatchNamespacedDeploymentRequest, options?: Configuration): Promise<V1Deployment> {
        return this.api.patchNamespacedDeployment(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeploymentScaleWithHttpInfo(param: AppsV1ApiPatchNamespacedDeploymentScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.patchNamespacedDeploymentScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeploymentScale(param: AppsV1ApiPatchNamespacedDeploymentScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.patchNamespacedDeploymentScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeploymentStatusWithHttpInfo(param: AppsV1ApiPatchNamespacedDeploymentStatusRequest, options?: Configuration): Promise<HttpInfo<V1Deployment>> {
        return this.api.patchNamespacedDeploymentStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeploymentStatus(param: AppsV1ApiPatchNamespacedDeploymentStatusRequest, options?: Configuration): Promise<V1Deployment> {
        return this.api.patchNamespacedDeploymentStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiPatchNamespacedReplicaSetRequest, options?: Configuration): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.patchNamespacedReplicaSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSet(param: AppsV1ApiPatchNamespacedReplicaSetRequest, options?: Configuration): Promise<V1ReplicaSet> {
        return this.api.patchNamespacedReplicaSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSetScaleWithHttpInfo(param: AppsV1ApiPatchNamespacedReplicaSetScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.patchNamespacedReplicaSetScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSetScale(param: AppsV1ApiPatchNamespacedReplicaSetScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.patchNamespacedReplicaSetScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSetStatusWithHttpInfo(param: AppsV1ApiPatchNamespacedReplicaSetStatusRequest, options?: Configuration): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.patchNamespacedReplicaSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSetStatus(param: AppsV1ApiPatchNamespacedReplicaSetStatusRequest, options?: Configuration): Promise<V1ReplicaSet> {
        return this.api.patchNamespacedReplicaSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiPatchNamespacedStatefulSetRequest, options?: Configuration): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.patchNamespacedStatefulSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSet(param: AppsV1ApiPatchNamespacedStatefulSetRequest, options?: Configuration): Promise<V1StatefulSet> {
        return this.api.patchNamespacedStatefulSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSetScaleWithHttpInfo(param: AppsV1ApiPatchNamespacedStatefulSetScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.patchNamespacedStatefulSetScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSetScale(param: AppsV1ApiPatchNamespacedStatefulSetScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.patchNamespacedStatefulSetScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSetStatusWithHttpInfo(param: AppsV1ApiPatchNamespacedStatefulSetStatusRequest, options?: Configuration): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.patchNamespacedStatefulSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSetStatus(param: AppsV1ApiPatchNamespacedStatefulSetStatusRequest, options?: Configuration): Promise<V1StatefulSet> {
        return this.api.patchNamespacedStatefulSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified ControllerRevision
     * @param param the request object
     */
    public readNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiReadNamespacedControllerRevisionRequest, options?: Configuration): Promise<HttpInfo<V1ControllerRevision>> {
        return this.api.readNamespacedControllerRevisionWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ControllerRevision
     * @param param the request object
     */
    public readNamespacedControllerRevision(param: AppsV1ApiReadNamespacedControllerRevisionRequest, options?: Configuration): Promise<V1ControllerRevision> {
        return this.api.readNamespacedControllerRevision(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified DaemonSet
     * @param param the request object
     */
    public readNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiReadNamespacedDaemonSetRequest, options?: Configuration): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.readNamespacedDaemonSetWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified DaemonSet
     * @param param the request object
     */
    public readNamespacedDaemonSet(param: AppsV1ApiReadNamespacedDaemonSetRequest, options?: Configuration): Promise<V1DaemonSet> {
        return this.api.readNamespacedDaemonSet(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified DaemonSet
     * @param param the request object
     */
    public readNamespacedDaemonSetStatusWithHttpInfo(param: AppsV1ApiReadNamespacedDaemonSetStatusRequest, options?: Configuration): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.readNamespacedDaemonSetStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified DaemonSet
     * @param param the request object
     */
    public readNamespacedDaemonSetStatus(param: AppsV1ApiReadNamespacedDaemonSetStatusRequest, options?: Configuration): Promise<V1DaemonSet> {
        return this.api.readNamespacedDaemonSetStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeploymentWithHttpInfo(param: AppsV1ApiReadNamespacedDeploymentRequest, options?: Configuration): Promise<HttpInfo<V1Deployment>> {
        return this.api.readNamespacedDeploymentWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeployment(param: AppsV1ApiReadNamespacedDeploymentRequest, options?: Configuration): Promise<V1Deployment> {
        return this.api.readNamespacedDeployment(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeploymentScaleWithHttpInfo(param: AppsV1ApiReadNamespacedDeploymentScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.readNamespacedDeploymentScaleWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeploymentScale(param: AppsV1ApiReadNamespacedDeploymentScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.readNamespacedDeploymentScale(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeploymentStatusWithHttpInfo(param: AppsV1ApiReadNamespacedDeploymentStatusRequest, options?: Configuration): Promise<HttpInfo<V1Deployment>> {
        return this.api.readNamespacedDeploymentStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeploymentStatus(param: AppsV1ApiReadNamespacedDeploymentStatusRequest, options?: Configuration): Promise<V1Deployment> {
        return this.api.readNamespacedDeploymentStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiReadNamespacedReplicaSetRequest, options?: Configuration): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.readNamespacedReplicaSetWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSet(param: AppsV1ApiReadNamespacedReplicaSetRequest, options?: Configuration): Promise<V1ReplicaSet> {
        return this.api.readNamespacedReplicaSet(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSetScaleWithHttpInfo(param: AppsV1ApiReadNamespacedReplicaSetScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.readNamespacedReplicaSetScaleWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSetScale(param: AppsV1ApiReadNamespacedReplicaSetScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.readNamespacedReplicaSetScale(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSetStatusWithHttpInfo(param: AppsV1ApiReadNamespacedReplicaSetStatusRequest, options?: Configuration): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.readNamespacedReplicaSetStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSetStatus(param: AppsV1ApiReadNamespacedReplicaSetStatusRequest, options?: Configuration): Promise<V1ReplicaSet> {
        return this.api.readNamespacedReplicaSetStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiReadNamespacedStatefulSetRequest, options?: Configuration): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.readNamespacedStatefulSetWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSet(param: AppsV1ApiReadNamespacedStatefulSetRequest, options?: Configuration): Promise<V1StatefulSet> {
        return this.api.readNamespacedStatefulSet(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSetScaleWithHttpInfo(param: AppsV1ApiReadNamespacedStatefulSetScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.readNamespacedStatefulSetScaleWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSetScale(param: AppsV1ApiReadNamespacedStatefulSetScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.readNamespacedStatefulSetScale(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSetStatusWithHttpInfo(param: AppsV1ApiReadNamespacedStatefulSetStatusRequest, options?: Configuration): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.readNamespacedStatefulSetStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSetStatus(param: AppsV1ApiReadNamespacedStatefulSetStatusRequest, options?: Configuration): Promise<V1StatefulSet> {
        return this.api.readNamespacedStatefulSetStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified ControllerRevision
     * @param param the request object
     */
    public replaceNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiReplaceNamespacedControllerRevisionRequest, options?: Configuration): Promise<HttpInfo<V1ControllerRevision>> {
        return this.api.replaceNamespacedControllerRevisionWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ControllerRevision
     * @param param the request object
     */
    public replaceNamespacedControllerRevision(param: AppsV1ApiReplaceNamespacedControllerRevisionRequest, options?: Configuration): Promise<V1ControllerRevision> {
        return this.api.replaceNamespacedControllerRevision(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified DaemonSet
     * @param param the request object
     */
    public replaceNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiReplaceNamespacedDaemonSetRequest, options?: Configuration): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.replaceNamespacedDaemonSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified DaemonSet
     * @param param the request object
     */
    public replaceNamespacedDaemonSet(param: AppsV1ApiReplaceNamespacedDaemonSetRequest, options?: Configuration): Promise<V1DaemonSet> {
        return this.api.replaceNamespacedDaemonSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified DaemonSet
     * @param param the request object
     */
    public replaceNamespacedDaemonSetStatusWithHttpInfo(param: AppsV1ApiReplaceNamespacedDaemonSetStatusRequest, options?: Configuration): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.replaceNamespacedDaemonSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified DaemonSet
     * @param param the request object
     */
    public replaceNamespacedDaemonSetStatus(param: AppsV1ApiReplaceNamespacedDaemonSetStatusRequest, options?: Configuration): Promise<V1DaemonSet> {
        return this.api.replaceNamespacedDaemonSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeploymentWithHttpInfo(param: AppsV1ApiReplaceNamespacedDeploymentRequest, options?: Configuration): Promise<HttpInfo<V1Deployment>> {
        return this.api.replaceNamespacedDeploymentWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeployment(param: AppsV1ApiReplaceNamespacedDeploymentRequest, options?: Configuration): Promise<V1Deployment> {
        return this.api.replaceNamespacedDeployment(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeploymentScaleWithHttpInfo(param: AppsV1ApiReplaceNamespacedDeploymentScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.replaceNamespacedDeploymentScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeploymentScale(param: AppsV1ApiReplaceNamespacedDeploymentScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.replaceNamespacedDeploymentScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeploymentStatusWithHttpInfo(param: AppsV1ApiReplaceNamespacedDeploymentStatusRequest, options?: Configuration): Promise<HttpInfo<V1Deployment>> {
        return this.api.replaceNamespacedDeploymentStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeploymentStatus(param: AppsV1ApiReplaceNamespacedDeploymentStatusRequest, options?: Configuration): Promise<V1Deployment> {
        return this.api.replaceNamespacedDeploymentStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiReplaceNamespacedReplicaSetRequest, options?: Configuration): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.replaceNamespacedReplicaSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSet(param: AppsV1ApiReplaceNamespacedReplicaSetRequest, options?: Configuration): Promise<V1ReplicaSet> {
        return this.api.replaceNamespacedReplicaSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSetScaleWithHttpInfo(param: AppsV1ApiReplaceNamespacedReplicaSetScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.replaceNamespacedReplicaSetScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSetScale(param: AppsV1ApiReplaceNamespacedReplicaSetScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.replaceNamespacedReplicaSetScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSetStatusWithHttpInfo(param: AppsV1ApiReplaceNamespacedReplicaSetStatusRequest, options?: Configuration): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.replaceNamespacedReplicaSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSetStatus(param: AppsV1ApiReplaceNamespacedReplicaSetStatusRequest, options?: Configuration): Promise<V1ReplicaSet> {
        return this.api.replaceNamespacedReplicaSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiReplaceNamespacedStatefulSetRequest, options?: Configuration): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.replaceNamespacedStatefulSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSet(param: AppsV1ApiReplaceNamespacedStatefulSetRequest, options?: Configuration): Promise<V1StatefulSet> {
        return this.api.replaceNamespacedStatefulSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSetScaleWithHttpInfo(param: AppsV1ApiReplaceNamespacedStatefulSetScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.replaceNamespacedStatefulSetScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSetScale(param: AppsV1ApiReplaceNamespacedStatefulSetScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.replaceNamespacedStatefulSetScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSetStatusWithHttpInfo(param: AppsV1ApiReplaceNamespacedStatefulSetStatusRequest, options?: Configuration): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.replaceNamespacedStatefulSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSetStatus(param: AppsV1ApiReplaceNamespacedStatefulSetStatusRequest, options?: Configuration): Promise<V1StatefulSet> {
        return this.api.replaceNamespacedStatefulSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableAuthenticationApi } from "./ObservableAPI";
import { AuthenticationApiRequestFactory, AuthenticationApiResponseProcessor} from "../apis/AuthenticationApi";

export interface AuthenticationApiGetAPIGroupRequest {
}

export class ObjectAuthenticationApi {
    private api: ObservableAuthenticationApi

    public constructor(configuration: Configuration, requestFactory?: AuthenticationApiRequestFactory, responseProcessor?: AuthenticationApiResponseProcessor) {
        this.api = new ObservableAuthenticationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: AuthenticationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: AuthenticationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableAuthenticationV1Api } from "./ObservableAPI";
import { AuthenticationV1ApiRequestFactory, AuthenticationV1ApiResponseProcessor} from "../apis/AuthenticationV1Api";

export interface AuthenticationV1ApiCreateTokenReviewRequest {
    /**
     * 
     * @type V1TokenReview
     * @memberof AuthenticationV1ApicreateTokenReview
     */
    body: V1TokenReview
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthenticationV1ApicreateTokenReview
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthenticationV1ApicreateTokenReview
     */
    fieldManager?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthenticationV1ApicreateTokenReview
     */
    pretty?: string
}

export interface AuthenticationV1ApiGetAPIResourcesRequest {
}

export class ObjectAuthenticationV1Api {
    private api: ObservableAuthenticationV1Api

    public constructor(configuration: Configuration, requestFactory?: AuthenticationV1ApiRequestFactory, responseProcessor?: AuthenticationV1ApiResponseProcessor) {
        this.api = new ObservableAuthenticationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a TokenReview
     * @param param the request object
     */
    public createTokenReviewWithHttpInfo(param: AuthenticationV1ApiCreateTokenReviewRequest, options?: Configuration): Promise<HttpInfo<V1TokenReview>> {
        return this.api.createTokenReviewWithHttpInfo(param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a TokenReview
     * @param param the request object
     */
    public createTokenReview(param: AuthenticationV1ApiCreateTokenReviewRequest, options?: Configuration): Promise<V1TokenReview> {
        return this.api.createTokenReview(param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AuthenticationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AuthenticationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

}

import { ObservableAuthorizationApi } from "./ObservableAPI";
import { AuthorizationApiRequestFactory, AuthorizationApiResponseProcessor} from "../apis/AuthorizationApi";

export interface AuthorizationApiGetAPIGroupRequest {
}

export class ObjectAuthorizationApi {
    private api: ObservableAuthorizationApi

    public constructor(configuration: Configuration, requestFactory?: AuthorizationApiRequestFactory, responseProcessor?: AuthorizationApiResponseProcessor) {
        this.api = new ObservableAuthorizationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: AuthorizationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: AuthorizationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableAuthorizationV1Api } from "./ObservableAPI";
import { AuthorizationV1ApiRequestFactory, AuthorizationV1ApiResponseProcessor} from "../apis/AuthorizationV1Api";

export interface AuthorizationV1ApiCreateNamespacedLocalSubjectAccessReviewRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AuthorizationV1ApicreateNamespacedLocalSubjectAccessReview
     */
    namespace: string
    /**
     * 
     * @type V1LocalSubjectAccessReview
     * @memberof AuthorizationV1ApicreateNamespacedLocalSubjectAccessReview
     */
    body: V1LocalSubjectAccessReview
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1ApicreateNamespacedLocalSubjectAccessReview
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1ApicreateNamespacedLocalSubjectAccessReview
     */
    fieldManager?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1ApicreateNamespacedLocalSubjectAccessReview
     */
    pretty?: string
}

export interface AuthorizationV1ApiCreateSelfSubjectAccessReviewRequest {
    /**
     * 
     * @type V1SelfSubjectAccessReview
     * @memberof AuthorizationV1ApicreateSelfSubjectAccessReview
     */
    body: V1SelfSubjectAccessReview
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectAccessReview
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectAccessReview
     */
    fieldManager?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectAccessReview
     */
    pretty?: string
}

export interface AuthorizationV1ApiCreateSelfSubjectRulesReviewRequest {
    /**
     * 
     * @type V1SelfSubjectRulesReview
     * @memberof AuthorizationV1ApicreateSelfSubjectRulesReview
     */
    body: V1SelfSubjectRulesReview
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectRulesReview
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectRulesReview
     */
    fieldManager?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectRulesReview
     */
    pretty?: string
}

export interface AuthorizationV1ApiCreateSubjectAccessReviewRequest {
    /**
     * 
     * @type V1SubjectAccessReview
     * @memberof AuthorizationV1ApicreateSubjectAccessReview
     */
    body: V1SubjectAccessReview
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1ApicreateSubjectAccessReview
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1ApicreateSubjectAccessReview
     */
    fieldManager?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1ApicreateSubjectAccessReview
     */
    pretty?: string
}

export interface AuthorizationV1ApiGetAPIResourcesRequest {
}

export class ObjectAuthorizationV1Api {
    private api: ObservableAuthorizationV1Api

    public constructor(configuration: Configuration, requestFactory?: AuthorizationV1ApiRequestFactory, responseProcessor?: AuthorizationV1ApiResponseProcessor) {
        this.api = new ObservableAuthorizationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a LocalSubjectAccessReview
     * @param param the request object
     */
    public createNamespacedLocalSubjectAccessReviewWithHttpInfo(param: AuthorizationV1ApiCreateNamespacedLocalSubjectAccessReviewRequest, options?: Configuration): Promise<HttpInfo<V1LocalSubjectAccessReview>> {
        return this.api.createNamespacedLocalSubjectAccessReviewWithHttpInfo(param.namespace, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a LocalSubjectAccessReview
     * @param param the request object
     */
    public createNamespacedLocalSubjectAccessReview(param: AuthorizationV1ApiCreateNamespacedLocalSubjectAccessReviewRequest, options?: Configuration): Promise<V1LocalSubjectAccessReview> {
        return this.api.createNamespacedLocalSubjectAccessReview(param.namespace, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a SelfSubjectAccessReview
     * @param param the request object
     */
    public createSelfSubjectAccessReviewWithHttpInfo(param: AuthorizationV1ApiCreateSelfSubjectAccessReviewRequest, options?: Configuration): Promise<HttpInfo<V1SelfSubjectAccessReview>> {
        return this.api.createSelfSubjectAccessReviewWithHttpInfo(param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a SelfSubjectAccessReview
     * @param param the request object
     */
    public createSelfSubjectAccessReview(param: AuthorizationV1ApiCreateSelfSubjectAccessReviewRequest, options?: Configuration): Promise<V1SelfSubjectAccessReview> {
        return this.api.createSelfSubjectAccessReview(param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a SelfSubjectRulesReview
     * @param param the request object
     */
    public createSelfSubjectRulesReviewWithHttpInfo(param: AuthorizationV1ApiCreateSelfSubjectRulesReviewRequest, options?: Configuration): Promise<HttpInfo<V1SelfSubjectRulesReview>> {
        return this.api.createSelfSubjectRulesReviewWithHttpInfo(param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a SelfSubjectRulesReview
     * @param param the request object
     */
    public createSelfSubjectRulesReview(param: AuthorizationV1ApiCreateSelfSubjectRulesReviewRequest, options?: Configuration): Promise<V1SelfSubjectRulesReview> {
        return this.api.createSelfSubjectRulesReview(param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a SubjectAccessReview
     * @param param the request object
     */
    public createSubjectAccessReviewWithHttpInfo(param: AuthorizationV1ApiCreateSubjectAccessReviewRequest, options?: Configuration): Promise<HttpInfo<V1SubjectAccessReview>> {
        return this.api.createSubjectAccessReviewWithHttpInfo(param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a SubjectAccessReview
     * @param param the request object
     */
    public createSubjectAccessReview(param: AuthorizationV1ApiCreateSubjectAccessReviewRequest, options?: Configuration): Promise<V1SubjectAccessReview> {
        return this.api.createSubjectAccessReview(param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AuthorizationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AuthorizationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

}

import { ObservableAutoscalingApi } from "./ObservableAPI";
import { AutoscalingApiRequestFactory, AutoscalingApiResponseProcessor} from "../apis/AutoscalingApi";

export interface AutoscalingApiGetAPIGroupRequest {
}

export class ObjectAutoscalingApi {
    private api: ObservableAutoscalingApi

    public constructor(configuration: Configuration, requestFactory?: AutoscalingApiRequestFactory, responseProcessor?: AutoscalingApiResponseProcessor) {
        this.api = new ObservableAutoscalingApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: AutoscalingApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: AutoscalingApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableAutoscalingV1Api } from "./ObservableAPI";
import { AutoscalingV1ApiRequestFactory, AutoscalingV1ApiResponseProcessor} from "../apis/AutoscalingV1Api";

export interface AutoscalingV1ApiCreateNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApicreateNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type V1HorizontalPodAutoscaler
     * @memberof AutoscalingV1ApicreateNamespacedHorizontalPodAutoscaler
     */
    body: V1HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApicreateNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApicreateNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV1ApicreateNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
}

export interface AutoscalingV1ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    body?: V1DeleteOptions
}

export interface AutoscalingV1ApiDeleteNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    body?: V1DeleteOptions
}

export interface AutoscalingV1ApiGetAPIResourcesRequest {
}

export interface AutoscalingV1ApiListHorizontalPodAutoscalerForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    watch?: boolean
}

export interface AutoscalingV1ApiListNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    watch?: boolean
}

export interface AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    force?: boolean
}

export interface AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    force?: boolean
}

export interface AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
}

export interface AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
}

export interface AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type V1HorizontalPodAutoscaler
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    body: V1HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
}

export interface AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * 
     * @type V1HorizontalPodAutoscaler
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    body: V1HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    fieldManager?: string
}

export class ObjectAutoscalingV1Api {
    private api: ObservableAutoscalingV1Api

    public constructor(configuration: Configuration, requestFactory?: AutoscalingV1ApiRequestFactory, responseProcessor?: AutoscalingV1ApiResponseProcessor) {
        this.api = new ObservableAutoscalingV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
    public createNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiCreateNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.createNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
    public createNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiCreateNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V1HorizontalPodAutoscaler> {
        return this.api.createNamespacedHorizontalPodAutoscaler(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteCollectionNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteCollectionNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedHorizontalPodAutoscaler(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiDeleteNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiDeleteNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AutoscalingV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AutoscalingV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listHorizontalPodAutoscalerForAllNamespacesWithHttpInfo(param: AutoscalingV1ApiListHorizontalPodAutoscalerForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1HorizontalPodAutoscalerList>> {
        return this.api.listHorizontalPodAutoscalerForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listHorizontalPodAutoscalerForAllNamespaces(param: AutoscalingV1ApiListHorizontalPodAutoscalerForAllNamespacesRequest = {}, options?: Configuration): Promise<V1HorizontalPodAutoscalerList> {
        return this.api.listHorizontalPodAutoscalerForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiListNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V1HorizontalPodAutoscalerList>> {
        return this.api.listNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiListNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V1HorizontalPodAutoscalerList> {
        return this.api.listNamespacedHorizontalPodAutoscaler(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.patchNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V1HorizontalPodAutoscaler> {
        return this.api.patchNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.patchNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<V1HorizontalPodAutoscaler> {
        return this.api.patchNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.readNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V1HorizontalPodAutoscaler> {
        return this.api.readNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.readNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<V1HorizontalPodAutoscaler> {
        return this.api.readNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V1HorizontalPodAutoscaler> {
        return this.api.replaceNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<V1HorizontalPodAutoscaler> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableAutoscalingV2beta1Api } from "./ObservableAPI";
import { AutoscalingV2beta1ApiRequestFactory, AutoscalingV2beta1ApiResponseProcessor} from "../apis/AutoscalingV2beta1Api";

export interface AutoscalingV2beta1ApiCreateNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApicreateNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type V2beta1HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta1ApicreateNamespacedHorizontalPodAutoscaler
     */
    body: V2beta1HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApicreateNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApicreateNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta1ApicreateNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
}

export interface AutoscalingV2beta1ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AutoscalingV2beta1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    body?: V1DeleteOptions
}

export interface AutoscalingV2beta1ApiDeleteNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApideleteNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApideleteNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApideleteNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV2beta1ApideleteNamespacedHorizontalPodAutoscaler
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV2beta1ApideleteNamespacedHorizontalPodAutoscaler
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteNamespacedHorizontalPodAutoscaler
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AutoscalingV2beta1ApideleteNamespacedHorizontalPodAutoscaler
     */
    body?: V1DeleteOptions
}

export interface AutoscalingV2beta1ApiGetAPIResourcesRequest {
}

export interface AutoscalingV2beta1ApiListHorizontalPodAutoscalerForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    watch?: boolean
}

export interface AutoscalingV2beta1ApiListNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApilistNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApilistNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta1ApilistNamespacedHorizontalPodAutoscaler
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta1ApilistNamespacedHorizontalPodAutoscaler
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApilistNamespacedHorizontalPodAutoscaler
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApilistNamespacedHorizontalPodAutoscaler
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta1ApilistNamespacedHorizontalPodAutoscaler
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApilistNamespacedHorizontalPodAutoscaler
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApilistNamespacedHorizontalPodAutoscaler
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta1ApilistNamespacedHorizontalPodAutoscaler
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta1ApilistNamespacedHorizontalPodAutoscaler
     */
    watch?: boolean
}

export interface AutoscalingV2beta1ApiPatchNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscaler
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscaler
     */
    force?: boolean
}

export interface AutoscalingV2beta1ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV2beta1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    force?: boolean
}

export interface AutoscalingV2beta1ApiReadNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApireadNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApireadNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApireadNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
}

export interface AutoscalingV2beta1ApiReadNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
}

export interface AutoscalingV2beta1ApiReplaceNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type V2beta1HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    body: V2beta1HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
}

export interface AutoscalingV2beta1ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * 
     * @type V2beta1HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    body: V2beta1HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    fieldManager?: string
}

export class ObjectAutoscalingV2beta1Api {
    private api: ObservableAutoscalingV2beta1Api

    public constructor(configuration: Configuration, requestFactory?: AutoscalingV2beta1ApiRequestFactory, responseProcessor?: AutoscalingV2beta1ApiResponseProcessor) {
        this.api = new ObservableAutoscalingV2beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
    public createNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta1ApiCreateNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V2beta1HorizontalPodAutoscaler>> {
        return this.api.createNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
    public createNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta1ApiCreateNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V2beta1HorizontalPodAutoscaler> {
        return this.api.createNamespacedHorizontalPodAutoscaler(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteCollectionNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta1ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteCollectionNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta1ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedHorizontalPodAutoscaler(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta1ApiDeleteNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta1ApiDeleteNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AutoscalingV2beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AutoscalingV2beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listHorizontalPodAutoscalerForAllNamespacesWithHttpInfo(param: AutoscalingV2beta1ApiListHorizontalPodAutoscalerForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V2beta1HorizontalPodAutoscalerList>> {
        return this.api.listHorizontalPodAutoscalerForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listHorizontalPodAutoscalerForAllNamespaces(param: AutoscalingV2beta1ApiListHorizontalPodAutoscalerForAllNamespacesRequest = {}, options?: Configuration): Promise<V2beta1HorizontalPodAutoscalerList> {
        return this.api.listHorizontalPodAutoscalerForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta1ApiListNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V2beta1HorizontalPodAutoscalerList>> {
        return this.api.listNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta1ApiListNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V2beta1HorizontalPodAutoscalerList> {
        return this.api.listNamespacedHorizontalPodAutoscaler(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta1ApiPatchNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V2beta1HorizontalPodAutoscaler>> {
        return this.api.patchNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta1ApiPatchNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V2beta1HorizontalPodAutoscaler> {
        return this.api.patchNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV2beta1ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<HttpInfo<V2beta1HorizontalPodAutoscaler>> {
        return this.api.patchNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV2beta1ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<V2beta1HorizontalPodAutoscaler> {
        return this.api.patchNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta1ApiReadNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V2beta1HorizontalPodAutoscaler>> {
        return this.api.readNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta1ApiReadNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V2beta1HorizontalPodAutoscaler> {
        return this.api.readNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV2beta1ApiReadNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<HttpInfo<V2beta1HorizontalPodAutoscaler>> {
        return this.api.readNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV2beta1ApiReadNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<V2beta1HorizontalPodAutoscaler> {
        return this.api.readNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta1ApiReplaceNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V2beta1HorizontalPodAutoscaler>> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta1ApiReplaceNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V2beta1HorizontalPodAutoscaler> {
        return this.api.replaceNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV2beta1ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<HttpInfo<V2beta1HorizontalPodAutoscaler>> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV2beta1ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<V2beta1HorizontalPodAutoscaler> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableAutoscalingV2beta2Api } from "./ObservableAPI";
import { AutoscalingV2beta2ApiRequestFactory, AutoscalingV2beta2ApiResponseProcessor} from "../apis/AutoscalingV2beta2Api";

export interface AutoscalingV2beta2ApiCreateNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApicreateNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type V2beta2HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta2ApicreateNamespacedHorizontalPodAutoscaler
     */
    body: V2beta2HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApicreateNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApicreateNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta2ApicreateNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
}

export interface AutoscalingV2beta2ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AutoscalingV2beta2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    body?: V1DeleteOptions
}

export interface AutoscalingV2beta2ApiDeleteNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApideleteNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApideleteNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApideleteNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV2beta2ApideleteNamespacedHorizontalPodAutoscaler
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV2beta2ApideleteNamespacedHorizontalPodAutoscaler
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteNamespacedHorizontalPodAutoscaler
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AutoscalingV2beta2ApideleteNamespacedHorizontalPodAutoscaler
     */
    body?: V1DeleteOptions
}

export interface AutoscalingV2beta2ApiGetAPIResourcesRequest {
}

export interface AutoscalingV2beta2ApiListHorizontalPodAutoscalerForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    watch?: boolean
}

export interface AutoscalingV2beta2ApiListNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApilistNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApilistNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta2ApilistNamespacedHorizontalPodAutoscaler
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta2ApilistNamespacedHorizontalPodAutoscaler
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApilistNamespacedHorizontalPodAutoscaler
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApilistNamespacedHorizontalPodAutoscaler
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta2ApilistNamespacedHorizontalPodAutoscaler
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApilistNamespacedHorizontalPodAutoscaler
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApilistNamespacedHorizontalPodAutoscaler
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta2ApilistNamespacedHorizontalPodAutoscaler
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta2ApilistNamespacedHorizontalPodAutoscaler
     */
    watch?: boolean
}

export interface AutoscalingV2beta2ApiPatchNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscaler
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscaler
     */
    force?: boolean
}

export interface AutoscalingV2beta2ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV2beta2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    force?: boolean
}

export interface AutoscalingV2beta2ApiReadNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApireadNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApireadNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApireadNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
}

export interface AutoscalingV2beta2ApiReadNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
}

export interface AutoscalingV2beta2ApiReplaceNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type V2beta2HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    body: V2beta2HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
}

export interface AutoscalingV2beta2ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * 
     * @type V2beta2HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    body: V2beta2HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    fieldManager?: string
}

export class ObjectAutoscalingV2beta2Api {
    private api: ObservableAutoscalingV2beta2Api

    public constructor(configuration: Configuration, requestFactory?: AutoscalingV2beta2ApiRequestFactory, responseProcessor?: AutoscalingV2beta2ApiResponseProcessor) {
        this.api = new ObservableAutoscalingV2beta2Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
    public createNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta2ApiCreateNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V2beta2HorizontalPodAutoscaler>> {
        return this.api.createNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
    public createNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta2ApiCreateNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V2beta2HorizontalPodAutoscaler> {
        return this.api.createNamespacedHorizontalPodAutoscaler(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteCollectionNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta2ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteCollectionNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta2ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedHorizontalPodAutoscaler(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta2ApiDeleteNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta2ApiDeleteNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AutoscalingV2beta2ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AutoscalingV2beta2ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listHorizontalPodAutoscalerForAllNamespacesWithHttpInfo(param: AutoscalingV2beta2ApiListHorizontalPodAutoscalerForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V2beta2HorizontalPodAutoscalerList>> {
        return this.api.listHorizontalPodAutoscalerForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listHorizontalPodAutoscalerForAllNamespaces(param: AutoscalingV2beta2ApiListHorizontalPodAutoscalerForAllNamespacesRequest = {}, options?: Configuration): Promise<V2beta2HorizontalPodAutoscalerList> {
        return this.api.listHorizontalPodAutoscalerForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta2ApiListNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V2beta2HorizontalPodAutoscalerList>> {
        return this.api.listNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta2ApiListNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V2beta2HorizontalPodAutoscalerList> {
        return this.api.listNamespacedHorizontalPodAutoscaler(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta2ApiPatchNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V2beta2HorizontalPodAutoscaler>> {
        return this.api.patchNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta2ApiPatchNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V2beta2HorizontalPodAutoscaler> {
        return this.api.patchNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV2beta2ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<HttpInfo<V2beta2HorizontalPodAutoscaler>> {
        return this.api.patchNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV2beta2ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<V2beta2HorizontalPodAutoscaler> {
        return this.api.patchNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta2ApiReadNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V2beta2HorizontalPodAutoscaler>> {
        return this.api.readNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta2ApiReadNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V2beta2HorizontalPodAutoscaler> {
        return this.api.readNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV2beta2ApiReadNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<HttpInfo<V2beta2HorizontalPodAutoscaler>> {
        return this.api.readNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV2beta2ApiReadNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<V2beta2HorizontalPodAutoscaler> {
        return this.api.readNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2beta2ApiReplaceNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<HttpInfo<V2beta2HorizontalPodAutoscaler>> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscaler(param: AutoscalingV2beta2ApiReplaceNamespacedHorizontalPodAutoscalerRequest, options?: Configuration): Promise<V2beta2HorizontalPodAutoscaler> {
        return this.api.replaceNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV2beta2ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<HttpInfo<V2beta2HorizontalPodAutoscaler>> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV2beta2ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest, options?: Configuration): Promise<V2beta2HorizontalPodAutoscaler> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableBatchApi } from "./ObservableAPI";
import { BatchApiRequestFactory, BatchApiResponseProcessor} from "../apis/BatchApi";

export interface BatchApiGetAPIGroupRequest {
}

export class ObjectBatchApi {
    private api: ObservableBatchApi

    public constructor(configuration: Configuration, requestFactory?: BatchApiRequestFactory, responseProcessor?: BatchApiResponseProcessor) {
        this.api = new ObservableBatchApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: BatchApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: BatchApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableBatchV1Api } from "./ObservableAPI";
import { BatchV1ApiRequestFactory, BatchV1ApiResponseProcessor} from "../apis/BatchV1Api";

export interface BatchV1ApiCreateNamespacedCronJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApicreateNamespacedCronJob
     */
    namespace: string
    /**
     * 
     * @type V1CronJob
     * @memberof BatchV1ApicreateNamespacedCronJob
     */
    body: V1CronJob
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApicreateNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApicreateNamespacedCronJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1ApicreateNamespacedCronJob
     */
    fieldManager?: string
}

export interface BatchV1ApiCreateNamespacedJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApicreateNamespacedJob
     */
    namespace: string
    /**
     * 
     * @type V1Job
     * @memberof BatchV1ApicreateNamespacedJob
     */
    body: V1Job
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApicreateNamespacedJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApicreateNamespacedJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1ApicreateNamespacedJob
     */
    fieldManager?: string
}

export interface BatchV1ApiDeleteCollectionNamespacedCronJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    body?: V1DeleteOptions
}

export interface BatchV1ApiDeleteCollectionNamespacedJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    body?: V1DeleteOptions
}

export interface BatchV1ApiDeleteNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    body?: V1DeleteOptions
}

export interface BatchV1ApiDeleteNamespacedJobRequest {
    /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApideleteNamespacedJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApideleteNamespacedJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApideleteNamespacedJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApideleteNamespacedJob
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV1ApideleteNamespacedJob
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV1ApideleteNamespacedJob
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV1ApideleteNamespacedJob
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof BatchV1ApideleteNamespacedJob
     */
    body?: V1DeleteOptions
}

export interface BatchV1ApiGetAPIResourcesRequest {
}

export interface BatchV1ApiListCronJobForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    watch?: boolean
}

export interface BatchV1ApiListJobForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    watch?: boolean
}

export interface BatchV1ApiListNamespacedCronJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    watch?: boolean
}

export interface BatchV1ApiListNamespacedJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof BatchV1ApilistNamespacedJob
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApilistNamespacedJob
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApilistNamespacedJob
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1ApilistNamespacedJob
     */
    watch?: boolean
}

export interface BatchV1ApiPatchNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    force?: boolean
}

export interface BatchV1ApiPatchNamespacedCronJobStatusRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    force?: boolean
}

export interface BatchV1ApiPatchNamespacedJobRequest {
    /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApipatchNamespacedJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApipatchNamespacedJob
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof BatchV1ApipatchNamespacedJob
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApipatchNamespacedJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApipatchNamespacedJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV1ApipatchNamespacedJob
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV1ApipatchNamespacedJob
     */
    force?: boolean
}

export interface BatchV1ApiPatchNamespacedJobStatusRequest {
    /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    force?: boolean
}

export interface BatchV1ApiReadNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJob
     */
    pretty?: string
}

export interface BatchV1ApiReadNamespacedCronJobStatusRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJobStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJobStatus
     */
    pretty?: string
}

export interface BatchV1ApiReadNamespacedJobRequest {
    /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApireadNamespacedJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireadNamespacedJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireadNamespacedJob
     */
    pretty?: string
}

export interface BatchV1ApiReadNamespacedJobStatusRequest {
    /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApireadNamespacedJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireadNamespacedJobStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireadNamespacedJobStatus
     */
    pretty?: string
}

export interface BatchV1ApiReplaceNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    namespace: string
    /**
     * 
     * @type V1CronJob
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    body: V1CronJob
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    fieldManager?: string
}

export interface BatchV1ApiReplaceNamespacedCronJobStatusRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    namespace: string
    /**
     * 
     * @type V1CronJob
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    body: V1CronJob
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    fieldManager?: string
}

export interface BatchV1ApiReplaceNamespacedJobRequest {
    /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    namespace: string
    /**
     * 
     * @type V1Job
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    body: V1Job
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    fieldManager?: string
}

export interface BatchV1ApiReplaceNamespacedJobStatusRequest {
    /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    namespace: string
    /**
     * 
     * @type V1Job
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    body: V1Job
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    fieldManager?: string
}

export class ObjectBatchV1Api {
    private api: ObservableBatchV1Api

    public constructor(configuration: Configuration, requestFactory?: BatchV1ApiRequestFactory, responseProcessor?: BatchV1ApiResponseProcessor) {
        this.api = new ObservableBatchV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a CronJob
     * @param param the request object
     */
    public createNamespacedCronJobWithHttpInfo(param: BatchV1ApiCreateNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1CronJob>> {
        return this.api.createNamespacedCronJobWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a CronJob
     * @param param the request object
     */
    public createNamespacedCronJob(param: BatchV1ApiCreateNamespacedCronJobRequest, options?: Configuration): Promise<V1CronJob> {
        return this.api.createNamespacedCronJob(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Job
     * @param param the request object
     */
    public createNamespacedJobWithHttpInfo(param: BatchV1ApiCreateNamespacedJobRequest, options?: Configuration): Promise<HttpInfo<V1Job>> {
        return this.api.createNamespacedJobWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Job
     * @param param the request object
     */
    public createNamespacedJob(param: BatchV1ApiCreateNamespacedJobRequest, options?: Configuration): Promise<V1Job> {
        return this.api.createNamespacedJob(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of CronJob
     * @param param the request object
     */
    public deleteCollectionNamespacedCronJobWithHttpInfo(param: BatchV1ApiDeleteCollectionNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedCronJobWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CronJob
     * @param param the request object
     */
    public deleteCollectionNamespacedCronJob(param: BatchV1ApiDeleteCollectionNamespacedCronJobRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedCronJob(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Job
     * @param param the request object
     */
    public deleteCollectionNamespacedJobWithHttpInfo(param: BatchV1ApiDeleteCollectionNamespacedJobRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedJobWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Job
     * @param param the request object
     */
    public deleteCollectionNamespacedJob(param: BatchV1ApiDeleteCollectionNamespacedJobRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedJob(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a CronJob
     * @param param the request object
     */
    public deleteNamespacedCronJobWithHttpInfo(param: BatchV1ApiDeleteNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CronJob
     * @param param the request object
     */
    public deleteNamespacedCronJob(param: BatchV1ApiDeleteNamespacedCronJobRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedCronJob(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Job
     * @param param the request object
     */
    public deleteNamespacedJobWithHttpInfo(param: BatchV1ApiDeleteNamespacedJobRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedJobWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Job
     * @param param the request object
     */
    public deleteNamespacedJob(param: BatchV1ApiDeleteNamespacedJobRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedJob(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: BatchV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: BatchV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listCronJobForAllNamespacesWithHttpInfo(param: BatchV1ApiListCronJobForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1CronJobList>> {
        return this.api.listCronJobForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listCronJobForAllNamespaces(param: BatchV1ApiListCronJobForAllNamespacesRequest = {}, options?: Configuration): Promise<V1CronJobList> {
        return this.api.listCronJobForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Job
     * @param param the request object
     */
    public listJobForAllNamespacesWithHttpInfo(param: BatchV1ApiListJobForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1JobList>> {
        return this.api.listJobForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Job
     * @param param the request object
     */
    public listJobForAllNamespaces(param: BatchV1ApiListJobForAllNamespacesRequest = {}, options?: Configuration): Promise<V1JobList> {
        return this.api.listJobForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listNamespacedCronJobWithHttpInfo(param: BatchV1ApiListNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1CronJobList>> {
        return this.api.listNamespacedCronJobWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listNamespacedCronJob(param: BatchV1ApiListNamespacedCronJobRequest, options?: Configuration): Promise<V1CronJobList> {
        return this.api.listNamespacedCronJob(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Job
     * @param param the request object
     */
    public listNamespacedJobWithHttpInfo(param: BatchV1ApiListNamespacedJobRequest, options?: Configuration): Promise<HttpInfo<V1JobList>> {
        return this.api.listNamespacedJobWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Job
     * @param param the request object
     */
    public listNamespacedJob(param: BatchV1ApiListNamespacedJobRequest, options?: Configuration): Promise<V1JobList> {
        return this.api.listNamespacedJob(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJobWithHttpInfo(param: BatchV1ApiPatchNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1CronJob>> {
        return this.api.patchNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJob(param: BatchV1ApiPatchNamespacedCronJobRequest, options?: Configuration): Promise<V1CronJob> {
        return this.api.patchNamespacedCronJob(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJobStatusWithHttpInfo(param: BatchV1ApiPatchNamespacedCronJobStatusRequest, options?: Configuration): Promise<HttpInfo<V1CronJob>> {
        return this.api.patchNamespacedCronJobStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJobStatus(param: BatchV1ApiPatchNamespacedCronJobStatusRequest, options?: Configuration): Promise<V1CronJob> {
        return this.api.patchNamespacedCronJobStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Job
     * @param param the request object
     */
    public patchNamespacedJobWithHttpInfo(param: BatchV1ApiPatchNamespacedJobRequest, options?: Configuration): Promise<HttpInfo<V1Job>> {
        return this.api.patchNamespacedJobWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Job
     * @param param the request object
     */
    public patchNamespacedJob(param: BatchV1ApiPatchNamespacedJobRequest, options?: Configuration): Promise<V1Job> {
        return this.api.patchNamespacedJob(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Job
     * @param param the request object
     */
    public patchNamespacedJobStatusWithHttpInfo(param: BatchV1ApiPatchNamespacedJobStatusRequest, options?: Configuration): Promise<HttpInfo<V1Job>> {
        return this.api.patchNamespacedJobStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Job
     * @param param the request object
     */
    public patchNamespacedJobStatus(param: BatchV1ApiPatchNamespacedJobStatusRequest, options?: Configuration): Promise<V1Job> {
        return this.api.patchNamespacedJobStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJobWithHttpInfo(param: BatchV1ApiReadNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1CronJob>> {
        return this.api.readNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJob(param: BatchV1ApiReadNamespacedCronJobRequest, options?: Configuration): Promise<V1CronJob> {
        return this.api.readNamespacedCronJob(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJobStatusWithHttpInfo(param: BatchV1ApiReadNamespacedCronJobStatusRequest, options?: Configuration): Promise<HttpInfo<V1CronJob>> {
        return this.api.readNamespacedCronJobStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJobStatus(param: BatchV1ApiReadNamespacedCronJobStatusRequest, options?: Configuration): Promise<V1CronJob> {
        return this.api.readNamespacedCronJobStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Job
     * @param param the request object
     */
    public readNamespacedJobWithHttpInfo(param: BatchV1ApiReadNamespacedJobRequest, options?: Configuration): Promise<HttpInfo<V1Job>> {
        return this.api.readNamespacedJobWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Job
     * @param param the request object
     */
    public readNamespacedJob(param: BatchV1ApiReadNamespacedJobRequest, options?: Configuration): Promise<V1Job> {
        return this.api.readNamespacedJob(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Job
     * @param param the request object
     */
    public readNamespacedJobStatusWithHttpInfo(param: BatchV1ApiReadNamespacedJobStatusRequest, options?: Configuration): Promise<HttpInfo<V1Job>> {
        return this.api.readNamespacedJobStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Job
     * @param param the request object
     */
    public readNamespacedJobStatus(param: BatchV1ApiReadNamespacedJobStatusRequest, options?: Configuration): Promise<V1Job> {
        return this.api.readNamespacedJobStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJobWithHttpInfo(param: BatchV1ApiReplaceNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1CronJob>> {
        return this.api.replaceNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJob(param: BatchV1ApiReplaceNamespacedCronJobRequest, options?: Configuration): Promise<V1CronJob> {
        return this.api.replaceNamespacedCronJob(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJobStatusWithHttpInfo(param: BatchV1ApiReplaceNamespacedCronJobStatusRequest, options?: Configuration): Promise<HttpInfo<V1CronJob>> {
        return this.api.replaceNamespacedCronJobStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJobStatus(param: BatchV1ApiReplaceNamespacedCronJobStatusRequest, options?: Configuration): Promise<V1CronJob> {
        return this.api.replaceNamespacedCronJobStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Job
     * @param param the request object
     */
    public replaceNamespacedJobWithHttpInfo(param: BatchV1ApiReplaceNamespacedJobRequest, options?: Configuration): Promise<HttpInfo<V1Job>> {
        return this.api.replaceNamespacedJobWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Job
     * @param param the request object
     */
    public replaceNamespacedJob(param: BatchV1ApiReplaceNamespacedJobRequest, options?: Configuration): Promise<V1Job> {
        return this.api.replaceNamespacedJob(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Job
     * @param param the request object
     */
    public replaceNamespacedJobStatusWithHttpInfo(param: BatchV1ApiReplaceNamespacedJobStatusRequest, options?: Configuration): Promise<HttpInfo<V1Job>> {
        return this.api.replaceNamespacedJobStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Job
     * @param param the request object
     */
    public replaceNamespacedJobStatus(param: BatchV1ApiReplaceNamespacedJobStatusRequest, options?: Configuration): Promise<V1Job> {
        return this.api.replaceNamespacedJobStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableBatchV1beta1Api } from "./ObservableAPI";
import { BatchV1beta1ApiRequestFactory, BatchV1beta1ApiResponseProcessor} from "../apis/BatchV1beta1Api";

export interface BatchV1beta1ApiCreateNamespacedCronJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApicreateNamespacedCronJob
     */
    namespace: string
    /**
     * 
     * @type V1beta1CronJob
     * @memberof BatchV1beta1ApicreateNamespacedCronJob
     */
    body: V1beta1CronJob
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApicreateNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApicreateNamespacedCronJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1beta1ApicreateNamespacedCronJob
     */
    fieldManager?: string
}

export interface BatchV1beta1ApiDeleteCollectionNamespacedCronJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof BatchV1beta1ApideleteCollectionNamespacedCronJob
     */
    body?: V1DeleteOptions
}

export interface BatchV1beta1ApiDeleteNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApideleteNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApideleteNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApideleteNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApideleteNamespacedCronJob
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV1beta1ApideleteNamespacedCronJob
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV1beta1ApideleteNamespacedCronJob
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV1beta1ApideleteNamespacedCronJob
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof BatchV1beta1ApideleteNamespacedCronJob
     */
    body?: V1DeleteOptions
}

export interface BatchV1beta1ApiGetAPIResourcesRequest {
}

export interface BatchV1beta1ApiListCronJobForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof BatchV1beta1ApilistCronJobForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1beta1ApilistCronJobForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApilistCronJobForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApilistCronJobForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1beta1ApilistCronJobForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApilistCronJobForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApilistCronJobForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApilistCronJobForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1beta1ApilistCronJobForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1beta1ApilistCronJobForAllNamespaces
     */
    watch?: boolean
}

export interface BatchV1beta1ApiListNamespacedCronJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApilistNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApilistNamespacedCronJob
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof BatchV1beta1ApilistNamespacedCronJob
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1beta1ApilistNamespacedCronJob
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApilistNamespacedCronJob
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApilistNamespacedCronJob
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1beta1ApilistNamespacedCronJob
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApilistNamespacedCronJob
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApilistNamespacedCronJob
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1beta1ApilistNamespacedCronJob
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1beta1ApilistNamespacedCronJob
     */
    watch?: boolean
}

export interface BatchV1beta1ApiPatchNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApipatchNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApipatchNamespacedCronJob
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof BatchV1beta1ApipatchNamespacedCronJob
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApipatchNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApipatchNamespacedCronJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV1beta1ApipatchNamespacedCronJob
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV1beta1ApipatchNamespacedCronJob
     */
    force?: boolean
}

export interface BatchV1beta1ApiPatchNamespacedCronJobStatusRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApipatchNamespacedCronJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApipatchNamespacedCronJobStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof BatchV1beta1ApipatchNamespacedCronJobStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApipatchNamespacedCronJobStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApipatchNamespacedCronJobStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV1beta1ApipatchNamespacedCronJobStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV1beta1ApipatchNamespacedCronJobStatus
     */
    force?: boolean
}

export interface BatchV1beta1ApiReadNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApireadNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApireadNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApireadNamespacedCronJob
     */
    pretty?: string
}

export interface BatchV1beta1ApiReadNamespacedCronJobStatusRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApireadNamespacedCronJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApireadNamespacedCronJobStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApireadNamespacedCronJobStatus
     */
    pretty?: string
}

export interface BatchV1beta1ApiReplaceNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApireplaceNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApireplaceNamespacedCronJob
     */
    namespace: string
    /**
     * 
     * @type V1beta1CronJob
     * @memberof BatchV1beta1ApireplaceNamespacedCronJob
     */
    body: V1beta1CronJob
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApireplaceNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApireplaceNamespacedCronJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1beta1ApireplaceNamespacedCronJob
     */
    fieldManager?: string
}

export interface BatchV1beta1ApiReplaceNamespacedCronJobStatusRequest {
    /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApireplaceNamespacedCronJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApireplaceNamespacedCronJobStatus
     */
    namespace: string
    /**
     * 
     * @type V1beta1CronJob
     * @memberof BatchV1beta1ApireplaceNamespacedCronJobStatus
     */
    body: V1beta1CronJob
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApireplaceNamespacedCronJobStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApireplaceNamespacedCronJobStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1beta1ApireplaceNamespacedCronJobStatus
     */
    fieldManager?: string
}

export class ObjectBatchV1beta1Api {
    private api: ObservableBatchV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: BatchV1beta1ApiRequestFactory, responseProcessor?: BatchV1beta1ApiResponseProcessor) {
        this.api = new ObservableBatchV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a CronJob
     * @param param the request object
     */
    public createNamespacedCronJobWithHttpInfo(param: BatchV1beta1ApiCreateNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1beta1CronJob>> {
        return this.api.createNamespacedCronJobWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a CronJob
     * @param param the request object
     */
    public createNamespacedCronJob(param: BatchV1beta1ApiCreateNamespacedCronJobRequest, options?: Configuration): Promise<V1beta1CronJob> {
        return this.api.createNamespacedCronJob(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of CronJob
     * @param param the request object
     */
    public deleteCollectionNamespacedCronJobWithHttpInfo(param: BatchV1beta1ApiDeleteCollectionNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedCronJobWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CronJob
     * @param param the request object
     */
    public deleteCollectionNamespacedCronJob(param: BatchV1beta1ApiDeleteCollectionNamespacedCronJobRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedCronJob(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a CronJob
     * @param param the request object
     */
    public deleteNamespacedCronJobWithHttpInfo(param: BatchV1beta1ApiDeleteNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CronJob
     * @param param the request object
     */
    public deleteNamespacedCronJob(param: BatchV1beta1ApiDeleteNamespacedCronJobRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedCronJob(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: BatchV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: BatchV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listCronJobForAllNamespacesWithHttpInfo(param: BatchV1beta1ApiListCronJobForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1beta1CronJobList>> {
        return this.api.listCronJobForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listCronJobForAllNamespaces(param: BatchV1beta1ApiListCronJobForAllNamespacesRequest = {}, options?: Configuration): Promise<V1beta1CronJobList> {
        return this.api.listCronJobForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listNamespacedCronJobWithHttpInfo(param: BatchV1beta1ApiListNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1beta1CronJobList>> {
        return this.api.listNamespacedCronJobWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listNamespacedCronJob(param: BatchV1beta1ApiListNamespacedCronJobRequest, options?: Configuration): Promise<V1beta1CronJobList> {
        return this.api.listNamespacedCronJob(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJobWithHttpInfo(param: BatchV1beta1ApiPatchNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1beta1CronJob>> {
        return this.api.patchNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJob(param: BatchV1beta1ApiPatchNamespacedCronJobRequest, options?: Configuration): Promise<V1beta1CronJob> {
        return this.api.patchNamespacedCronJob(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJobStatusWithHttpInfo(param: BatchV1beta1ApiPatchNamespacedCronJobStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1CronJob>> {
        return this.api.patchNamespacedCronJobStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJobStatus(param: BatchV1beta1ApiPatchNamespacedCronJobStatusRequest, options?: Configuration): Promise<V1beta1CronJob> {
        return this.api.patchNamespacedCronJobStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJobWithHttpInfo(param: BatchV1beta1ApiReadNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1beta1CronJob>> {
        return this.api.readNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJob(param: BatchV1beta1ApiReadNamespacedCronJobRequest, options?: Configuration): Promise<V1beta1CronJob> {
        return this.api.readNamespacedCronJob(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJobStatusWithHttpInfo(param: BatchV1beta1ApiReadNamespacedCronJobStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1CronJob>> {
        return this.api.readNamespacedCronJobStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJobStatus(param: BatchV1beta1ApiReadNamespacedCronJobStatusRequest, options?: Configuration): Promise<V1beta1CronJob> {
        return this.api.readNamespacedCronJobStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJobWithHttpInfo(param: BatchV1beta1ApiReplaceNamespacedCronJobRequest, options?: Configuration): Promise<HttpInfo<V1beta1CronJob>> {
        return this.api.replaceNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJob(param: BatchV1beta1ApiReplaceNamespacedCronJobRequest, options?: Configuration): Promise<V1beta1CronJob> {
        return this.api.replaceNamespacedCronJob(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJobStatusWithHttpInfo(param: BatchV1beta1ApiReplaceNamespacedCronJobStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1CronJob>> {
        return this.api.replaceNamespacedCronJobStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJobStatus(param: BatchV1beta1ApiReplaceNamespacedCronJobStatusRequest, options?: Configuration): Promise<V1beta1CronJob> {
        return this.api.replaceNamespacedCronJobStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableCertificatesApi } from "./ObservableAPI";
import { CertificatesApiRequestFactory, CertificatesApiResponseProcessor} from "../apis/CertificatesApi";

export interface CertificatesApiGetAPIGroupRequest {
}

export class ObjectCertificatesApi {
    private api: ObservableCertificatesApi

    public constructor(configuration: Configuration, requestFactory?: CertificatesApiRequestFactory, responseProcessor?: CertificatesApiResponseProcessor) {
        this.api = new ObservableCertificatesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: CertificatesApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: CertificatesApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableCertificatesV1Api } from "./ObservableAPI";
import { CertificatesV1ApiRequestFactory, CertificatesV1ApiResponseProcessor} from "../apis/CertificatesV1Api";

export interface CertificatesV1ApiCreateCertificateSigningRequestRequest {
    /**
     * 
     * @type V1CertificateSigningRequest
     * @memberof CertificatesV1ApicreateCertificateSigningRequest
     */
    body: V1CertificateSigningRequest
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApicreateCertificateSigningRequest
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApicreateCertificateSigningRequest
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1ApicreateCertificateSigningRequest
     */
    fieldManager?: string
}

export interface CertificatesV1ApiDeleteCertificateSigningRequestRequest {
    /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    body?: V1DeleteOptions
}

export interface CertificatesV1ApiDeleteCollectionCertificateSigningRequestRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    body?: V1DeleteOptions
}

export interface CertificatesV1ApiGetAPIResourcesRequest {
}

export interface CertificatesV1ApiListCertificateSigningRequestRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    watch?: boolean
}

export interface CertificatesV1ApiPatchCertificateSigningRequestRequest {
    /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    force?: boolean
}

export interface CertificatesV1ApiPatchCertificateSigningRequestApprovalRequest {
    /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    force?: boolean
}

export interface CertificatesV1ApiPatchCertificateSigningRequestStatusRequest {
    /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    force?: boolean
}

export interface CertificatesV1ApiReadCertificateSigningRequestRequest {
    /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequest
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequest
     */
    pretty?: string
}

export interface CertificatesV1ApiReadCertificateSigningRequestApprovalRequest {
    /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequestApproval
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequestApproval
     */
    pretty?: string
}

export interface CertificatesV1ApiReadCertificateSigningRequestStatusRequest {
    /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequestStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequestStatus
     */
    pretty?: string
}

export interface CertificatesV1ApiReplaceCertificateSigningRequestRequest {
    /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequest
     */
    name: string
    /**
     * 
     * @type V1CertificateSigningRequest
     * @memberof CertificatesV1ApireplaceCertificateSigningRequest
     */
    body: V1CertificateSigningRequest
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequest
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequest
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequest
     */
    fieldManager?: string
}

export interface CertificatesV1ApiReplaceCertificateSigningRequestApprovalRequest {
    /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestApproval
     */
    name: string
    /**
     * 
     * @type V1CertificateSigningRequest
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestApproval
     */
    body: V1CertificateSigningRequest
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestApproval
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestApproval
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestApproval
     */
    fieldManager?: string
}

export interface CertificatesV1ApiReplaceCertificateSigningRequestStatusRequest {
    /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestStatus
     */
    name: string
    /**
     * 
     * @type V1CertificateSigningRequest
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestStatus
     */
    body: V1CertificateSigningRequest
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestStatus
     */
    fieldManager?: string
}

export class ObjectCertificatesV1Api {
    private api: ObservableCertificatesV1Api

    public constructor(configuration: Configuration, requestFactory?: CertificatesV1ApiRequestFactory, responseProcessor?: CertificatesV1ApiResponseProcessor) {
        this.api = new ObservableCertificatesV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a CertificateSigningRequest
     * @param param the request object
     */
    public createCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiCreateCertificateSigningRequestRequest, options?: Configuration): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.createCertificateSigningRequestWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a CertificateSigningRequest
     * @param param the request object
     */
    public createCertificateSigningRequest(param: CertificatesV1ApiCreateCertificateSigningRequestRequest, options?: Configuration): Promise<V1CertificateSigningRequest> {
        return this.api.createCertificateSigningRequest(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete a CertificateSigningRequest
     * @param param the request object
     */
    public deleteCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiDeleteCertificateSigningRequestRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCertificateSigningRequestWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CertificateSigningRequest
     * @param param the request object
     */
    public deleteCertificateSigningRequest(param: CertificatesV1ApiDeleteCertificateSigningRequestRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCertificateSigningRequest(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete collection of CertificateSigningRequest
     * @param param the request object
     */
    public deleteCollectionCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiDeleteCollectionCertificateSigningRequestRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionCertificateSigningRequestWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CertificateSigningRequest
     * @param param the request object
     */
    public deleteCollectionCertificateSigningRequest(param: CertificatesV1ApiDeleteCollectionCertificateSigningRequestRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionCertificateSigningRequest(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CertificatesV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CertificatesV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind CertificateSigningRequest
     * @param param the request object
     */
    public listCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiListCertificateSigningRequestRequest = {}, options?: Configuration): Promise<HttpInfo<V1CertificateSigningRequestList>> {
        return this.api.listCertificateSigningRequestWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CertificateSigningRequest
     * @param param the request object
     */
    public listCertificateSigningRequest(param: CertificatesV1ApiListCertificateSigningRequestRequest = {}, options?: Configuration): Promise<V1CertificateSigningRequestList> {
        return this.api.listCertificateSigningRequest(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiPatchCertificateSigningRequestRequest, options?: Configuration): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.patchCertificateSigningRequestWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequest(param: CertificatesV1ApiPatchCertificateSigningRequestRequest, options?: Configuration): Promise<V1CertificateSigningRequest> {
        return this.api.patchCertificateSigningRequest(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequestApprovalWithHttpInfo(param: CertificatesV1ApiPatchCertificateSigningRequestApprovalRequest, options?: Configuration): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.patchCertificateSigningRequestApprovalWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequestApproval(param: CertificatesV1ApiPatchCertificateSigningRequestApprovalRequest, options?: Configuration): Promise<V1CertificateSigningRequest> {
        return this.api.patchCertificateSigningRequestApproval(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequestStatusWithHttpInfo(param: CertificatesV1ApiPatchCertificateSigningRequestStatusRequest, options?: Configuration): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.patchCertificateSigningRequestStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequestStatus(param: CertificatesV1ApiPatchCertificateSigningRequestStatusRequest, options?: Configuration): Promise<V1CertificateSigningRequest> {
        return this.api.patchCertificateSigningRequestStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiReadCertificateSigningRequestRequest, options?: Configuration): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.readCertificateSigningRequestWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequest(param: CertificatesV1ApiReadCertificateSigningRequestRequest, options?: Configuration): Promise<V1CertificateSigningRequest> {
        return this.api.readCertificateSigningRequest(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequestApprovalWithHttpInfo(param: CertificatesV1ApiReadCertificateSigningRequestApprovalRequest, options?: Configuration): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.readCertificateSigningRequestApprovalWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequestApproval(param: CertificatesV1ApiReadCertificateSigningRequestApprovalRequest, options?: Configuration): Promise<V1CertificateSigningRequest> {
        return this.api.readCertificateSigningRequestApproval(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequestStatusWithHttpInfo(param: CertificatesV1ApiReadCertificateSigningRequestStatusRequest, options?: Configuration): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.readCertificateSigningRequestStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequestStatus(param: CertificatesV1ApiReadCertificateSigningRequestStatusRequest, options?: Configuration): Promise<V1CertificateSigningRequest> {
        return this.api.readCertificateSigningRequestStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiReplaceCertificateSigningRequestRequest, options?: Configuration): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.replaceCertificateSigningRequestWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequest(param: CertificatesV1ApiReplaceCertificateSigningRequestRequest, options?: Configuration): Promise<V1CertificateSigningRequest> {
        return this.api.replaceCertificateSigningRequest(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequestApprovalWithHttpInfo(param: CertificatesV1ApiReplaceCertificateSigningRequestApprovalRequest, options?: Configuration): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.replaceCertificateSigningRequestApprovalWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequestApproval(param: CertificatesV1ApiReplaceCertificateSigningRequestApprovalRequest, options?: Configuration): Promise<V1CertificateSigningRequest> {
        return this.api.replaceCertificateSigningRequestApproval(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequestStatusWithHttpInfo(param: CertificatesV1ApiReplaceCertificateSigningRequestStatusRequest, options?: Configuration): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.replaceCertificateSigningRequestStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequestStatus(param: CertificatesV1ApiReplaceCertificateSigningRequestStatusRequest, options?: Configuration): Promise<V1CertificateSigningRequest> {
        return this.api.replaceCertificateSigningRequestStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableCoordinationApi } from "./ObservableAPI";
import { CoordinationApiRequestFactory, CoordinationApiResponseProcessor} from "../apis/CoordinationApi";

export interface CoordinationApiGetAPIGroupRequest {
}

export class ObjectCoordinationApi {
    private api: ObservableCoordinationApi

    public constructor(configuration: Configuration, requestFactory?: CoordinationApiRequestFactory, responseProcessor?: CoordinationApiResponseProcessor) {
        this.api = new ObservableCoordinationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: CoordinationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: CoordinationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableCoordinationV1Api } from "./ObservableAPI";
import { CoordinationV1ApiRequestFactory, CoordinationV1ApiResponseProcessor} from "../apis/CoordinationV1Api";

export interface CoordinationV1ApiCreateNamespacedLeaseRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApicreateNamespacedLease
     */
    namespace: string
    /**
     * 
     * @type V1Lease
     * @memberof CoordinationV1ApicreateNamespacedLease
     */
    body: V1Lease
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApicreateNamespacedLease
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1ApicreateNamespacedLease
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoordinationV1ApicreateNamespacedLease
     */
    fieldManager?: string
}

export interface CoordinationV1ApiDeleteCollectionNamespacedLeaseRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    body?: V1DeleteOptions
}

export interface CoordinationV1ApiDeleteNamespacedLeaseRequest {
    /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    body?: V1DeleteOptions
}

export interface CoordinationV1ApiGetAPIResourcesRequest {
}

export interface CoordinationV1ApiListLeaseForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    watch?: boolean
}

export interface CoordinationV1ApiListNamespacedLeaseRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    watch?: boolean
}

export interface CoordinationV1ApiPatchNamespacedLeaseRequest {
    /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    force?: boolean
}

export interface CoordinationV1ApiReadNamespacedLeaseRequest {
    /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1ApireadNamespacedLease
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApireadNamespacedLease
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApireadNamespacedLease
     */
    pretty?: string
}

export interface CoordinationV1ApiReplaceNamespacedLeaseRequest {
    /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    namespace: string
    /**
     * 
     * @type V1Lease
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    body: V1Lease
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    fieldManager?: string
}

export class ObjectCoordinationV1Api {
    private api: ObservableCoordinationV1Api

    public constructor(configuration: Configuration, requestFactory?: CoordinationV1ApiRequestFactory, responseProcessor?: CoordinationV1ApiResponseProcessor) {
        this.api = new ObservableCoordinationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a Lease
     * @param param the request object
     */
    public createNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiCreateNamespacedLeaseRequest, options?: Configuration): Promise<HttpInfo<V1Lease>> {
        return this.api.createNamespacedLeaseWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Lease
     * @param param the request object
     */
    public createNamespacedLease(param: CoordinationV1ApiCreateNamespacedLeaseRequest, options?: Configuration): Promise<V1Lease> {
        return this.api.createNamespacedLease(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of Lease
     * @param param the request object
     */
    public deleteCollectionNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiDeleteCollectionNamespacedLeaseRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedLeaseWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Lease
     * @param param the request object
     */
    public deleteCollectionNamespacedLease(param: CoordinationV1ApiDeleteCollectionNamespacedLeaseRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedLease(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a Lease
     * @param param the request object
     */
    public deleteNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiDeleteNamespacedLeaseRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedLeaseWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Lease
     * @param param the request object
     */
    public deleteNamespacedLease(param: CoordinationV1ApiDeleteNamespacedLeaseRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedLease(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CoordinationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CoordinationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
    public listLeaseForAllNamespacesWithHttpInfo(param: CoordinationV1ApiListLeaseForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1LeaseList>> {
        return this.api.listLeaseForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
    public listLeaseForAllNamespaces(param: CoordinationV1ApiListLeaseForAllNamespacesRequest = {}, options?: Configuration): Promise<V1LeaseList> {
        return this.api.listLeaseForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
    public listNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiListNamespacedLeaseRequest, options?: Configuration): Promise<HttpInfo<V1LeaseList>> {
        return this.api.listNamespacedLeaseWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
    public listNamespacedLease(param: CoordinationV1ApiListNamespacedLeaseRequest, options?: Configuration): Promise<V1LeaseList> {
        return this.api.listNamespacedLease(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified Lease
     * @param param the request object
     */
    public patchNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiPatchNamespacedLeaseRequest, options?: Configuration): Promise<HttpInfo<V1Lease>> {
        return this.api.patchNamespacedLeaseWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Lease
     * @param param the request object
     */
    public patchNamespacedLease(param: CoordinationV1ApiPatchNamespacedLeaseRequest, options?: Configuration): Promise<V1Lease> {
        return this.api.patchNamespacedLease(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified Lease
     * @param param the request object
     */
    public readNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiReadNamespacedLeaseRequest, options?: Configuration): Promise<HttpInfo<V1Lease>> {
        return this.api.readNamespacedLeaseWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Lease
     * @param param the request object
     */
    public readNamespacedLease(param: CoordinationV1ApiReadNamespacedLeaseRequest, options?: Configuration): Promise<V1Lease> {
        return this.api.readNamespacedLease(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified Lease
     * @param param the request object
     */
    public replaceNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiReplaceNamespacedLeaseRequest, options?: Configuration): Promise<HttpInfo<V1Lease>> {
        return this.api.replaceNamespacedLeaseWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Lease
     * @param param the request object
     */
    public replaceNamespacedLease(param: CoordinationV1ApiReplaceNamespacedLeaseRequest, options?: Configuration): Promise<V1Lease> {
        return this.api.replaceNamespacedLease(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableCoreApi } from "./ObservableAPI";
import { CoreApiRequestFactory, CoreApiResponseProcessor} from "../apis/CoreApi";

export interface CoreApiGetAPIVersionsRequest {
}

export class ObjectCoreApi {
    private api: ObservableCoreApi

    public constructor(configuration: Configuration, requestFactory?: CoreApiRequestFactory, responseProcessor?: CoreApiResponseProcessor) {
        this.api = new ObservableCoreApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get available API versions
     * @param param the request object
     */
    public getAPIVersionsWithHttpInfo(param: CoreApiGetAPIVersionsRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIVersions>> {
        return this.api.getAPIVersionsWithHttpInfo( options).toPromise();
    }

    /**
     * get available API versions
     * @param param the request object
     */
    public getAPIVersions(param: CoreApiGetAPIVersionsRequest = {}, options?: Configuration): Promise<V1APIVersions> {
        return this.api.getAPIVersions( options).toPromise();
    }

}

import { ObservableCoreV1Api } from "./ObservableAPI";
import { CoreV1ApiRequestFactory, CoreV1ApiResponseProcessor} from "../apis/CoreV1Api";

export interface CoreV1ApiConnectDeleteNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectDeleteNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectDeleteNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectDeleteNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectDeleteNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectDeleteNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectDeleteNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectDeleteNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectDeleteNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectDeleteNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectDeleteNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectGetNamespacedPodAttachRequest {
    /**
     * name of the PodAttachOptions
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    namespace: string
    /**
     * The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    container?: string
    /**
     * Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    stderr?: boolean
    /**
     * Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    stdin?: boolean
    /**
     * Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    stdout?: boolean
    /**
     * TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    tty?: boolean
}

export interface CoreV1ApiConnectGetNamespacedPodExecRequest {
    /**
     * name of the PodExecOptions
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    namespace: string
    /**
     * Command is the remote command to execute. argv array. Not executed within a shell.
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    command?: string
    /**
     * Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    container?: string
    /**
     * Redirect the standard error stream of the pod for this call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    stderr?: boolean
    /**
     * Redirect the standard input stream of the pod for this call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    stdin?: boolean
    /**
     * Redirect the standard output stream of the pod for this call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    stdout?: boolean
    /**
     * TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    tty?: boolean
}

export interface CoreV1ApiConnectGetNamespacedPodPortforwardRequest {
    /**
     * name of the PodPortForwardOptions
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodPortforward
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodPortforward
     */
    namespace: string
    /**
     * List of ports to forward Required when using WebSockets
     * @type number
     * @memberof CoreV1ApiconnectGetNamespacedPodPortforward
     */
    ports?: number
}

export interface CoreV1ApiConnectGetNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectGetNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectGetNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectGetNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectGetNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectGetNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectGetNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectGetNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectGetNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectGetNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectGetNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectHeadNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectHeadNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectHeadNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectHeadNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectHeadNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectHeadNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectHeadNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectHeadNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectHeadNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectHeadNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectHeadNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectOptionsNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectOptionsNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectOptionsNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectOptionsNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectOptionsNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectOptionsNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectOptionsNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectOptionsNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectOptionsNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectOptionsNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectOptionsNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPatchNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPatchNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPatchNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPatchNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPatchNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPatchNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectPatchNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPatchNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPatchNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectPatchNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectPatchNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPostNamespacedPodAttachRequest {
    /**
     * name of the PodAttachOptions
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    namespace: string
    /**
     * The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    container?: string
    /**
     * Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    stderr?: boolean
    /**
     * Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    stdin?: boolean
    /**
     * Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    stdout?: boolean
    /**
     * TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    tty?: boolean
}

export interface CoreV1ApiConnectPostNamespacedPodExecRequest {
    /**
     * name of the PodExecOptions
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    namespace: string
    /**
     * Command is the remote command to execute. argv array. Not executed within a shell.
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    command?: string
    /**
     * Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    container?: string
    /**
     * Redirect the standard error stream of the pod for this call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    stderr?: boolean
    /**
     * Redirect the standard input stream of the pod for this call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    stdin?: boolean
    /**
     * Redirect the standard output stream of the pod for this call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    stdout?: boolean
    /**
     * TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    tty?: boolean
}

export interface CoreV1ApiConnectPostNamespacedPodPortforwardRequest {
    /**
     * name of the PodPortForwardOptions
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodPortforward
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodPortforward
     */
    namespace: string
    /**
     * List of ports to forward Required when using WebSockets
     * @type number
     * @memberof CoreV1ApiconnectPostNamespacedPodPortforward
     */
    ports?: number
}

export interface CoreV1ApiConnectPostNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPostNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPostNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPostNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPostNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPostNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectPostNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPostNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPostNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectPostNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectPostNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPutNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPutNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPutNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPutNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPutNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPutNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectPutNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPutNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectPutNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectPutNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectPutNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiCreateNamespaceRequest {
    /**
     * 
     * @type V1Namespace
     * @memberof CoreV1ApicreateNamespace
     */
    body: V1Namespace
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespace
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespace
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespace
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedBindingRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedBinding
     */
    namespace: string
    /**
     * 
     * @type V1Binding
     * @memberof CoreV1ApicreateNamespacedBinding
     */
    body: V1Binding
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedBinding
     */
    fieldManager?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedBinding
     */
    pretty?: string
}

export interface CoreV1ApiCreateNamespacedConfigMapRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedConfigMap
     */
    namespace: string
    /**
     * 
     * @type V1ConfigMap
     * @memberof CoreV1ApicreateNamespacedConfigMap
     */
    body: V1ConfigMap
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedConfigMap
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedConfigMap
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedConfigMap
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedEndpointsRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedEndpoints
     */
    namespace: string
    /**
     * 
     * @type V1Endpoints
     * @memberof CoreV1ApicreateNamespacedEndpoints
     */
    body: V1Endpoints
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedEndpoints
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedEndpoints
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedEndpoints
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type CoreV1Event
     * @memberof CoreV1ApicreateNamespacedEvent
     */
    body: CoreV1Event
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedEvent
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedLimitRangeRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedLimitRange
     */
    namespace: string
    /**
     * 
     * @type V1LimitRange
     * @memberof CoreV1ApicreateNamespacedLimitRange
     */
    body: V1LimitRange
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedLimitRange
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedLimitRange
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedLimitRange
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedPersistentVolumeClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * 
     * @type V1PersistentVolumeClaim
     * @memberof CoreV1ApicreateNamespacedPersistentVolumeClaim
     */
    body: V1PersistentVolumeClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedPersistentVolumeClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedPersistentVolumeClaim
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedPodRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedPod
     */
    namespace: string
    /**
     * 
     * @type V1Pod
     * @memberof CoreV1ApicreateNamespacedPod
     */
    body: V1Pod
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedPod
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedPod
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedPod
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedPodBindingRequest {
    /**
     * name of the Binding
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    namespace: string
    /**
     * 
     * @type V1Binding
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    body: V1Binding
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    fieldManager?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    pretty?: string
}

export interface CoreV1ApiCreateNamespacedPodEvictionRequest {
    /**
     * name of the Eviction
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    namespace: string
    /**
     * 
     * @type V1Eviction
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    body: V1Eviction
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    fieldManager?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    pretty?: string
}

export interface CoreV1ApiCreateNamespacedPodTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodTemplate
     */
    namespace: string
    /**
     * 
     * @type V1PodTemplate
     * @memberof CoreV1ApicreateNamespacedPodTemplate
     */
    body: V1PodTemplate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodTemplate
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedReplicationControllerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedReplicationController
     */
    namespace: string
    /**
     * 
     * @type V1ReplicationController
     * @memberof CoreV1ApicreateNamespacedReplicationController
     */
    body: V1ReplicationController
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedReplicationController
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedReplicationController
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedReplicationController
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedResourceQuotaRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedResourceQuota
     */
    namespace: string
    /**
     * 
     * @type V1ResourceQuota
     * @memberof CoreV1ApicreateNamespacedResourceQuota
     */
    body: V1ResourceQuota
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedResourceQuota
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedResourceQuota
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedResourceQuota
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedSecretRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedSecret
     */
    namespace: string
    /**
     * 
     * @type V1Secret
     * @memberof CoreV1ApicreateNamespacedSecret
     */
    body: V1Secret
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedSecret
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedSecret
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedSecret
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedServiceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedService
     */
    namespace: string
    /**
     * 
     * @type V1Service
     * @memberof CoreV1ApicreateNamespacedService
     */
    body: V1Service
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedService
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedServiceAccountRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccount
     */
    namespace: string
    /**
     * 
     * @type V1ServiceAccount
     * @memberof CoreV1ApicreateNamespacedServiceAccount
     */
    body: V1ServiceAccount
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccount
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccount
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccount
     */
    fieldManager?: string
}

export interface CoreV1ApiCreateNamespacedServiceAccountTokenRequest {
    /**
     * name of the TokenRequest
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    namespace: string
    /**
     * 
     * @type AuthenticationV1TokenRequest
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    body: AuthenticationV1TokenRequest
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    fieldManager?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    pretty?: string
}

export interface CoreV1ApiCreateNodeRequest {
    /**
     * 
     * @type V1Node
     * @memberof CoreV1ApicreateNode
     */
    body: V1Node
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateNode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateNode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateNode
     */
    fieldManager?: string
}

export interface CoreV1ApiCreatePersistentVolumeRequest {
    /**
     * 
     * @type V1PersistentVolume
     * @memberof CoreV1ApicreatePersistentVolume
     */
    body: V1PersistentVolume
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreatePersistentVolume
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreatePersistentVolume
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreatePersistentVolume
     */
    fieldManager?: string
}

export interface CoreV1ApiDeleteCollectionNamespacedConfigMapRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedEndpointsRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedLimitRangeRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedPersistentVolumeClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedPodRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedPodTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedReplicationControllerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedResourceQuotaRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedSecretRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedServiceAccountRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNodeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionNode
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionNode
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNode
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionNode
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNode
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionPersistentVolumeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespaceRequest {
    /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApideleteNamespace
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespace
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespace
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespace
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespace
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespace
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespace
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedConfigMapRequest {
    /**
     * name of the ConfigMap
     * @type string
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedEndpointsRequest {
    /**
     * name of the Endpoints
     * @type string
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedLimitRangeRequest {
    /**
     * name of the LimitRange
     * @type string
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedPersistentVolumeClaimRequest {
    /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedPodRequest {
    /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApideleteNamespacedPod
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedPod
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedPod
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedPod
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedPod
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedPod
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedPod
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedPod
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedPodTemplateRequest {
    /**
     * name of the PodTemplate
     * @type string
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedReplicationControllerRequest {
    /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedResourceQuotaRequest {
    /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedSecretRequest {
    /**
     * name of the Secret
     * @type string
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedServiceRequest {
    /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApideleteNamespacedService
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedService
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedService
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedService
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedService
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedService
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedService
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedServiceAccountRequest {
    /**
     * name of the ServiceAccount
     * @type string
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNodeRequest {
    /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApideleteNode
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteNode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteNode
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteNode
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteNode
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteNode
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNode
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeletePersistentVolumeRequest {
    /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApideletePersistentVolume
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideletePersistentVolume
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideletePersistentVolume
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideletePersistentVolume
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideletePersistentVolume
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideletePersistentVolume
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideletePersistentVolume
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiGetAPIResourcesRequest {
}

export interface CoreV1ApiListComponentStatusRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistComponentStatus
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistComponentStatus
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistComponentStatus
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistComponentStatus
     */
    watch?: boolean
}

export interface CoreV1ApiListConfigMapForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListEndpointsForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListEventForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListLimitRangeForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespaceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespace
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespace
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespace
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespace
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedConfigMapRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedEndpointsRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedEvent
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedEvent
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedEvent
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedEvent
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedLimitRangeRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedPersistentVolumeClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedPodRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPod
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedPod
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedPod
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPod
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedPodTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedReplicationControllerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedResourceQuotaRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedSecretRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedSecret
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedSecret
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedSecret
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedSecret
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedServiceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedService
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedService
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedService
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedService
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedServiceAccountRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    watch?: boolean
}

export interface CoreV1ApiListNodeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistNode
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistNode
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistNode
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNode
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistNode
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistNode
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNode
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistNode
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistNode
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistNode
     */
    watch?: boolean
}

export interface CoreV1ApiListPersistentVolumeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistPersistentVolume
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistPersistentVolume
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistPersistentVolume
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistPersistentVolume
     */
    watch?: boolean
}

export interface CoreV1ApiListPersistentVolumeClaimForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListPodForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListPodTemplateForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListReplicationControllerForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListResourceQuotaForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListSecretForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListServiceAccountForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListServiceForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiPatchNamespaceRequest {
    /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApipatchNamespace
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespace
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespace
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespace
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespace
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespace
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespaceStatusRequest {
    /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedConfigMapRequest {
    /**
     * name of the ConfigMap
     * @type string
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedEndpointsRequest {
    /**
     * name of the Endpoints
     * @type string
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedLimitRangeRequest {
    /**
     * name of the LimitRange
     * @type string
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPersistentVolumeClaimRequest {
    /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPersistentVolumeClaimStatusRequest {
    /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPodRequest {
    /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApipatchNamespacedPod
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedPod
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPod
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedPod
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedPod
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedPod
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPod
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPodEphemeralcontainersRequest {
    /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPodStatusRequest {
    /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPodTemplateRequest {
    /**
     * name of the PodTemplate
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedReplicationControllerRequest {
    /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedReplicationControllerScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedReplicationControllerStatusRequest {
    /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedResourceQuotaRequest {
    /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedResourceQuotaStatusRequest {
    /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedSecretRequest {
    /**
     * name of the Secret
     * @type string
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedServiceRequest {
    /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApipatchNamespacedService
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedService
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedService
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedService
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedService
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedServiceAccountRequest {
    /**
     * name of the ServiceAccount
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedServiceStatusRequest {
    /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNodeRequest {
    /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApipatchNode
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNode
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNode
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNode
     */
    force?: boolean
}

export interface CoreV1ApiPatchNodeStatusRequest {
    /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApipatchNodeStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNodeStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchNodeStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchNodeStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchNodeStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchNodeStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchPersistentVolumeRequest {
    /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApipatchPersistentVolume
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchPersistentVolume
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchPersistentVolume
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchPersistentVolume
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchPersistentVolume
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchPersistentVolume
     */
    force?: boolean
}

export interface CoreV1ApiPatchPersistentVolumeStatusRequest {
    /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    force?: boolean
}

export interface CoreV1ApiReadComponentStatusRequest {
    /**
     * name of the ComponentStatus
     * @type string
     * @memberof CoreV1ApireadComponentStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadComponentStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespaceRequest {
    /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApireadNamespace
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespace
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespaceStatusRequest {
    /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApireadNamespaceStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespaceStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedConfigMapRequest {
    /**
     * name of the ConfigMap
     * @type string
     * @memberof CoreV1ApireadNamespacedConfigMap
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedConfigMap
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedConfigMap
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedEndpointsRequest {
    /**
     * name of the Endpoints
     * @type string
     * @memberof CoreV1ApireadNamespacedEndpoints
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedEndpoints
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedEndpoints
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof CoreV1ApireadNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedEvent
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedLimitRangeRequest {
    /**
     * name of the LimitRange
     * @type string
     * @memberof CoreV1ApireadNamespacedLimitRange
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedLimitRange
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedLimitRange
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPersistentVolumeClaimRequest {
    /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaim
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPersistentVolumeClaimStatusRequest {
    /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaimStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaimStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPodRequest {
    /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireadNamespacedPod
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedPod
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedPod
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPodEphemeralcontainersRequest {
    /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireadNamespacedPodEphemeralcontainers
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedPodEphemeralcontainers
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedPodEphemeralcontainers
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPodLogRequest {
    /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    namespace: string
    /**
     * The container for which to stream logs. Defaults to only container if there is one container in the pod.
     * @type string
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    container?: string
    /**
     * Follow the log stream of the pod. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    follow?: boolean
    /**
     * insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet.  If the kubelet is configured to verify the apiserver\&#39;s TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet).
     * @type boolean
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    insecureSkipTLSVerifyBackend?: boolean
    /**
     * If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
     * @type number
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    limitBytes?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    pretty?: string
    /**
     * Return previous terminated container logs. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    previous?: boolean
    /**
     * A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
     * @type number
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    sinceSeconds?: number
    /**
     * If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
     * @type number
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    tailLines?: number
    /**
     * If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    timestamps?: boolean
}

export interface CoreV1ApiReadNamespacedPodStatusRequest {
    /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireadNamespacedPodStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedPodStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedPodStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPodTemplateRequest {
    /**
     * name of the PodTemplate
     * @type string
     * @memberof CoreV1ApireadNamespacedPodTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedPodTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedPodTemplate
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedReplicationControllerRequest {
    /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationController
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationController
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationController
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedReplicationControllerScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerScale
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerScale
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedReplicationControllerStatusRequest {
    /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedResourceQuotaRequest {
    /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuota
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuota
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuota
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedResourceQuotaStatusRequest {
    /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuotaStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuotaStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuotaStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedSecretRequest {
    /**
     * name of the Secret
     * @type string
     * @memberof CoreV1ApireadNamespacedSecret
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedSecret
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedSecret
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedServiceRequest {
    /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApireadNamespacedService
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedService
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedService
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedServiceAccountRequest {
    /**
     * name of the ServiceAccount
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceAccount
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceAccount
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceAccount
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedServiceStatusRequest {
    /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNodeRequest {
    /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApireadNode
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNode
     */
    pretty?: string
}

export interface CoreV1ApiReadNodeStatusRequest {
    /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApireadNodeStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadNodeStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadPersistentVolumeRequest {
    /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApireadPersistentVolume
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadPersistentVolume
     */
    pretty?: string
}

export interface CoreV1ApiReadPersistentVolumeStatusRequest {
    /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApireadPersistentVolumeStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadPersistentVolumeStatus
     */
    pretty?: string
}

export interface CoreV1ApiReplaceNamespaceRequest {
    /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApireplaceNamespace
     */
    name: string
    /**
     * 
     * @type V1Namespace
     * @memberof CoreV1ApireplaceNamespace
     */
    body: V1Namespace
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespace
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespace
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespace
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespaceFinalizeRequest {
    /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApireplaceNamespaceFinalize
     */
    name: string
    /**
     * 
     * @type V1Namespace
     * @memberof CoreV1ApireplaceNamespaceFinalize
     */
    body: V1Namespace
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespaceFinalize
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespaceFinalize
     */
    fieldManager?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespaceFinalize
     */
    pretty?: string
}

export interface CoreV1ApiReplaceNamespaceStatusRequest {
    /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApireplaceNamespaceStatus
     */
    name: string
    /**
     * 
     * @type V1Namespace
     * @memberof CoreV1ApireplaceNamespaceStatus
     */
    body: V1Namespace
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespaceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespaceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespaceStatus
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedConfigMapRequest {
    /**
     * name of the ConfigMap
     * @type string
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    namespace: string
    /**
     * 
     * @type V1ConfigMap
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    body: V1ConfigMap
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedEndpointsRequest {
    /**
     * name of the Endpoints
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    namespace: string
    /**
     * 
     * @type V1Endpoints
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    body: V1Endpoints
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type CoreV1Event
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    body: CoreV1Event
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedLimitRangeRequest {
    /**
     * name of the LimitRange
     * @type string
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    namespace: string
    /**
     * 
     * @type V1LimitRange
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    body: V1LimitRange
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedPersistentVolumeClaimRequest {
    /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * 
     * @type V1PersistentVolumeClaim
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    body: V1PersistentVolumeClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedPersistentVolumeClaimStatusRequest {
    /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    namespace: string
    /**
     * 
     * @type V1PersistentVolumeClaim
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    body: V1PersistentVolumeClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedPodRequest {
    /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    namespace: string
    /**
     * 
     * @type V1Pod
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    body: V1Pod
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedPodEphemeralcontainersRequest {
    /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    namespace: string
    /**
     * 
     * @type V1Pod
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    body: V1Pod
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedPodStatusRequest {
    /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    namespace: string
    /**
     * 
     * @type V1Pod
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    body: V1Pod
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedPodTemplateRequest {
    /**
     * name of the PodTemplate
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    namespace: string
    /**
     * 
     * @type V1PodTemplate
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    body: V1PodTemplate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedReplicationControllerRequest {
    /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    namespace: string
    /**
     * 
     * @type V1ReplicationController
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    body: V1ReplicationController
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedReplicationControllerScaleRequest {
    /**
     * name of the Scale
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    namespace: string
    /**
     * 
     * @type V1Scale
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    body: V1Scale
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedReplicationControllerStatusRequest {
    /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    namespace: string
    /**
     * 
     * @type V1ReplicationController
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    body: V1ReplicationController
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedResourceQuotaRequest {
    /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    namespace: string
    /**
     * 
     * @type V1ResourceQuota
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    body: V1ResourceQuota
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedResourceQuotaStatusRequest {
    /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    namespace: string
    /**
     * 
     * @type V1ResourceQuota
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    body: V1ResourceQuota
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedSecretRequest {
    /**
     * name of the Secret
     * @type string
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    namespace: string
    /**
     * 
     * @type V1Secret
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    body: V1Secret
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedServiceRequest {
    /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApireplaceNamespacedService
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedService
     */
    namespace: string
    /**
     * 
     * @type V1Service
     * @memberof CoreV1ApireplaceNamespacedService
     */
    body: V1Service
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedService
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedServiceAccountRequest {
    /**
     * name of the ServiceAccount
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    namespace: string
    /**
     * 
     * @type V1ServiceAccount
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    body: V1ServiceAccount
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNamespacedServiceStatusRequest {
    /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    namespace: string
    /**
     * 
     * @type V1Service
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    body: V1Service
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNodeRequest {
    /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApireplaceNode
     */
    name: string
    /**
     * 
     * @type V1Node
     * @memberof CoreV1ApireplaceNode
     */
    body: V1Node
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNode
     */
    fieldManager?: string
}

export interface CoreV1ApiReplaceNodeStatusRequest {
    /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApireplaceNodeStatus
     */
    name: string
    /**
     * 
     * @type V1Node
     * @memberof CoreV1ApireplaceNodeStatus
     */
    body: V1Node
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceNodeStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceNodeStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceNodeStatus
     */
    fieldManager?: string
}

export interface CoreV1ApiReplacePersistentVolumeRequest {
    /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApireplacePersistentVolume
     */
    name: string
    /**
     * 
     * @type V1PersistentVolume
     * @memberof CoreV1ApireplacePersistentVolume
     */
    body: V1PersistentVolume
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplacePersistentVolume
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplacePersistentVolume
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplacePersistentVolume
     */
    fieldManager?: string
}

export interface CoreV1ApiReplacePersistentVolumeStatusRequest {
    /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApireplacePersistentVolumeStatus
     */
    name: string
    /**
     * 
     * @type V1PersistentVolume
     * @memberof CoreV1ApireplacePersistentVolumeStatus
     */
    body: V1PersistentVolume
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplacePersistentVolumeStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplacePersistentVolumeStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplacePersistentVolumeStatus
     */
    fieldManager?: string
}

export class ObjectCoreV1Api {
    private api: ObservableCoreV1Api

    public constructor(configuration: Configuration, requestFactory?: CoreV1ApiRequestFactory, responseProcessor?: CoreV1ApiResponseProcessor) {
        this.api = new ObservableCoreV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * connect DELETE requests to proxy of Pod
     * @param param the request object
     */
    public connectDeleteNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectDeleteNamespacedPodProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Pod
     * @param param the request object
     */
    public connectDeleteNamespacedPodProxy(param: CoreV1ApiConnectDeleteNamespacedPodProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectDeleteNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Pod
     * @param param the request object
     */
    public connectDeleteNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectDeleteNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Pod
     * @param param the request object
     */
    public connectDeleteNamespacedPodProxyWithPath(param: CoreV1ApiConnectDeleteNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectDeleteNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Service
     * @param param the request object
     */
    public connectDeleteNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectDeleteNamespacedServiceProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Service
     * @param param the request object
     */
    public connectDeleteNamespacedServiceProxy(param: CoreV1ApiConnectDeleteNamespacedServiceProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectDeleteNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Service
     * @param param the request object
     */
    public connectDeleteNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectDeleteNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Service
     * @param param the request object
     */
    public connectDeleteNamespacedServiceProxyWithPath(param: CoreV1ApiConnectDeleteNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectDeleteNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Node
     * @param param the request object
     */
    public connectDeleteNodeProxyWithHttpInfo(param: CoreV1ApiConnectDeleteNodeProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Node
     * @param param the request object
     */
    public connectDeleteNodeProxy(param: CoreV1ApiConnectDeleteNodeProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectDeleteNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Node
     * @param param the request object
     */
    public connectDeleteNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectDeleteNodeProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Node
     * @param param the request object
     */
    public connectDeleteNodeProxyWithPath(param: CoreV1ApiConnectDeleteNodeProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectDeleteNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to attach of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodAttachWithHttpInfo(param: CoreV1ApiConnectGetNamespacedPodAttachRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedPodAttachWithHttpInfo(param.name, param.namespace, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect GET requests to attach of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodAttach(param: CoreV1ApiConnectGetNamespacedPodAttachRequest, options?: Configuration): Promise<string> {
        return this.api.connectGetNamespacedPodAttach(param.name, param.namespace, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect GET requests to exec of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodExecWithHttpInfo(param: CoreV1ApiConnectGetNamespacedPodExecRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedPodExecWithHttpInfo(param.name, param.namespace, param.command, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect GET requests to exec of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodExec(param: CoreV1ApiConnectGetNamespacedPodExecRequest, options?: Configuration): Promise<string> {
        return this.api.connectGetNamespacedPodExec(param.name, param.namespace, param.command, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect GET requests to portforward of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodPortforwardWithHttpInfo(param: CoreV1ApiConnectGetNamespacedPodPortforwardRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedPodPortforwardWithHttpInfo(param.name, param.namespace, param.ports,  options).toPromise();
    }

    /**
     * connect GET requests to portforward of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodPortforward(param: CoreV1ApiConnectGetNamespacedPodPortforwardRequest, options?: Configuration): Promise<string> {
        return this.api.connectGetNamespacedPodPortforward(param.name, param.namespace, param.ports,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectGetNamespacedPodProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodProxy(param: CoreV1ApiConnectGetNamespacedPodProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectGetNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectGetNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodProxyWithPath(param: CoreV1ApiConnectGetNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectGetNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Service
     * @param param the request object
     */
    public connectGetNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectGetNamespacedServiceProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Service
     * @param param the request object
     */
    public connectGetNamespacedServiceProxy(param: CoreV1ApiConnectGetNamespacedServiceProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectGetNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Service
     * @param param the request object
     */
    public connectGetNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectGetNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Service
     * @param param the request object
     */
    public connectGetNamespacedServiceProxyWithPath(param: CoreV1ApiConnectGetNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectGetNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Node
     * @param param the request object
     */
    public connectGetNodeProxyWithHttpInfo(param: CoreV1ApiConnectGetNodeProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectGetNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Node
     * @param param the request object
     */
    public connectGetNodeProxy(param: CoreV1ApiConnectGetNodeProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectGetNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Node
     * @param param the request object
     */
    public connectGetNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectGetNodeProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectGetNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Node
     * @param param the request object
     */
    public connectGetNodeProxyWithPath(param: CoreV1ApiConnectGetNodeProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectGetNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Pod
     * @param param the request object
     */
    public connectHeadNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectHeadNamespacedPodProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectHeadNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Pod
     * @param param the request object
     */
    public connectHeadNamespacedPodProxy(param: CoreV1ApiConnectHeadNamespacedPodProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectHeadNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Pod
     * @param param the request object
     */
    public connectHeadNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectHeadNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectHeadNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Pod
     * @param param the request object
     */
    public connectHeadNamespacedPodProxyWithPath(param: CoreV1ApiConnectHeadNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectHeadNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Service
     * @param param the request object
     */
    public connectHeadNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectHeadNamespacedServiceProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectHeadNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Service
     * @param param the request object
     */
    public connectHeadNamespacedServiceProxy(param: CoreV1ApiConnectHeadNamespacedServiceProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectHeadNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Service
     * @param param the request object
     */
    public connectHeadNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectHeadNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectHeadNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Service
     * @param param the request object
     */
    public connectHeadNamespacedServiceProxyWithPath(param: CoreV1ApiConnectHeadNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectHeadNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Node
     * @param param the request object
     */
    public connectHeadNodeProxyWithHttpInfo(param: CoreV1ApiConnectHeadNodeProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectHeadNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Node
     * @param param the request object
     */
    public connectHeadNodeProxy(param: CoreV1ApiConnectHeadNodeProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectHeadNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Node
     * @param param the request object
     */
    public connectHeadNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectHeadNodeProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectHeadNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Node
     * @param param the request object
     */
    public connectHeadNodeProxyWithPath(param: CoreV1ApiConnectHeadNodeProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectHeadNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param param the request object
     */
    public connectOptionsNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectOptionsNamespacedPodProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param param the request object
     */
    public connectOptionsNamespacedPodProxy(param: CoreV1ApiConnectOptionsNamespacedPodProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectOptionsNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param param the request object
     */
    public connectOptionsNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectOptionsNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param param the request object
     */
    public connectOptionsNamespacedPodProxyWithPath(param: CoreV1ApiConnectOptionsNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectOptionsNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     * @param param the request object
     */
    public connectOptionsNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectOptionsNamespacedServiceProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     * @param param the request object
     */
    public connectOptionsNamespacedServiceProxy(param: CoreV1ApiConnectOptionsNamespacedServiceProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectOptionsNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     * @param param the request object
     */
    public connectOptionsNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectOptionsNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     * @param param the request object
     */
    public connectOptionsNamespacedServiceProxyWithPath(param: CoreV1ApiConnectOptionsNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectOptionsNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     * @param param the request object
     */
    public connectOptionsNodeProxyWithHttpInfo(param: CoreV1ApiConnectOptionsNodeProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     * @param param the request object
     */
    public connectOptionsNodeProxy(param: CoreV1ApiConnectOptionsNodeProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectOptionsNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     * @param param the request object
     */
    public connectOptionsNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectOptionsNodeProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     * @param param the request object
     */
    public connectOptionsNodeProxyWithPath(param: CoreV1ApiConnectOptionsNodeProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectOptionsNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Pod
     * @param param the request object
     */
    public connectPatchNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectPatchNamespacedPodProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPatchNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Pod
     * @param param the request object
     */
    public connectPatchNamespacedPodProxy(param: CoreV1ApiConnectPatchNamespacedPodProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectPatchNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Pod
     * @param param the request object
     */
    public connectPatchNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPatchNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPatchNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Pod
     * @param param the request object
     */
    public connectPatchNamespacedPodProxyWithPath(param: CoreV1ApiConnectPatchNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectPatchNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Service
     * @param param the request object
     */
    public connectPatchNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectPatchNamespacedServiceProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPatchNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Service
     * @param param the request object
     */
    public connectPatchNamespacedServiceProxy(param: CoreV1ApiConnectPatchNamespacedServiceProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectPatchNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Service
     * @param param the request object
     */
    public connectPatchNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPatchNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPatchNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Service
     * @param param the request object
     */
    public connectPatchNamespacedServiceProxyWithPath(param: CoreV1ApiConnectPatchNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectPatchNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Node
     * @param param the request object
     */
    public connectPatchNodeProxyWithHttpInfo(param: CoreV1ApiConnectPatchNodeProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPatchNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Node
     * @param param the request object
     */
    public connectPatchNodeProxy(param: CoreV1ApiConnectPatchNodeProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectPatchNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Node
     * @param param the request object
     */
    public connectPatchNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPatchNodeProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPatchNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Node
     * @param param the request object
     */
    public connectPatchNodeProxyWithPath(param: CoreV1ApiConnectPatchNodeProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectPatchNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to attach of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodAttachWithHttpInfo(param: CoreV1ApiConnectPostNamespacedPodAttachRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedPodAttachWithHttpInfo(param.name, param.namespace, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect POST requests to attach of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodAttach(param: CoreV1ApiConnectPostNamespacedPodAttachRequest, options?: Configuration): Promise<string> {
        return this.api.connectPostNamespacedPodAttach(param.name, param.namespace, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect POST requests to exec of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodExecWithHttpInfo(param: CoreV1ApiConnectPostNamespacedPodExecRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedPodExecWithHttpInfo(param.name, param.namespace, param.command, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect POST requests to exec of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodExec(param: CoreV1ApiConnectPostNamespacedPodExecRequest, options?: Configuration): Promise<string> {
        return this.api.connectPostNamespacedPodExec(param.name, param.namespace, param.command, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect POST requests to portforward of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodPortforwardWithHttpInfo(param: CoreV1ApiConnectPostNamespacedPodPortforwardRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedPodPortforwardWithHttpInfo(param.name, param.namespace, param.ports,  options).toPromise();
    }

    /**
     * connect POST requests to portforward of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodPortforward(param: CoreV1ApiConnectPostNamespacedPodPortforwardRequest, options?: Configuration): Promise<string> {
        return this.api.connectPostNamespacedPodPortforward(param.name, param.namespace, param.ports,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectPostNamespacedPodProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodProxy(param: CoreV1ApiConnectPostNamespacedPodProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectPostNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPostNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodProxyWithPath(param: CoreV1ApiConnectPostNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectPostNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Service
     * @param param the request object
     */
    public connectPostNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectPostNamespacedServiceProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Service
     * @param param the request object
     */
    public connectPostNamespacedServiceProxy(param: CoreV1ApiConnectPostNamespacedServiceProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectPostNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Service
     * @param param the request object
     */
    public connectPostNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPostNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Service
     * @param param the request object
     */
    public connectPostNamespacedServiceProxyWithPath(param: CoreV1ApiConnectPostNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectPostNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Node
     * @param param the request object
     */
    public connectPostNodeProxyWithHttpInfo(param: CoreV1ApiConnectPostNodeProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPostNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Node
     * @param param the request object
     */
    public connectPostNodeProxy(param: CoreV1ApiConnectPostNodeProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectPostNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Node
     * @param param the request object
     */
    public connectPostNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPostNodeProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPostNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Node
     * @param param the request object
     */
    public connectPostNodeProxyWithPath(param: CoreV1ApiConnectPostNodeProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectPostNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Pod
     * @param param the request object
     */
    public connectPutNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectPutNamespacedPodProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPutNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Pod
     * @param param the request object
     */
    public connectPutNamespacedPodProxy(param: CoreV1ApiConnectPutNamespacedPodProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectPutNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Pod
     * @param param the request object
     */
    public connectPutNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPutNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPutNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Pod
     * @param param the request object
     */
    public connectPutNamespacedPodProxyWithPath(param: CoreV1ApiConnectPutNamespacedPodProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectPutNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Service
     * @param param the request object
     */
    public connectPutNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectPutNamespacedServiceProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPutNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Service
     * @param param the request object
     */
    public connectPutNamespacedServiceProxy(param: CoreV1ApiConnectPutNamespacedServiceProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectPutNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Service
     * @param param the request object
     */
    public connectPutNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPutNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPutNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Service
     * @param param the request object
     */
    public connectPutNamespacedServiceProxyWithPath(param: CoreV1ApiConnectPutNamespacedServiceProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectPutNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Node
     * @param param the request object
     */
    public connectPutNodeProxyWithHttpInfo(param: CoreV1ApiConnectPutNodeProxyRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPutNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Node
     * @param param the request object
     */
    public connectPutNodeProxy(param: CoreV1ApiConnectPutNodeProxyRequest, options?: Configuration): Promise<string> {
        return this.api.connectPutNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Node
     * @param param the request object
     */
    public connectPutNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPutNodeProxyWithPathRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.connectPutNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Node
     * @param param the request object
     */
    public connectPutNodeProxyWithPath(param: CoreV1ApiConnectPutNodeProxyWithPathRequest, options?: Configuration): Promise<string> {
        return this.api.connectPutNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * create a Namespace
     * @param param the request object
     */
    public createNamespaceWithHttpInfo(param: CoreV1ApiCreateNamespaceRequest, options?: Configuration): Promise<HttpInfo<V1Namespace>> {
        return this.api.createNamespaceWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Namespace
     * @param param the request object
     */
    public createNamespace(param: CoreV1ApiCreateNamespaceRequest, options?: Configuration): Promise<V1Namespace> {
        return this.api.createNamespace(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Binding
     * @param param the request object
     */
    public createNamespacedBindingWithHttpInfo(param: CoreV1ApiCreateNamespacedBindingRequest, options?: Configuration): Promise<HttpInfo<V1Binding>> {
        return this.api.createNamespacedBindingWithHttpInfo(param.namespace, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a Binding
     * @param param the request object
     */
    public createNamespacedBinding(param: CoreV1ApiCreateNamespacedBindingRequest, options?: Configuration): Promise<V1Binding> {
        return this.api.createNamespacedBinding(param.namespace, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a ConfigMap
     * @param param the request object
     */
    public createNamespacedConfigMapWithHttpInfo(param: CoreV1ApiCreateNamespacedConfigMapRequest, options?: Configuration): Promise<HttpInfo<V1ConfigMap>> {
        return this.api.createNamespacedConfigMapWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ConfigMap
     * @param param the request object
     */
    public createNamespacedConfigMap(param: CoreV1ApiCreateNamespacedConfigMapRequest, options?: Configuration): Promise<V1ConfigMap> {
        return this.api.createNamespacedConfigMap(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create Endpoints
     * @param param the request object
     */
    public createNamespacedEndpointsWithHttpInfo(param: CoreV1ApiCreateNamespacedEndpointsRequest, options?: Configuration): Promise<HttpInfo<V1Endpoints>> {
        return this.api.createNamespacedEndpointsWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create Endpoints
     * @param param the request object
     */
    public createNamespacedEndpoints(param: CoreV1ApiCreateNamespacedEndpointsRequest, options?: Configuration): Promise<V1Endpoints> {
        return this.api.createNamespacedEndpoints(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create an Event
     * @param param the request object
     */
    public createNamespacedEventWithHttpInfo(param: CoreV1ApiCreateNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<CoreV1Event>> {
        return this.api.createNamespacedEventWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create an Event
     * @param param the request object
     */
    public createNamespacedEvent(param: CoreV1ApiCreateNamespacedEventRequest, options?: Configuration): Promise<CoreV1Event> {
        return this.api.createNamespacedEvent(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a LimitRange
     * @param param the request object
     */
    public createNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiCreateNamespacedLimitRangeRequest, options?: Configuration): Promise<HttpInfo<V1LimitRange>> {
        return this.api.createNamespacedLimitRangeWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a LimitRange
     * @param param the request object
     */
    public createNamespacedLimitRange(param: CoreV1ApiCreateNamespacedLimitRangeRequest, options?: Configuration): Promise<V1LimitRange> {
        return this.api.createNamespacedLimitRange(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PersistentVolumeClaim
     * @param param the request object
     */
    public createNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiCreateNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.createNamespacedPersistentVolumeClaimWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PersistentVolumeClaim
     * @param param the request object
     */
    public createNamespacedPersistentVolumeClaim(param: CoreV1ApiCreateNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<V1PersistentVolumeClaim> {
        return this.api.createNamespacedPersistentVolumeClaim(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Pod
     * @param param the request object
     */
    public createNamespacedPodWithHttpInfo(param: CoreV1ApiCreateNamespacedPodRequest, options?: Configuration): Promise<HttpInfo<V1Pod>> {
        return this.api.createNamespacedPodWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Pod
     * @param param the request object
     */
    public createNamespacedPod(param: CoreV1ApiCreateNamespacedPodRequest, options?: Configuration): Promise<V1Pod> {
        return this.api.createNamespacedPod(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create binding of a Pod
     * @param param the request object
     */
    public createNamespacedPodBindingWithHttpInfo(param: CoreV1ApiCreateNamespacedPodBindingRequest, options?: Configuration): Promise<HttpInfo<V1Binding>> {
        return this.api.createNamespacedPodBindingWithHttpInfo(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create binding of a Pod
     * @param param the request object
     */
    public createNamespacedPodBinding(param: CoreV1ApiCreateNamespacedPodBindingRequest, options?: Configuration): Promise<V1Binding> {
        return this.api.createNamespacedPodBinding(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create eviction of a Pod
     * @param param the request object
     */
    public createNamespacedPodEvictionWithHttpInfo(param: CoreV1ApiCreateNamespacedPodEvictionRequest, options?: Configuration): Promise<HttpInfo<V1Eviction>> {
        return this.api.createNamespacedPodEvictionWithHttpInfo(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create eviction of a Pod
     * @param param the request object
     */
    public createNamespacedPodEviction(param: CoreV1ApiCreateNamespacedPodEvictionRequest, options?: Configuration): Promise<V1Eviction> {
        return this.api.createNamespacedPodEviction(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a PodTemplate
     * @param param the request object
     */
    public createNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiCreateNamespacedPodTemplateRequest, options?: Configuration): Promise<HttpInfo<V1PodTemplate>> {
        return this.api.createNamespacedPodTemplateWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PodTemplate
     * @param param the request object
     */
    public createNamespacedPodTemplate(param: CoreV1ApiCreateNamespacedPodTemplateRequest, options?: Configuration): Promise<V1PodTemplate> {
        return this.api.createNamespacedPodTemplate(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ReplicationController
     * @param param the request object
     */
    public createNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiCreateNamespacedReplicationControllerRequest, options?: Configuration): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.createNamespacedReplicationControllerWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ReplicationController
     * @param param the request object
     */
    public createNamespacedReplicationController(param: CoreV1ApiCreateNamespacedReplicationControllerRequest, options?: Configuration): Promise<V1ReplicationController> {
        return this.api.createNamespacedReplicationController(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ResourceQuota
     * @param param the request object
     */
    public createNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiCreateNamespacedResourceQuotaRequest, options?: Configuration): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.createNamespacedResourceQuotaWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ResourceQuota
     * @param param the request object
     */
    public createNamespacedResourceQuota(param: CoreV1ApiCreateNamespacedResourceQuotaRequest, options?: Configuration): Promise<V1ResourceQuota> {
        return this.api.createNamespacedResourceQuota(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Secret
     * @param param the request object
     */
    public createNamespacedSecretWithHttpInfo(param: CoreV1ApiCreateNamespacedSecretRequest, options?: Configuration): Promise<HttpInfo<V1Secret>> {
        return this.api.createNamespacedSecretWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Secret
     * @param param the request object
     */
    public createNamespacedSecret(param: CoreV1ApiCreateNamespacedSecretRequest, options?: Configuration): Promise<V1Secret> {
        return this.api.createNamespacedSecret(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Service
     * @param param the request object
     */
    public createNamespacedServiceWithHttpInfo(param: CoreV1ApiCreateNamespacedServiceRequest, options?: Configuration): Promise<HttpInfo<V1Service>> {
        return this.api.createNamespacedServiceWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Service
     * @param param the request object
     */
    public createNamespacedService(param: CoreV1ApiCreateNamespacedServiceRequest, options?: Configuration): Promise<V1Service> {
        return this.api.createNamespacedService(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ServiceAccount
     * @param param the request object
     */
    public createNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiCreateNamespacedServiceAccountRequest, options?: Configuration): Promise<HttpInfo<V1ServiceAccount>> {
        return this.api.createNamespacedServiceAccountWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ServiceAccount
     * @param param the request object
     */
    public createNamespacedServiceAccount(param: CoreV1ApiCreateNamespacedServiceAccountRequest, options?: Configuration): Promise<V1ServiceAccount> {
        return this.api.createNamespacedServiceAccount(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create token of a ServiceAccount
     * @param param the request object
     */
    public createNamespacedServiceAccountTokenWithHttpInfo(param: CoreV1ApiCreateNamespacedServiceAccountTokenRequest, options?: Configuration): Promise<HttpInfo<AuthenticationV1TokenRequest>> {
        return this.api.createNamespacedServiceAccountTokenWithHttpInfo(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create token of a ServiceAccount
     * @param param the request object
     */
    public createNamespacedServiceAccountToken(param: CoreV1ApiCreateNamespacedServiceAccountTokenRequest, options?: Configuration): Promise<AuthenticationV1TokenRequest> {
        return this.api.createNamespacedServiceAccountToken(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * create a Node
     * @param param the request object
     */
    public createNodeWithHttpInfo(param: CoreV1ApiCreateNodeRequest, options?: Configuration): Promise<HttpInfo<V1Node>> {
        return this.api.createNodeWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Node
     * @param param the request object
     */
    public createNode(param: CoreV1ApiCreateNodeRequest, options?: Configuration): Promise<V1Node> {
        return this.api.createNode(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PersistentVolume
     * @param param the request object
     */
    public createPersistentVolumeWithHttpInfo(param: CoreV1ApiCreatePersistentVolumeRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.createPersistentVolumeWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PersistentVolume
     * @param param the request object
     */
    public createPersistentVolume(param: CoreV1ApiCreatePersistentVolumeRequest, options?: Configuration): Promise<V1PersistentVolume> {
        return this.api.createPersistentVolume(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of ConfigMap
     * @param param the request object
     */
    public deleteCollectionNamespacedConfigMapWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedConfigMapRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedConfigMapWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ConfigMap
     * @param param the request object
     */
    public deleteCollectionNamespacedConfigMap(param: CoreV1ApiDeleteCollectionNamespacedConfigMapRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedConfigMap(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Endpoints
     * @param param the request object
     */
    public deleteCollectionNamespacedEndpointsWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedEndpointsRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedEndpointsWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Endpoints
     * @param param the request object
     */
    public deleteCollectionNamespacedEndpoints(param: CoreV1ApiDeleteCollectionNamespacedEndpointsRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedEndpoints(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Event
     * @param param the request object
     */
    public deleteCollectionNamespacedEventWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedEventWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Event
     * @param param the request object
     */
    public deleteCollectionNamespacedEvent(param: CoreV1ApiDeleteCollectionNamespacedEventRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedEvent(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of LimitRange
     * @param param the request object
     */
    public deleteCollectionNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedLimitRangeRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedLimitRangeWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of LimitRange
     * @param param the request object
     */
    public deleteCollectionNamespacedLimitRange(param: CoreV1ApiDeleteCollectionNamespacedLimitRangeRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedLimitRange(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PersistentVolumeClaim
     * @param param the request object
     */
    public deleteCollectionNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedPersistentVolumeClaimWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PersistentVolumeClaim
     * @param param the request object
     */
    public deleteCollectionNamespacedPersistentVolumeClaim(param: CoreV1ApiDeleteCollectionNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedPersistentVolumeClaim(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Pod
     * @param param the request object
     */
    public deleteCollectionNamespacedPodWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedPodRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedPodWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Pod
     * @param param the request object
     */
    public deleteCollectionNamespacedPod(param: CoreV1ApiDeleteCollectionNamespacedPodRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedPod(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PodTemplate
     * @param param the request object
     */
    public deleteCollectionNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedPodTemplateRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedPodTemplateWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PodTemplate
     * @param param the request object
     */
    public deleteCollectionNamespacedPodTemplate(param: CoreV1ApiDeleteCollectionNamespacedPodTemplateRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedPodTemplate(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ReplicationController
     * @param param the request object
     */
    public deleteCollectionNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedReplicationControllerRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedReplicationControllerWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ReplicationController
     * @param param the request object
     */
    public deleteCollectionNamespacedReplicationController(param: CoreV1ApiDeleteCollectionNamespacedReplicationControllerRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedReplicationController(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceQuota
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedResourceQuotaRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedResourceQuotaWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceQuota
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceQuota(param: CoreV1ApiDeleteCollectionNamespacedResourceQuotaRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedResourceQuota(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Secret
     * @param param the request object
     */
    public deleteCollectionNamespacedSecretWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedSecretRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedSecretWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Secret
     * @param param the request object
     */
    public deleteCollectionNamespacedSecret(param: CoreV1ApiDeleteCollectionNamespacedSecretRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedSecret(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ServiceAccount
     * @param param the request object
     */
    public deleteCollectionNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedServiceAccountRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedServiceAccountWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ServiceAccount
     * @param param the request object
     */
    public deleteCollectionNamespacedServiceAccount(param: CoreV1ApiDeleteCollectionNamespacedServiceAccountRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedServiceAccount(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Node
     * @param param the request object
     */
    public deleteCollectionNodeWithHttpInfo(param: CoreV1ApiDeleteCollectionNodeRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNodeWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Node
     * @param param the request object
     */
    public deleteCollectionNode(param: CoreV1ApiDeleteCollectionNodeRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNode(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PersistentVolume
     * @param param the request object
     */
    public deleteCollectionPersistentVolumeWithHttpInfo(param: CoreV1ApiDeleteCollectionPersistentVolumeRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionPersistentVolumeWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PersistentVolume
     * @param param the request object
     */
    public deleteCollectionPersistentVolume(param: CoreV1ApiDeleteCollectionPersistentVolumeRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionPersistentVolume(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a Namespace
     * @param param the request object
     */
    public deleteNamespaceWithHttpInfo(param: CoreV1ApiDeleteNamespaceRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespaceWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Namespace
     * @param param the request object
     */
    public deleteNamespace(param: CoreV1ApiDeleteNamespaceRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespace(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ConfigMap
     * @param param the request object
     */
    public deleteNamespacedConfigMapWithHttpInfo(param: CoreV1ApiDeleteNamespacedConfigMapRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedConfigMapWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ConfigMap
     * @param param the request object
     */
    public deleteNamespacedConfigMap(param: CoreV1ApiDeleteNamespacedConfigMapRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedConfigMap(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete Endpoints
     * @param param the request object
     */
    public deleteNamespacedEndpointsWithHttpInfo(param: CoreV1ApiDeleteNamespacedEndpointsRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedEndpointsWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete Endpoints
     * @param param the request object
     */
    public deleteNamespacedEndpoints(param: CoreV1ApiDeleteNamespacedEndpointsRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedEndpoints(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an Event
     * @param param the request object
     */
    public deleteNamespacedEventWithHttpInfo(param: CoreV1ApiDeleteNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedEventWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an Event
     * @param param the request object
     */
    public deleteNamespacedEvent(param: CoreV1ApiDeleteNamespacedEventRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedEvent(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a LimitRange
     * @param param the request object
     */
    public deleteNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiDeleteNamespacedLimitRangeRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedLimitRangeWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a LimitRange
     * @param param the request object
     */
    public deleteNamespacedLimitRange(param: CoreV1ApiDeleteNamespacedLimitRangeRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedLimitRange(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PersistentVolumeClaim
     * @param param the request object
     */
    public deleteNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiDeleteNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.deleteNamespacedPersistentVolumeClaimWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PersistentVolumeClaim
     * @param param the request object
     */
    public deleteNamespacedPersistentVolumeClaim(param: CoreV1ApiDeleteNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<V1PersistentVolumeClaim> {
        return this.api.deleteNamespacedPersistentVolumeClaim(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Pod
     * @param param the request object
     */
    public deleteNamespacedPodWithHttpInfo(param: CoreV1ApiDeleteNamespacedPodRequest, options?: Configuration): Promise<HttpInfo<V1Pod>> {
        return this.api.deleteNamespacedPodWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Pod
     * @param param the request object
     */
    public deleteNamespacedPod(param: CoreV1ApiDeleteNamespacedPodRequest, options?: Configuration): Promise<V1Pod> {
        return this.api.deleteNamespacedPod(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PodTemplate
     * @param param the request object
     */
    public deleteNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiDeleteNamespacedPodTemplateRequest, options?: Configuration): Promise<HttpInfo<V1PodTemplate>> {
        return this.api.deleteNamespacedPodTemplateWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PodTemplate
     * @param param the request object
     */
    public deleteNamespacedPodTemplate(param: CoreV1ApiDeleteNamespacedPodTemplateRequest, options?: Configuration): Promise<V1PodTemplate> {
        return this.api.deleteNamespacedPodTemplate(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ReplicationController
     * @param param the request object
     */
    public deleteNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiDeleteNamespacedReplicationControllerRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedReplicationControllerWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ReplicationController
     * @param param the request object
     */
    public deleteNamespacedReplicationController(param: CoreV1ApiDeleteNamespacedReplicationControllerRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedReplicationController(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceQuota
     * @param param the request object
     */
    public deleteNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiDeleteNamespacedResourceQuotaRequest, options?: Configuration): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.deleteNamespacedResourceQuotaWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceQuota
     * @param param the request object
     */
    public deleteNamespacedResourceQuota(param: CoreV1ApiDeleteNamespacedResourceQuotaRequest, options?: Configuration): Promise<V1ResourceQuota> {
        return this.api.deleteNamespacedResourceQuota(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Secret
     * @param param the request object
     */
    public deleteNamespacedSecretWithHttpInfo(param: CoreV1ApiDeleteNamespacedSecretRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedSecretWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Secret
     * @param param the request object
     */
    public deleteNamespacedSecret(param: CoreV1ApiDeleteNamespacedSecretRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedSecret(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Service
     * @param param the request object
     */
    public deleteNamespacedServiceWithHttpInfo(param: CoreV1ApiDeleteNamespacedServiceRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedServiceWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Service
     * @param param the request object
     */
    public deleteNamespacedService(param: CoreV1ApiDeleteNamespacedServiceRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedService(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ServiceAccount
     * @param param the request object
     */
    public deleteNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiDeleteNamespacedServiceAccountRequest, options?: Configuration): Promise<HttpInfo<V1ServiceAccount>> {
        return this.api.deleteNamespacedServiceAccountWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ServiceAccount
     * @param param the request object
     */
    public deleteNamespacedServiceAccount(param: CoreV1ApiDeleteNamespacedServiceAccountRequest, options?: Configuration): Promise<V1ServiceAccount> {
        return this.api.deleteNamespacedServiceAccount(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Node
     * @param param the request object
     */
    public deleteNodeWithHttpInfo(param: CoreV1ApiDeleteNodeRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNodeWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Node
     * @param param the request object
     */
    public deleteNode(param: CoreV1ApiDeleteNodeRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNode(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PersistentVolume
     * @param param the request object
     */
    public deletePersistentVolumeWithHttpInfo(param: CoreV1ApiDeletePersistentVolumeRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.deletePersistentVolumeWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PersistentVolume
     * @param param the request object
     */
    public deletePersistentVolume(param: CoreV1ApiDeletePersistentVolumeRequest, options?: Configuration): Promise<V1PersistentVolume> {
        return this.api.deletePersistentVolume(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CoreV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CoreV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list objects of kind ComponentStatus
     * @param param the request object
     */
    public listComponentStatusWithHttpInfo(param: CoreV1ApiListComponentStatusRequest = {}, options?: Configuration): Promise<HttpInfo<V1ComponentStatusList>> {
        return this.api.listComponentStatusWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list objects of kind ComponentStatus
     * @param param the request object
     */
    public listComponentStatus(param: CoreV1ApiListComponentStatusRequest = {}, options?: Configuration): Promise<V1ComponentStatusList> {
        return this.api.listComponentStatus(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ConfigMap
     * @param param the request object
     */
    public listConfigMapForAllNamespacesWithHttpInfo(param: CoreV1ApiListConfigMapForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1ConfigMapList>> {
        return this.api.listConfigMapForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ConfigMap
     * @param param the request object
     */
    public listConfigMapForAllNamespaces(param: CoreV1ApiListConfigMapForAllNamespacesRequest = {}, options?: Configuration): Promise<V1ConfigMapList> {
        return this.api.listConfigMapForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Endpoints
     * @param param the request object
     */
    public listEndpointsForAllNamespacesWithHttpInfo(param: CoreV1ApiListEndpointsForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1EndpointsList>> {
        return this.api.listEndpointsForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Endpoints
     * @param param the request object
     */
    public listEndpointsForAllNamespaces(param: CoreV1ApiListEndpointsForAllNamespacesRequest = {}, options?: Configuration): Promise<V1EndpointsList> {
        return this.api.listEndpointsForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listEventForAllNamespacesWithHttpInfo(param: CoreV1ApiListEventForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<CoreV1EventList>> {
        return this.api.listEventForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listEventForAllNamespaces(param: CoreV1ApiListEventForAllNamespacesRequest = {}, options?: Configuration): Promise<CoreV1EventList> {
        return this.api.listEventForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LimitRange
     * @param param the request object
     */
    public listLimitRangeForAllNamespacesWithHttpInfo(param: CoreV1ApiListLimitRangeForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1LimitRangeList>> {
        return this.api.listLimitRangeForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LimitRange
     * @param param the request object
     */
    public listLimitRangeForAllNamespaces(param: CoreV1ApiListLimitRangeForAllNamespacesRequest = {}, options?: Configuration): Promise<V1LimitRangeList> {
        return this.api.listLimitRangeForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Namespace
     * @param param the request object
     */
    public listNamespaceWithHttpInfo(param: CoreV1ApiListNamespaceRequest = {}, options?: Configuration): Promise<HttpInfo<V1NamespaceList>> {
        return this.api.listNamespaceWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Namespace
     * @param param the request object
     */
    public listNamespace(param: CoreV1ApiListNamespaceRequest = {}, options?: Configuration): Promise<V1NamespaceList> {
        return this.api.listNamespace(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ConfigMap
     * @param param the request object
     */
    public listNamespacedConfigMapWithHttpInfo(param: CoreV1ApiListNamespacedConfigMapRequest, options?: Configuration): Promise<HttpInfo<V1ConfigMapList>> {
        return this.api.listNamespacedConfigMapWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ConfigMap
     * @param param the request object
     */
    public listNamespacedConfigMap(param: CoreV1ApiListNamespacedConfigMapRequest, options?: Configuration): Promise<V1ConfigMapList> {
        return this.api.listNamespacedConfigMap(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Endpoints
     * @param param the request object
     */
    public listNamespacedEndpointsWithHttpInfo(param: CoreV1ApiListNamespacedEndpointsRequest, options?: Configuration): Promise<HttpInfo<V1EndpointsList>> {
        return this.api.listNamespacedEndpointsWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Endpoints
     * @param param the request object
     */
    public listNamespacedEndpoints(param: CoreV1ApiListNamespacedEndpointsRequest, options?: Configuration): Promise<V1EndpointsList> {
        return this.api.listNamespacedEndpoints(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listNamespacedEventWithHttpInfo(param: CoreV1ApiListNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<CoreV1EventList>> {
        return this.api.listNamespacedEventWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listNamespacedEvent(param: CoreV1ApiListNamespacedEventRequest, options?: Configuration): Promise<CoreV1EventList> {
        return this.api.listNamespacedEvent(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LimitRange
     * @param param the request object
     */
    public listNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiListNamespacedLimitRangeRequest, options?: Configuration): Promise<HttpInfo<V1LimitRangeList>> {
        return this.api.listNamespacedLimitRangeWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LimitRange
     * @param param the request object
     */
    public listNamespacedLimitRange(param: CoreV1ApiListNamespacedLimitRangeRequest, options?: Configuration): Promise<V1LimitRangeList> {
        return this.api.listNamespacedLimitRange(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param param the request object
     */
    public listNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiListNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolumeClaimList>> {
        return this.api.listNamespacedPersistentVolumeClaimWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param param the request object
     */
    public listNamespacedPersistentVolumeClaim(param: CoreV1ApiListNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<V1PersistentVolumeClaimList> {
        return this.api.listNamespacedPersistentVolumeClaim(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Pod
     * @param param the request object
     */
    public listNamespacedPodWithHttpInfo(param: CoreV1ApiListNamespacedPodRequest, options?: Configuration): Promise<HttpInfo<V1PodList>> {
        return this.api.listNamespacedPodWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Pod
     * @param param the request object
     */
    public listNamespacedPod(param: CoreV1ApiListNamespacedPodRequest, options?: Configuration): Promise<V1PodList> {
        return this.api.listNamespacedPod(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodTemplate
     * @param param the request object
     */
    public listNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiListNamespacedPodTemplateRequest, options?: Configuration): Promise<HttpInfo<V1PodTemplateList>> {
        return this.api.listNamespacedPodTemplateWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodTemplate
     * @param param the request object
     */
    public listNamespacedPodTemplate(param: CoreV1ApiListNamespacedPodTemplateRequest, options?: Configuration): Promise<V1PodTemplateList> {
        return this.api.listNamespacedPodTemplate(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicationController
     * @param param the request object
     */
    public listNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiListNamespacedReplicationControllerRequest, options?: Configuration): Promise<HttpInfo<V1ReplicationControllerList>> {
        return this.api.listNamespacedReplicationControllerWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicationController
     * @param param the request object
     */
    public listNamespacedReplicationController(param: CoreV1ApiListNamespacedReplicationControllerRequest, options?: Configuration): Promise<V1ReplicationControllerList> {
        return this.api.listNamespacedReplicationController(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceQuota
     * @param param the request object
     */
    public listNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiListNamespacedResourceQuotaRequest, options?: Configuration): Promise<HttpInfo<V1ResourceQuotaList>> {
        return this.api.listNamespacedResourceQuotaWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceQuota
     * @param param the request object
     */
    public listNamespacedResourceQuota(param: CoreV1ApiListNamespacedResourceQuotaRequest, options?: Configuration): Promise<V1ResourceQuotaList> {
        return this.api.listNamespacedResourceQuota(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Secret
     * @param param the request object
     */
    public listNamespacedSecretWithHttpInfo(param: CoreV1ApiListNamespacedSecretRequest, options?: Configuration): Promise<HttpInfo<V1SecretList>> {
        return this.api.listNamespacedSecretWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Secret
     * @param param the request object
     */
    public listNamespacedSecret(param: CoreV1ApiListNamespacedSecretRequest, options?: Configuration): Promise<V1SecretList> {
        return this.api.listNamespacedSecret(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Service
     * @param param the request object
     */
    public listNamespacedServiceWithHttpInfo(param: CoreV1ApiListNamespacedServiceRequest, options?: Configuration): Promise<HttpInfo<V1ServiceList>> {
        return this.api.listNamespacedServiceWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Service
     * @param param the request object
     */
    public listNamespacedService(param: CoreV1ApiListNamespacedServiceRequest, options?: Configuration): Promise<V1ServiceList> {
        return this.api.listNamespacedService(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceAccount
     * @param param the request object
     */
    public listNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiListNamespacedServiceAccountRequest, options?: Configuration): Promise<HttpInfo<V1ServiceAccountList>> {
        return this.api.listNamespacedServiceAccountWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceAccount
     * @param param the request object
     */
    public listNamespacedServiceAccount(param: CoreV1ApiListNamespacedServiceAccountRequest, options?: Configuration): Promise<V1ServiceAccountList> {
        return this.api.listNamespacedServiceAccount(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Node
     * @param param the request object
     */
    public listNodeWithHttpInfo(param: CoreV1ApiListNodeRequest = {}, options?: Configuration): Promise<HttpInfo<V1NodeList>> {
        return this.api.listNodeWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Node
     * @param param the request object
     */
    public listNode(param: CoreV1ApiListNodeRequest = {}, options?: Configuration): Promise<V1NodeList> {
        return this.api.listNode(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolume
     * @param param the request object
     */
    public listPersistentVolumeWithHttpInfo(param: CoreV1ApiListPersistentVolumeRequest = {}, options?: Configuration): Promise<HttpInfo<V1PersistentVolumeList>> {
        return this.api.listPersistentVolumeWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolume
     * @param param the request object
     */
    public listPersistentVolume(param: CoreV1ApiListPersistentVolumeRequest = {}, options?: Configuration): Promise<V1PersistentVolumeList> {
        return this.api.listPersistentVolume(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param param the request object
     */
    public listPersistentVolumeClaimForAllNamespacesWithHttpInfo(param: CoreV1ApiListPersistentVolumeClaimForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1PersistentVolumeClaimList>> {
        return this.api.listPersistentVolumeClaimForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param param the request object
     */
    public listPersistentVolumeClaimForAllNamespaces(param: CoreV1ApiListPersistentVolumeClaimForAllNamespacesRequest = {}, options?: Configuration): Promise<V1PersistentVolumeClaimList> {
        return this.api.listPersistentVolumeClaimForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Pod
     * @param param the request object
     */
    public listPodForAllNamespacesWithHttpInfo(param: CoreV1ApiListPodForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1PodList>> {
        return this.api.listPodForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Pod
     * @param param the request object
     */
    public listPodForAllNamespaces(param: CoreV1ApiListPodForAllNamespacesRequest = {}, options?: Configuration): Promise<V1PodList> {
        return this.api.listPodForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodTemplate
     * @param param the request object
     */
    public listPodTemplateForAllNamespacesWithHttpInfo(param: CoreV1ApiListPodTemplateForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1PodTemplateList>> {
        return this.api.listPodTemplateForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodTemplate
     * @param param the request object
     */
    public listPodTemplateForAllNamespaces(param: CoreV1ApiListPodTemplateForAllNamespacesRequest = {}, options?: Configuration): Promise<V1PodTemplateList> {
        return this.api.listPodTemplateForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicationController
     * @param param the request object
     */
    public listReplicationControllerForAllNamespacesWithHttpInfo(param: CoreV1ApiListReplicationControllerForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1ReplicationControllerList>> {
        return this.api.listReplicationControllerForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicationController
     * @param param the request object
     */
    public listReplicationControllerForAllNamespaces(param: CoreV1ApiListReplicationControllerForAllNamespacesRequest = {}, options?: Configuration): Promise<V1ReplicationControllerList> {
        return this.api.listReplicationControllerForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceQuota
     * @param param the request object
     */
    public listResourceQuotaForAllNamespacesWithHttpInfo(param: CoreV1ApiListResourceQuotaForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1ResourceQuotaList>> {
        return this.api.listResourceQuotaForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceQuota
     * @param param the request object
     */
    public listResourceQuotaForAllNamespaces(param: CoreV1ApiListResourceQuotaForAllNamespacesRequest = {}, options?: Configuration): Promise<V1ResourceQuotaList> {
        return this.api.listResourceQuotaForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Secret
     * @param param the request object
     */
    public listSecretForAllNamespacesWithHttpInfo(param: CoreV1ApiListSecretForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1SecretList>> {
        return this.api.listSecretForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Secret
     * @param param the request object
     */
    public listSecretForAllNamespaces(param: CoreV1ApiListSecretForAllNamespacesRequest = {}, options?: Configuration): Promise<V1SecretList> {
        return this.api.listSecretForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceAccount
     * @param param the request object
     */
    public listServiceAccountForAllNamespacesWithHttpInfo(param: CoreV1ApiListServiceAccountForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1ServiceAccountList>> {
        return this.api.listServiceAccountForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceAccount
     * @param param the request object
     */
    public listServiceAccountForAllNamespaces(param: CoreV1ApiListServiceAccountForAllNamespacesRequest = {}, options?: Configuration): Promise<V1ServiceAccountList> {
        return this.api.listServiceAccountForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Service
     * @param param the request object
     */
    public listServiceForAllNamespacesWithHttpInfo(param: CoreV1ApiListServiceForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1ServiceList>> {
        return this.api.listServiceForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Service
     * @param param the request object
     */
    public listServiceForAllNamespaces(param: CoreV1ApiListServiceForAllNamespacesRequest = {}, options?: Configuration): Promise<V1ServiceList> {
        return this.api.listServiceForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified Namespace
     * @param param the request object
     */
    public patchNamespaceWithHttpInfo(param: CoreV1ApiPatchNamespaceRequest, options?: Configuration): Promise<HttpInfo<V1Namespace>> {
        return this.api.patchNamespaceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Namespace
     * @param param the request object
     */
    public patchNamespace(param: CoreV1ApiPatchNamespaceRequest, options?: Configuration): Promise<V1Namespace> {
        return this.api.patchNamespace(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Namespace
     * @param param the request object
     */
    public patchNamespaceStatusWithHttpInfo(param: CoreV1ApiPatchNamespaceStatusRequest, options?: Configuration): Promise<HttpInfo<V1Namespace>> {
        return this.api.patchNamespaceStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Namespace
     * @param param the request object
     */
    public patchNamespaceStatus(param: CoreV1ApiPatchNamespaceStatusRequest, options?: Configuration): Promise<V1Namespace> {
        return this.api.patchNamespaceStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ConfigMap
     * @param param the request object
     */
    public patchNamespacedConfigMapWithHttpInfo(param: CoreV1ApiPatchNamespacedConfigMapRequest, options?: Configuration): Promise<HttpInfo<V1ConfigMap>> {
        return this.api.patchNamespacedConfigMapWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ConfigMap
     * @param param the request object
     */
    public patchNamespacedConfigMap(param: CoreV1ApiPatchNamespacedConfigMapRequest, options?: Configuration): Promise<V1ConfigMap> {
        return this.api.patchNamespacedConfigMap(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Endpoints
     * @param param the request object
     */
    public patchNamespacedEndpointsWithHttpInfo(param: CoreV1ApiPatchNamespacedEndpointsRequest, options?: Configuration): Promise<HttpInfo<V1Endpoints>> {
        return this.api.patchNamespacedEndpointsWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Endpoints
     * @param param the request object
     */
    public patchNamespacedEndpoints(param: CoreV1ApiPatchNamespacedEndpointsRequest, options?: Configuration): Promise<V1Endpoints> {
        return this.api.patchNamespacedEndpoints(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Event
     * @param param the request object
     */
    public patchNamespacedEventWithHttpInfo(param: CoreV1ApiPatchNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<CoreV1Event>> {
        return this.api.patchNamespacedEventWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Event
     * @param param the request object
     */
    public patchNamespacedEvent(param: CoreV1ApiPatchNamespacedEventRequest, options?: Configuration): Promise<CoreV1Event> {
        return this.api.patchNamespacedEvent(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified LimitRange
     * @param param the request object
     */
    public patchNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiPatchNamespacedLimitRangeRequest, options?: Configuration): Promise<HttpInfo<V1LimitRange>> {
        return this.api.patchNamespacedLimitRangeWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified LimitRange
     * @param param the request object
     */
    public patchNamespacedLimitRange(param: CoreV1ApiPatchNamespacedLimitRangeRequest, options?: Configuration): Promise<V1LimitRange> {
        return this.api.patchNamespacedLimitRange(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PersistentVolumeClaim
     * @param param the request object
     */
    public patchNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiPatchNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.patchNamespacedPersistentVolumeClaimWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PersistentVolumeClaim
     * @param param the request object
     */
    public patchNamespacedPersistentVolumeClaim(param: CoreV1ApiPatchNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<V1PersistentVolumeClaim> {
        return this.api.patchNamespacedPersistentVolumeClaim(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public patchNamespacedPersistentVolumeClaimStatusWithHttpInfo(param: CoreV1ApiPatchNamespacedPersistentVolumeClaimStatusRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.patchNamespacedPersistentVolumeClaimStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public patchNamespacedPersistentVolumeClaimStatus(param: CoreV1ApiPatchNamespacedPersistentVolumeClaimStatusRequest, options?: Configuration): Promise<V1PersistentVolumeClaim> {
        return this.api.patchNamespacedPersistentVolumeClaimStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodWithHttpInfo(param: CoreV1ApiPatchNamespacedPodRequest, options?: Configuration): Promise<HttpInfo<V1Pod>> {
        return this.api.patchNamespacedPodWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Pod
     * @param param the request object
     */
    public patchNamespacedPod(param: CoreV1ApiPatchNamespacedPodRequest, options?: Configuration): Promise<V1Pod> {
        return this.api.patchNamespacedPod(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodEphemeralcontainersWithHttpInfo(param: CoreV1ApiPatchNamespacedPodEphemeralcontainersRequest, options?: Configuration): Promise<HttpInfo<V1Pod>> {
        return this.api.patchNamespacedPodEphemeralcontainersWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodEphemeralcontainers(param: CoreV1ApiPatchNamespacedPodEphemeralcontainersRequest, options?: Configuration): Promise<V1Pod> {
        return this.api.patchNamespacedPodEphemeralcontainers(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodStatusWithHttpInfo(param: CoreV1ApiPatchNamespacedPodStatusRequest, options?: Configuration): Promise<HttpInfo<V1Pod>> {
        return this.api.patchNamespacedPodStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodStatus(param: CoreV1ApiPatchNamespacedPodStatusRequest, options?: Configuration): Promise<V1Pod> {
        return this.api.patchNamespacedPodStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PodTemplate
     * @param param the request object
     */
    public patchNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiPatchNamespacedPodTemplateRequest, options?: Configuration): Promise<HttpInfo<V1PodTemplate>> {
        return this.api.patchNamespacedPodTemplateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PodTemplate
     * @param param the request object
     */
    public patchNamespacedPodTemplate(param: CoreV1ApiPatchNamespacedPodTemplateRequest, options?: Configuration): Promise<V1PodTemplate> {
        return this.api.patchNamespacedPodTemplate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiPatchNamespacedReplicationControllerRequest, options?: Configuration): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.patchNamespacedReplicationControllerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationController(param: CoreV1ApiPatchNamespacedReplicationControllerRequest, options?: Configuration): Promise<V1ReplicationController> {
        return this.api.patchNamespacedReplicationController(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationControllerScaleWithHttpInfo(param: CoreV1ApiPatchNamespacedReplicationControllerScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.patchNamespacedReplicationControllerScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationControllerScale(param: CoreV1ApiPatchNamespacedReplicationControllerScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.patchNamespacedReplicationControllerScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationControllerStatusWithHttpInfo(param: CoreV1ApiPatchNamespacedReplicationControllerStatusRequest, options?: Configuration): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.patchNamespacedReplicationControllerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationControllerStatus(param: CoreV1ApiPatchNamespacedReplicationControllerStatusRequest, options?: Configuration): Promise<V1ReplicationController> {
        return this.api.patchNamespacedReplicationControllerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceQuota
     * @param param the request object
     */
    public patchNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiPatchNamespacedResourceQuotaRequest, options?: Configuration): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.patchNamespacedResourceQuotaWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceQuota
     * @param param the request object
     */
    public patchNamespacedResourceQuota(param: CoreV1ApiPatchNamespacedResourceQuotaRequest, options?: Configuration): Promise<V1ResourceQuota> {
        return this.api.patchNamespacedResourceQuota(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ResourceQuota
     * @param param the request object
     */
    public patchNamespacedResourceQuotaStatusWithHttpInfo(param: CoreV1ApiPatchNamespacedResourceQuotaStatusRequest, options?: Configuration): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.patchNamespacedResourceQuotaStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ResourceQuota
     * @param param the request object
     */
    public patchNamespacedResourceQuotaStatus(param: CoreV1ApiPatchNamespacedResourceQuotaStatusRequest, options?: Configuration): Promise<V1ResourceQuota> {
        return this.api.patchNamespacedResourceQuotaStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Secret
     * @param param the request object
     */
    public patchNamespacedSecretWithHttpInfo(param: CoreV1ApiPatchNamespacedSecretRequest, options?: Configuration): Promise<HttpInfo<V1Secret>> {
        return this.api.patchNamespacedSecretWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Secret
     * @param param the request object
     */
    public patchNamespacedSecret(param: CoreV1ApiPatchNamespacedSecretRequest, options?: Configuration): Promise<V1Secret> {
        return this.api.patchNamespacedSecret(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Service
     * @param param the request object
     */
    public patchNamespacedServiceWithHttpInfo(param: CoreV1ApiPatchNamespacedServiceRequest, options?: Configuration): Promise<HttpInfo<V1Service>> {
        return this.api.patchNamespacedServiceWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Service
     * @param param the request object
     */
    public patchNamespacedService(param: CoreV1ApiPatchNamespacedServiceRequest, options?: Configuration): Promise<V1Service> {
        return this.api.patchNamespacedService(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ServiceAccount
     * @param param the request object
     */
    public patchNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiPatchNamespacedServiceAccountRequest, options?: Configuration): Promise<HttpInfo<V1ServiceAccount>> {
        return this.api.patchNamespacedServiceAccountWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ServiceAccount
     * @param param the request object
     */
    public patchNamespacedServiceAccount(param: CoreV1ApiPatchNamespacedServiceAccountRequest, options?: Configuration): Promise<V1ServiceAccount> {
        return this.api.patchNamespacedServiceAccount(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Service
     * @param param the request object
     */
    public patchNamespacedServiceStatusWithHttpInfo(param: CoreV1ApiPatchNamespacedServiceStatusRequest, options?: Configuration): Promise<HttpInfo<V1Service>> {
        return this.api.patchNamespacedServiceStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Service
     * @param param the request object
     */
    public patchNamespacedServiceStatus(param: CoreV1ApiPatchNamespacedServiceStatusRequest, options?: Configuration): Promise<V1Service> {
        return this.api.patchNamespacedServiceStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Node
     * @param param the request object
     */
    public patchNodeWithHttpInfo(param: CoreV1ApiPatchNodeRequest, options?: Configuration): Promise<HttpInfo<V1Node>> {
        return this.api.patchNodeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Node
     * @param param the request object
     */
    public patchNode(param: CoreV1ApiPatchNodeRequest, options?: Configuration): Promise<V1Node> {
        return this.api.patchNode(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Node
     * @param param the request object
     */
    public patchNodeStatusWithHttpInfo(param: CoreV1ApiPatchNodeStatusRequest, options?: Configuration): Promise<HttpInfo<V1Node>> {
        return this.api.patchNodeStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Node
     * @param param the request object
     */
    public patchNodeStatus(param: CoreV1ApiPatchNodeStatusRequest, options?: Configuration): Promise<V1Node> {
        return this.api.patchNodeStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PersistentVolume
     * @param param the request object
     */
    public patchPersistentVolumeWithHttpInfo(param: CoreV1ApiPatchPersistentVolumeRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.patchPersistentVolumeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PersistentVolume
     * @param param the request object
     */
    public patchPersistentVolume(param: CoreV1ApiPatchPersistentVolumeRequest, options?: Configuration): Promise<V1PersistentVolume> {
        return this.api.patchPersistentVolume(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PersistentVolume
     * @param param the request object
     */
    public patchPersistentVolumeStatusWithHttpInfo(param: CoreV1ApiPatchPersistentVolumeStatusRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.patchPersistentVolumeStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PersistentVolume
     * @param param the request object
     */
    public patchPersistentVolumeStatus(param: CoreV1ApiPatchPersistentVolumeStatusRequest, options?: Configuration): Promise<V1PersistentVolume> {
        return this.api.patchPersistentVolumeStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified ComponentStatus
     * @param param the request object
     */
    public readComponentStatusWithHttpInfo(param: CoreV1ApiReadComponentStatusRequest, options?: Configuration): Promise<HttpInfo<V1ComponentStatus>> {
        return this.api.readComponentStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ComponentStatus
     * @param param the request object
     */
    public readComponentStatus(param: CoreV1ApiReadComponentStatusRequest, options?: Configuration): Promise<V1ComponentStatus> {
        return this.api.readComponentStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Namespace
     * @param param the request object
     */
    public readNamespaceWithHttpInfo(param: CoreV1ApiReadNamespaceRequest, options?: Configuration): Promise<HttpInfo<V1Namespace>> {
        return this.api.readNamespaceWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Namespace
     * @param param the request object
     */
    public readNamespace(param: CoreV1ApiReadNamespaceRequest, options?: Configuration): Promise<V1Namespace> {
        return this.api.readNamespace(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Namespace
     * @param param the request object
     */
    public readNamespaceStatusWithHttpInfo(param: CoreV1ApiReadNamespaceStatusRequest, options?: Configuration): Promise<HttpInfo<V1Namespace>> {
        return this.api.readNamespaceStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Namespace
     * @param param the request object
     */
    public readNamespaceStatus(param: CoreV1ApiReadNamespaceStatusRequest, options?: Configuration): Promise<V1Namespace> {
        return this.api.readNamespaceStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ConfigMap
     * @param param the request object
     */
    public readNamespacedConfigMapWithHttpInfo(param: CoreV1ApiReadNamespacedConfigMapRequest, options?: Configuration): Promise<HttpInfo<V1ConfigMap>> {
        return this.api.readNamespacedConfigMapWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ConfigMap
     * @param param the request object
     */
    public readNamespacedConfigMap(param: CoreV1ApiReadNamespacedConfigMapRequest, options?: Configuration): Promise<V1ConfigMap> {
        return this.api.readNamespacedConfigMap(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Endpoints
     * @param param the request object
     */
    public readNamespacedEndpointsWithHttpInfo(param: CoreV1ApiReadNamespacedEndpointsRequest, options?: Configuration): Promise<HttpInfo<V1Endpoints>> {
        return this.api.readNamespacedEndpointsWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Endpoints
     * @param param the request object
     */
    public readNamespacedEndpoints(param: CoreV1ApiReadNamespacedEndpointsRequest, options?: Configuration): Promise<V1Endpoints> {
        return this.api.readNamespacedEndpoints(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Event
     * @param param the request object
     */
    public readNamespacedEventWithHttpInfo(param: CoreV1ApiReadNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<CoreV1Event>> {
        return this.api.readNamespacedEventWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Event
     * @param param the request object
     */
    public readNamespacedEvent(param: CoreV1ApiReadNamespacedEventRequest, options?: Configuration): Promise<CoreV1Event> {
        return this.api.readNamespacedEvent(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified LimitRange
     * @param param the request object
     */
    public readNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiReadNamespacedLimitRangeRequest, options?: Configuration): Promise<HttpInfo<V1LimitRange>> {
        return this.api.readNamespacedLimitRangeWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified LimitRange
     * @param param the request object
     */
    public readNamespacedLimitRange(param: CoreV1ApiReadNamespacedLimitRangeRequest, options?: Configuration): Promise<V1LimitRange> {
        return this.api.readNamespacedLimitRange(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PersistentVolumeClaim
     * @param param the request object
     */
    public readNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiReadNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.readNamespacedPersistentVolumeClaimWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PersistentVolumeClaim
     * @param param the request object
     */
    public readNamespacedPersistentVolumeClaim(param: CoreV1ApiReadNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<V1PersistentVolumeClaim> {
        return this.api.readNamespacedPersistentVolumeClaim(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public readNamespacedPersistentVolumeClaimStatusWithHttpInfo(param: CoreV1ApiReadNamespacedPersistentVolumeClaimStatusRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.readNamespacedPersistentVolumeClaimStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public readNamespacedPersistentVolumeClaimStatus(param: CoreV1ApiReadNamespacedPersistentVolumeClaimStatusRequest, options?: Configuration): Promise<V1PersistentVolumeClaim> {
        return this.api.readNamespacedPersistentVolumeClaimStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Pod
     * @param param the request object
     */
    public readNamespacedPodWithHttpInfo(param: CoreV1ApiReadNamespacedPodRequest, options?: Configuration): Promise<HttpInfo<V1Pod>> {
        return this.api.readNamespacedPodWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Pod
     * @param param the request object
     */
    public readNamespacedPod(param: CoreV1ApiReadNamespacedPodRequest, options?: Configuration): Promise<V1Pod> {
        return this.api.readNamespacedPod(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodEphemeralcontainersWithHttpInfo(param: CoreV1ApiReadNamespacedPodEphemeralcontainersRequest, options?: Configuration): Promise<HttpInfo<V1Pod>> {
        return this.api.readNamespacedPodEphemeralcontainersWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodEphemeralcontainers(param: CoreV1ApiReadNamespacedPodEphemeralcontainersRequest, options?: Configuration): Promise<V1Pod> {
        return this.api.readNamespacedPodEphemeralcontainers(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read log of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodLogWithHttpInfo(param: CoreV1ApiReadNamespacedPodLogRequest, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.readNamespacedPodLogWithHttpInfo(param.name, param.namespace, param.container, param.follow, param.insecureSkipTLSVerifyBackend, param.limitBytes, param.pretty, param.previous, param.sinceSeconds, param.tailLines, param.timestamps,  options).toPromise();
    }

    /**
     * read log of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodLog(param: CoreV1ApiReadNamespacedPodLogRequest, options?: Configuration): Promise<string> {
        return this.api.readNamespacedPodLog(param.name, param.namespace, param.container, param.follow, param.insecureSkipTLSVerifyBackend, param.limitBytes, param.pretty, param.previous, param.sinceSeconds, param.tailLines, param.timestamps,  options).toPromise();
    }

    /**
     * read status of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodStatusWithHttpInfo(param: CoreV1ApiReadNamespacedPodStatusRequest, options?: Configuration): Promise<HttpInfo<V1Pod>> {
        return this.api.readNamespacedPodStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodStatus(param: CoreV1ApiReadNamespacedPodStatusRequest, options?: Configuration): Promise<V1Pod> {
        return this.api.readNamespacedPodStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PodTemplate
     * @param param the request object
     */
    public readNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiReadNamespacedPodTemplateRequest, options?: Configuration): Promise<HttpInfo<V1PodTemplate>> {
        return this.api.readNamespacedPodTemplateWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PodTemplate
     * @param param the request object
     */
    public readNamespacedPodTemplate(param: CoreV1ApiReadNamespacedPodTemplateRequest, options?: Configuration): Promise<V1PodTemplate> {
        return this.api.readNamespacedPodTemplate(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiReadNamespacedReplicationControllerRequest, options?: Configuration): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.readNamespacedReplicationControllerWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationController(param: CoreV1ApiReadNamespacedReplicationControllerRequest, options?: Configuration): Promise<V1ReplicationController> {
        return this.api.readNamespacedReplicationController(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationControllerScaleWithHttpInfo(param: CoreV1ApiReadNamespacedReplicationControllerScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.readNamespacedReplicationControllerScaleWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationControllerScale(param: CoreV1ApiReadNamespacedReplicationControllerScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.readNamespacedReplicationControllerScale(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationControllerStatusWithHttpInfo(param: CoreV1ApiReadNamespacedReplicationControllerStatusRequest, options?: Configuration): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.readNamespacedReplicationControllerStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationControllerStatus(param: CoreV1ApiReadNamespacedReplicationControllerStatusRequest, options?: Configuration): Promise<V1ReplicationController> {
        return this.api.readNamespacedReplicationControllerStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceQuota
     * @param param the request object
     */
    public readNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiReadNamespacedResourceQuotaRequest, options?: Configuration): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.readNamespacedResourceQuotaWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceQuota
     * @param param the request object
     */
    public readNamespacedResourceQuota(param: CoreV1ApiReadNamespacedResourceQuotaRequest, options?: Configuration): Promise<V1ResourceQuota> {
        return this.api.readNamespacedResourceQuota(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ResourceQuota
     * @param param the request object
     */
    public readNamespacedResourceQuotaStatusWithHttpInfo(param: CoreV1ApiReadNamespacedResourceQuotaStatusRequest, options?: Configuration): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.readNamespacedResourceQuotaStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ResourceQuota
     * @param param the request object
     */
    public readNamespacedResourceQuotaStatus(param: CoreV1ApiReadNamespacedResourceQuotaStatusRequest, options?: Configuration): Promise<V1ResourceQuota> {
        return this.api.readNamespacedResourceQuotaStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Secret
     * @param param the request object
     */
    public readNamespacedSecretWithHttpInfo(param: CoreV1ApiReadNamespacedSecretRequest, options?: Configuration): Promise<HttpInfo<V1Secret>> {
        return this.api.readNamespacedSecretWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Secret
     * @param param the request object
     */
    public readNamespacedSecret(param: CoreV1ApiReadNamespacedSecretRequest, options?: Configuration): Promise<V1Secret> {
        return this.api.readNamespacedSecret(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Service
     * @param param the request object
     */
    public readNamespacedServiceWithHttpInfo(param: CoreV1ApiReadNamespacedServiceRequest, options?: Configuration): Promise<HttpInfo<V1Service>> {
        return this.api.readNamespacedServiceWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Service
     * @param param the request object
     */
    public readNamespacedService(param: CoreV1ApiReadNamespacedServiceRequest, options?: Configuration): Promise<V1Service> {
        return this.api.readNamespacedService(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ServiceAccount
     * @param param the request object
     */
    public readNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiReadNamespacedServiceAccountRequest, options?: Configuration): Promise<HttpInfo<V1ServiceAccount>> {
        return this.api.readNamespacedServiceAccountWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ServiceAccount
     * @param param the request object
     */
    public readNamespacedServiceAccount(param: CoreV1ApiReadNamespacedServiceAccountRequest, options?: Configuration): Promise<V1ServiceAccount> {
        return this.api.readNamespacedServiceAccount(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Service
     * @param param the request object
     */
    public readNamespacedServiceStatusWithHttpInfo(param: CoreV1ApiReadNamespacedServiceStatusRequest, options?: Configuration): Promise<HttpInfo<V1Service>> {
        return this.api.readNamespacedServiceStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Service
     * @param param the request object
     */
    public readNamespacedServiceStatus(param: CoreV1ApiReadNamespacedServiceStatusRequest, options?: Configuration): Promise<V1Service> {
        return this.api.readNamespacedServiceStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Node
     * @param param the request object
     */
    public readNodeWithHttpInfo(param: CoreV1ApiReadNodeRequest, options?: Configuration): Promise<HttpInfo<V1Node>> {
        return this.api.readNodeWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Node
     * @param param the request object
     */
    public readNode(param: CoreV1ApiReadNodeRequest, options?: Configuration): Promise<V1Node> {
        return this.api.readNode(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Node
     * @param param the request object
     */
    public readNodeStatusWithHttpInfo(param: CoreV1ApiReadNodeStatusRequest, options?: Configuration): Promise<HttpInfo<V1Node>> {
        return this.api.readNodeStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Node
     * @param param the request object
     */
    public readNodeStatus(param: CoreV1ApiReadNodeStatusRequest, options?: Configuration): Promise<V1Node> {
        return this.api.readNodeStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PersistentVolume
     * @param param the request object
     */
    public readPersistentVolumeWithHttpInfo(param: CoreV1ApiReadPersistentVolumeRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.readPersistentVolumeWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PersistentVolume
     * @param param the request object
     */
    public readPersistentVolume(param: CoreV1ApiReadPersistentVolumeRequest, options?: Configuration): Promise<V1PersistentVolume> {
        return this.api.readPersistentVolume(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PersistentVolume
     * @param param the request object
     */
    public readPersistentVolumeStatusWithHttpInfo(param: CoreV1ApiReadPersistentVolumeStatusRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.readPersistentVolumeStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PersistentVolume
     * @param param the request object
     */
    public readPersistentVolumeStatus(param: CoreV1ApiReadPersistentVolumeStatusRequest, options?: Configuration): Promise<V1PersistentVolume> {
        return this.api.readPersistentVolumeStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified Namespace
     * @param param the request object
     */
    public replaceNamespaceWithHttpInfo(param: CoreV1ApiReplaceNamespaceRequest, options?: Configuration): Promise<HttpInfo<V1Namespace>> {
        return this.api.replaceNamespaceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Namespace
     * @param param the request object
     */
    public replaceNamespace(param: CoreV1ApiReplaceNamespaceRequest, options?: Configuration): Promise<V1Namespace> {
        return this.api.replaceNamespace(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace finalize of the specified Namespace
     * @param param the request object
     */
    public replaceNamespaceFinalizeWithHttpInfo(param: CoreV1ApiReplaceNamespaceFinalizeRequest, options?: Configuration): Promise<HttpInfo<V1Namespace>> {
        return this.api.replaceNamespaceFinalizeWithHttpInfo(param.name, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * replace finalize of the specified Namespace
     * @param param the request object
     */
    public replaceNamespaceFinalize(param: CoreV1ApiReplaceNamespaceFinalizeRequest, options?: Configuration): Promise<V1Namespace> {
        return this.api.replaceNamespaceFinalize(param.name, param.body, param.dryRun, param.fieldManager, param.pretty,  options).toPromise();
    }

    /**
     * replace status of the specified Namespace
     * @param param the request object
     */
    public replaceNamespaceStatusWithHttpInfo(param: CoreV1ApiReplaceNamespaceStatusRequest, options?: Configuration): Promise<HttpInfo<V1Namespace>> {
        return this.api.replaceNamespaceStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Namespace
     * @param param the request object
     */
    public replaceNamespaceStatus(param: CoreV1ApiReplaceNamespaceStatusRequest, options?: Configuration): Promise<V1Namespace> {
        return this.api.replaceNamespaceStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ConfigMap
     * @param param the request object
     */
    public replaceNamespacedConfigMapWithHttpInfo(param: CoreV1ApiReplaceNamespacedConfigMapRequest, options?: Configuration): Promise<HttpInfo<V1ConfigMap>> {
        return this.api.replaceNamespacedConfigMapWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ConfigMap
     * @param param the request object
     */
    public replaceNamespacedConfigMap(param: CoreV1ApiReplaceNamespacedConfigMapRequest, options?: Configuration): Promise<V1ConfigMap> {
        return this.api.replaceNamespacedConfigMap(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Endpoints
     * @param param the request object
     */
    public replaceNamespacedEndpointsWithHttpInfo(param: CoreV1ApiReplaceNamespacedEndpointsRequest, options?: Configuration): Promise<HttpInfo<V1Endpoints>> {
        return this.api.replaceNamespacedEndpointsWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Endpoints
     * @param param the request object
     */
    public replaceNamespacedEndpoints(param: CoreV1ApiReplaceNamespacedEndpointsRequest, options?: Configuration): Promise<V1Endpoints> {
        return this.api.replaceNamespacedEndpoints(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Event
     * @param param the request object
     */
    public replaceNamespacedEventWithHttpInfo(param: CoreV1ApiReplaceNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<CoreV1Event>> {
        return this.api.replaceNamespacedEventWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Event
     * @param param the request object
     */
    public replaceNamespacedEvent(param: CoreV1ApiReplaceNamespacedEventRequest, options?: Configuration): Promise<CoreV1Event> {
        return this.api.replaceNamespacedEvent(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified LimitRange
     * @param param the request object
     */
    public replaceNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiReplaceNamespacedLimitRangeRequest, options?: Configuration): Promise<HttpInfo<V1LimitRange>> {
        return this.api.replaceNamespacedLimitRangeWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified LimitRange
     * @param param the request object
     */
    public replaceNamespacedLimitRange(param: CoreV1ApiReplaceNamespacedLimitRangeRequest, options?: Configuration): Promise<V1LimitRange> {
        return this.api.replaceNamespacedLimitRange(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PersistentVolumeClaim
     * @param param the request object
     */
    public replaceNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiReplaceNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.replaceNamespacedPersistentVolumeClaimWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PersistentVolumeClaim
     * @param param the request object
     */
    public replaceNamespacedPersistentVolumeClaim(param: CoreV1ApiReplaceNamespacedPersistentVolumeClaimRequest, options?: Configuration): Promise<V1PersistentVolumeClaim> {
        return this.api.replaceNamespacedPersistentVolumeClaim(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public replaceNamespacedPersistentVolumeClaimStatusWithHttpInfo(param: CoreV1ApiReplaceNamespacedPersistentVolumeClaimStatusRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.replaceNamespacedPersistentVolumeClaimStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public replaceNamespacedPersistentVolumeClaimStatus(param: CoreV1ApiReplaceNamespacedPersistentVolumeClaimStatusRequest, options?: Configuration): Promise<V1PersistentVolumeClaim> {
        return this.api.replaceNamespacedPersistentVolumeClaimStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodWithHttpInfo(param: CoreV1ApiReplaceNamespacedPodRequest, options?: Configuration): Promise<HttpInfo<V1Pod>> {
        return this.api.replaceNamespacedPodWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPod(param: CoreV1ApiReplaceNamespacedPodRequest, options?: Configuration): Promise<V1Pod> {
        return this.api.replaceNamespacedPod(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodEphemeralcontainersWithHttpInfo(param: CoreV1ApiReplaceNamespacedPodEphemeralcontainersRequest, options?: Configuration): Promise<HttpInfo<V1Pod>> {
        return this.api.replaceNamespacedPodEphemeralcontainersWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodEphemeralcontainers(param: CoreV1ApiReplaceNamespacedPodEphemeralcontainersRequest, options?: Configuration): Promise<V1Pod> {
        return this.api.replaceNamespacedPodEphemeralcontainers(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodStatusWithHttpInfo(param: CoreV1ApiReplaceNamespacedPodStatusRequest, options?: Configuration): Promise<HttpInfo<V1Pod>> {
        return this.api.replaceNamespacedPodStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodStatus(param: CoreV1ApiReplaceNamespacedPodStatusRequest, options?: Configuration): Promise<V1Pod> {
        return this.api.replaceNamespacedPodStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PodTemplate
     * @param param the request object
     */
    public replaceNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiReplaceNamespacedPodTemplateRequest, options?: Configuration): Promise<HttpInfo<V1PodTemplate>> {
        return this.api.replaceNamespacedPodTemplateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PodTemplate
     * @param param the request object
     */
    public replaceNamespacedPodTemplate(param: CoreV1ApiReplaceNamespacedPodTemplateRequest, options?: Configuration): Promise<V1PodTemplate> {
        return this.api.replaceNamespacedPodTemplate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiReplaceNamespacedReplicationControllerRequest, options?: Configuration): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.replaceNamespacedReplicationControllerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationController(param: CoreV1ApiReplaceNamespacedReplicationControllerRequest, options?: Configuration): Promise<V1ReplicationController> {
        return this.api.replaceNamespacedReplicationController(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationControllerScaleWithHttpInfo(param: CoreV1ApiReplaceNamespacedReplicationControllerScaleRequest, options?: Configuration): Promise<HttpInfo<V1Scale>> {
        return this.api.replaceNamespacedReplicationControllerScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationControllerScale(param: CoreV1ApiReplaceNamespacedReplicationControllerScaleRequest, options?: Configuration): Promise<V1Scale> {
        return this.api.replaceNamespacedReplicationControllerScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationControllerStatusWithHttpInfo(param: CoreV1ApiReplaceNamespacedReplicationControllerStatusRequest, options?: Configuration): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.replaceNamespacedReplicationControllerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationControllerStatus(param: CoreV1ApiReplaceNamespacedReplicationControllerStatusRequest, options?: Configuration): Promise<V1ReplicationController> {
        return this.api.replaceNamespacedReplicationControllerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ResourceQuota
     * @param param the request object
     */
    public replaceNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiReplaceNamespacedResourceQuotaRequest, options?: Configuration): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.replaceNamespacedResourceQuotaWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ResourceQuota
     * @param param the request object
     */
    public replaceNamespacedResourceQuota(param: CoreV1ApiReplaceNamespacedResourceQuotaRequest, options?: Configuration): Promise<V1ResourceQuota> {
        return this.api.replaceNamespacedResourceQuota(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified ResourceQuota
     * @param param the request object
     */
    public replaceNamespacedResourceQuotaStatusWithHttpInfo(param: CoreV1ApiReplaceNamespacedResourceQuotaStatusRequest, options?: Configuration): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.replaceNamespacedResourceQuotaStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified ResourceQuota
     * @param param the request object
     */
    public replaceNamespacedResourceQuotaStatus(param: CoreV1ApiReplaceNamespacedResourceQuotaStatusRequest, options?: Configuration): Promise<V1ResourceQuota> {
        return this.api.replaceNamespacedResourceQuotaStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Secret
     * @param param the request object
     */
    public replaceNamespacedSecretWithHttpInfo(param: CoreV1ApiReplaceNamespacedSecretRequest, options?: Configuration): Promise<HttpInfo<V1Secret>> {
        return this.api.replaceNamespacedSecretWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Secret
     * @param param the request object
     */
    public replaceNamespacedSecret(param: CoreV1ApiReplaceNamespacedSecretRequest, options?: Configuration): Promise<V1Secret> {
        return this.api.replaceNamespacedSecret(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Service
     * @param param the request object
     */
    public replaceNamespacedServiceWithHttpInfo(param: CoreV1ApiReplaceNamespacedServiceRequest, options?: Configuration): Promise<HttpInfo<V1Service>> {
        return this.api.replaceNamespacedServiceWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Service
     * @param param the request object
     */
    public replaceNamespacedService(param: CoreV1ApiReplaceNamespacedServiceRequest, options?: Configuration): Promise<V1Service> {
        return this.api.replaceNamespacedService(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ServiceAccount
     * @param param the request object
     */
    public replaceNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiReplaceNamespacedServiceAccountRequest, options?: Configuration): Promise<HttpInfo<V1ServiceAccount>> {
        return this.api.replaceNamespacedServiceAccountWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ServiceAccount
     * @param param the request object
     */
    public replaceNamespacedServiceAccount(param: CoreV1ApiReplaceNamespacedServiceAccountRequest, options?: Configuration): Promise<V1ServiceAccount> {
        return this.api.replaceNamespacedServiceAccount(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Service
     * @param param the request object
     */
    public replaceNamespacedServiceStatusWithHttpInfo(param: CoreV1ApiReplaceNamespacedServiceStatusRequest, options?: Configuration): Promise<HttpInfo<V1Service>> {
        return this.api.replaceNamespacedServiceStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Service
     * @param param the request object
     */
    public replaceNamespacedServiceStatus(param: CoreV1ApiReplaceNamespacedServiceStatusRequest, options?: Configuration): Promise<V1Service> {
        return this.api.replaceNamespacedServiceStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Node
     * @param param the request object
     */
    public replaceNodeWithHttpInfo(param: CoreV1ApiReplaceNodeRequest, options?: Configuration): Promise<HttpInfo<V1Node>> {
        return this.api.replaceNodeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Node
     * @param param the request object
     */
    public replaceNode(param: CoreV1ApiReplaceNodeRequest, options?: Configuration): Promise<V1Node> {
        return this.api.replaceNode(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Node
     * @param param the request object
     */
    public replaceNodeStatusWithHttpInfo(param: CoreV1ApiReplaceNodeStatusRequest, options?: Configuration): Promise<HttpInfo<V1Node>> {
        return this.api.replaceNodeStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Node
     * @param param the request object
     */
    public replaceNodeStatus(param: CoreV1ApiReplaceNodeStatusRequest, options?: Configuration): Promise<V1Node> {
        return this.api.replaceNodeStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PersistentVolume
     * @param param the request object
     */
    public replacePersistentVolumeWithHttpInfo(param: CoreV1ApiReplacePersistentVolumeRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.replacePersistentVolumeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PersistentVolume
     * @param param the request object
     */
    public replacePersistentVolume(param: CoreV1ApiReplacePersistentVolumeRequest, options?: Configuration): Promise<V1PersistentVolume> {
        return this.api.replacePersistentVolume(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified PersistentVolume
     * @param param the request object
     */
    public replacePersistentVolumeStatusWithHttpInfo(param: CoreV1ApiReplacePersistentVolumeStatusRequest, options?: Configuration): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.replacePersistentVolumeStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified PersistentVolume
     * @param param the request object
     */
    public replacePersistentVolumeStatus(param: CoreV1ApiReplacePersistentVolumeStatusRequest, options?: Configuration): Promise<V1PersistentVolume> {
        return this.api.replacePersistentVolumeStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableCustomObjectsApi } from "./ObservableAPI";
import { CustomObjectsApiRequestFactory, CustomObjectsApiResponseProcessor} from "../apis/CustomObjectsApi";

export interface CustomObjectsApiCreateClusterCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    plural: string
    /**
     * The JSON schema of the Resource to create.
     * @type any
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    fieldManager?: string
}

export interface CustomObjectsApiCreateNamespacedCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    namespace: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    plural: string
    /**
     * The JSON schema of the Resource to create.
     * @type any
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    fieldManager?: string
}

export interface CustomObjectsApiDeleteClusterCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    version: string
    /**
     * the custom object\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    name: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    propagationPolicy?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    dryRun?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    body?: V1DeleteOptions
}

export interface CustomObjectsApiDeleteCollectionClusterCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    plural: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    pretty?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    propagationPolicy?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    dryRun?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    body?: V1DeleteOptions
}

export interface CustomObjectsApiDeleteCollectionNamespacedCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    namespace: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    plural: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    pretty?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    propagationPolicy?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    dryRun?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    body?: V1DeleteOptions
}

export interface CustomObjectsApiDeleteNamespacedCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    name: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    propagationPolicy?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    dryRun?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    body?: V1DeleteOptions
}

export interface CustomObjectsApiGetAPIResourcesRequest {
    /**
     * The custom resource\&#39;s group name
     * @type string
     * @memberof CustomObjectsApigetAPIResources
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApigetAPIResources
     */
    version: string
}

export interface CustomObjectsApiGetClusterCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObject
     */
    version: string
    /**
     * the custom object\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObject
     */
    name: string
}

export interface CustomObjectsApiGetClusterCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectScale
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectScale
     */
    name: string
}

export interface CustomObjectsApiGetClusterCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectStatus
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectStatus
     */
    name: string
}

export interface CustomObjectsApiGetNamespacedCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObject
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObject
     */
    name: string
}

export interface CustomObjectsApiGetNamespacedCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectScale
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectScale
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectScale
     */
    name: string
}

export interface CustomObjectsApiGetNamespacedCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectStatus
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectStatus
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectStatus
     */
    name: string
}

export interface CustomObjectsApiListClusterCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    plural: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    limit?: number
    /**
     * When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications.
     * @type boolean
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    watch?: boolean
}

export interface CustomObjectsApiListNamespacedCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    namespace: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    plural: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    limit?: number
    /**
     * When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications.
     * @type boolean
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    watch?: boolean
}

export interface CustomObjectsApiPatchClusterCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    version: string
    /**
     * the custom object\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    name: string
    /**
     * The JSON schema of the Resource to patch.
     * @type any
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    force?: boolean
}

export interface CustomObjectsApiPatchClusterCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    force?: boolean
}

export interface CustomObjectsApiPatchClusterCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    force?: boolean
}

export interface CustomObjectsApiPatchNamespacedCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    name: string
    /**
     * The JSON schema of the Resource to patch.
     * @type any
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    force?: boolean
}

export interface CustomObjectsApiPatchNamespacedCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    force?: boolean
}

export interface CustomObjectsApiPatchNamespacedCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    force?: boolean
}

export interface CustomObjectsApiReplaceClusterCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    version: string
    /**
     * the custom object\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    name: string
    /**
     * The JSON schema of the Resource to replace.
     * @type any
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    fieldManager?: string
}

export interface CustomObjectsApiReplaceClusterCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    fieldManager?: string
}

export interface CustomObjectsApiReplaceClusterCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    fieldManager?: string
}

export interface CustomObjectsApiReplaceNamespacedCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    name: string
    /**
     * The JSON schema of the Resource to replace.
     * @type any
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    fieldManager?: string
}

export interface CustomObjectsApiReplaceNamespacedCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    fieldManager?: string
}

export interface CustomObjectsApiReplaceNamespacedCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    fieldManager?: string
}

export class ObjectCustomObjectsApi {
    private api: ObservableCustomObjectsApi

    public constructor(configuration: Configuration, requestFactory?: CustomObjectsApiRequestFactory, responseProcessor?: CustomObjectsApiResponseProcessor) {
        this.api = new ObservableCustomObjectsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Creates a cluster scoped Custom object
     * @param param the request object
     */
    public createClusterCustomObjectWithHttpInfo(param: CustomObjectsApiCreateClusterCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.createClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * Creates a cluster scoped Custom object
     * @param param the request object
     */
    public createClusterCustomObject(param: CustomObjectsApiCreateClusterCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.createClusterCustomObject(param.group, param.version, param.plural, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * Creates a namespace scoped Custom object
     * @param param the request object
     */
    public createNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiCreateNamespacedCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.createNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * Creates a namespace scoped Custom object
     * @param param the request object
     */
    public createNamespacedCustomObject(param: CustomObjectsApiCreateNamespacedCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.createNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * Deletes the specified cluster scoped custom object
     * @param param the request object
     */
    public deleteClusterCustomObjectWithHttpInfo(param: CustomObjectsApiDeleteClusterCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.deleteClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.name, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Deletes the specified cluster scoped custom object
     * @param param the request object
     */
    public deleteClusterCustomObject(param: CustomObjectsApiDeleteClusterCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.deleteClusterCustomObject(param.group, param.version, param.plural, param.name, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Delete collection of cluster scoped custom objects
     * @param param the request object
     */
    public deleteCollectionClusterCustomObjectWithHttpInfo(param: CustomObjectsApiDeleteCollectionClusterCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.deleteCollectionClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.pretty, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Delete collection of cluster scoped custom objects
     * @param param the request object
     */
    public deleteCollectionClusterCustomObject(param: CustomObjectsApiDeleteCollectionClusterCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.deleteCollectionClusterCustomObject(param.group, param.version, param.plural, param.pretty, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Delete collection of namespace scoped custom objects
     * @param param the request object
     */
    public deleteCollectionNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiDeleteCollectionNamespacedCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.deleteCollectionNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.pretty, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Delete collection of namespace scoped custom objects
     * @param param the request object
     */
    public deleteCollectionNamespacedCustomObject(param: CustomObjectsApiDeleteCollectionNamespacedCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.deleteCollectionNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.pretty, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Deletes the specified namespace scoped custom object
     * @param param the request object
     */
    public deleteNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiDeleteNamespacedCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.deleteNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Deletes the specified namespace scoped custom object
     * @param param the request object
     */
    public deleteNamespacedCustomObject(param: CustomObjectsApiDeleteNamespacedCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.deleteNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.name, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CustomObjectsApiGetAPIResourcesRequest, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo(param.group, param.version,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CustomObjectsApiGetAPIResourcesRequest, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources(param.group, param.version,  options).toPromise();
    }

    /**
     * Returns a cluster scoped custom object
     * @param param the request object
     */
    public getClusterCustomObjectWithHttpInfo(param: CustomObjectsApiGetClusterCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.getClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * Returns a cluster scoped custom object
     * @param param the request object
     */
    public getClusterCustomObject(param: CustomObjectsApiGetClusterCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.getClusterCustomObject(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * read scale of the specified custom object
     * @param param the request object
     */
    public getClusterCustomObjectScaleWithHttpInfo(param: CustomObjectsApiGetClusterCustomObjectScaleRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.getClusterCustomObjectScaleWithHttpInfo(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * read scale of the specified custom object
     * @param param the request object
     */
    public getClusterCustomObjectScale(param: CustomObjectsApiGetClusterCustomObjectScaleRequest, options?: Configuration): Promise<any> {
        return this.api.getClusterCustomObjectScale(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * read status of the specified cluster scoped custom object
     * @param param the request object
     */
    public getClusterCustomObjectStatusWithHttpInfo(param: CustomObjectsApiGetClusterCustomObjectStatusRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.getClusterCustomObjectStatusWithHttpInfo(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * read status of the specified cluster scoped custom object
     * @param param the request object
     */
    public getClusterCustomObjectStatus(param: CustomObjectsApiGetClusterCustomObjectStatusRequest, options?: Configuration): Promise<any> {
        return this.api.getClusterCustomObjectStatus(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * Returns a namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiGetNamespacedCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.getNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * Returns a namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObject(param: CustomObjectsApiGetNamespacedCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.getNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * read scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObjectScaleWithHttpInfo(param: CustomObjectsApiGetNamespacedCustomObjectScaleRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.getNamespacedCustomObjectScaleWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * read scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObjectScale(param: CustomObjectsApiGetNamespacedCustomObjectScaleRequest, options?: Configuration): Promise<any> {
        return this.api.getNamespacedCustomObjectScale(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * read status of the specified namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObjectStatusWithHttpInfo(param: CustomObjectsApiGetNamespacedCustomObjectStatusRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.getNamespacedCustomObjectStatusWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * read status of the specified namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObjectStatus(param: CustomObjectsApiGetNamespacedCustomObjectStatusRequest, options?: Configuration): Promise<any> {
        return this.api.getNamespacedCustomObjectStatus(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * list or watch cluster scoped custom objects
     * @param param the request object
     */
    public listClusterCustomObjectWithHttpInfo(param: CustomObjectsApiListClusterCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.listClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch cluster scoped custom objects
     * @param param the request object
     */
    public listClusterCustomObject(param: CustomObjectsApiListClusterCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.listClusterCustomObject(param.group, param.version, param.plural, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch namespace scoped custom objects
     * @param param the request object
     */
    public listNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiListNamespacedCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.listNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch namespace scoped custom objects
     * @param param the request object
     */
    public listNamespacedCustomObject(param: CustomObjectsApiListNamespacedCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.listNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * patch the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObjectWithHttpInfo(param: CustomObjectsApiPatchClusterCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.patchClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * patch the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObject(param: CustomObjectsApiPatchClusterCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.patchClusterCustomObject(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObjectScaleWithHttpInfo(param: CustomObjectsApiPatchClusterCustomObjectScaleRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.patchClusterCustomObjectScaleWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObjectScale(param: CustomObjectsApiPatchClusterCustomObjectScaleRequest, options?: Configuration): Promise<any> {
        return this.api.patchClusterCustomObjectScale(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObjectStatusWithHttpInfo(param: CustomObjectsApiPatchClusterCustomObjectStatusRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.patchClusterCustomObjectStatusWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObjectStatus(param: CustomObjectsApiPatchClusterCustomObjectStatusRequest, options?: Configuration): Promise<any> {
        return this.api.patchClusterCustomObjectStatus(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * patch the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiPatchNamespacedCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.patchNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * patch the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObject(param: CustomObjectsApiPatchNamespacedCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.patchNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObjectScaleWithHttpInfo(param: CustomObjectsApiPatchNamespacedCustomObjectScaleRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.patchNamespacedCustomObjectScaleWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObjectScale(param: CustomObjectsApiPatchNamespacedCustomObjectScaleRequest, options?: Configuration): Promise<any> {
        return this.api.patchNamespacedCustomObjectScale(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObjectStatusWithHttpInfo(param: CustomObjectsApiPatchNamespacedCustomObjectStatusRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.patchNamespacedCustomObjectStatusWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObjectStatus(param: CustomObjectsApiPatchNamespacedCustomObjectStatusRequest, options?: Configuration): Promise<any> {
        return this.api.patchNamespacedCustomObjectStatus(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * replace the specified cluster scoped custom object
     * @param param the request object
     */
    public replaceClusterCustomObjectWithHttpInfo(param: CustomObjectsApiReplaceClusterCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.replaceClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified cluster scoped custom object
     * @param param the request object
     */
    public replaceClusterCustomObject(param: CustomObjectsApiReplaceClusterCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.replaceClusterCustomObject(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified cluster scoped custom object
     * @param param the request object
     */
    public replaceClusterCustomObjectScaleWithHttpInfo(param: CustomObjectsApiReplaceClusterCustomObjectScaleRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.replaceClusterCustomObjectScaleWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified cluster scoped custom object
     * @param param the request object
     */
    public replaceClusterCustomObjectScale(param: CustomObjectsApiReplaceClusterCustomObjectScaleRequest, options?: Configuration): Promise<any> {
        return this.api.replaceClusterCustomObjectScale(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the cluster scoped specified custom object
     * @param param the request object
     */
    public replaceClusterCustomObjectStatusWithHttpInfo(param: CustomObjectsApiReplaceClusterCustomObjectStatusRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.replaceClusterCustomObjectStatusWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the cluster scoped specified custom object
     * @param param the request object
     */
    public replaceClusterCustomObjectStatus(param: CustomObjectsApiReplaceClusterCustomObjectStatusRequest, options?: Configuration): Promise<any> {
        return this.api.replaceClusterCustomObjectStatus(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiReplaceNamespacedCustomObjectRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.replaceNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObject(param: CustomObjectsApiReplaceNamespacedCustomObjectRequest, options?: Configuration): Promise<any> {
        return this.api.replaceNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObjectScaleWithHttpInfo(param: CustomObjectsApiReplaceNamespacedCustomObjectScaleRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.replaceNamespacedCustomObjectScaleWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObjectScale(param: CustomObjectsApiReplaceNamespacedCustomObjectScaleRequest, options?: Configuration): Promise<any> {
        return this.api.replaceNamespacedCustomObjectScale(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObjectStatusWithHttpInfo(param: CustomObjectsApiReplaceNamespacedCustomObjectStatusRequest, options?: Configuration): Promise<HttpInfo<any>> {
        return this.api.replaceNamespacedCustomObjectStatusWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObjectStatus(param: CustomObjectsApiReplaceNamespacedCustomObjectStatusRequest, options?: Configuration): Promise<any> {
        return this.api.replaceNamespacedCustomObjectStatus(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableDiscoveryApi } from "./ObservableAPI";
import { DiscoveryApiRequestFactory, DiscoveryApiResponseProcessor} from "../apis/DiscoveryApi";

export interface DiscoveryApiGetAPIGroupRequest {
}

export class ObjectDiscoveryApi {
    private api: ObservableDiscoveryApi

    public constructor(configuration: Configuration, requestFactory?: DiscoveryApiRequestFactory, responseProcessor?: DiscoveryApiResponseProcessor) {
        this.api = new ObservableDiscoveryApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: DiscoveryApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: DiscoveryApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableDiscoveryV1Api } from "./ObservableAPI";
import { DiscoveryV1ApiRequestFactory, DiscoveryV1ApiResponseProcessor} from "../apis/DiscoveryV1Api";

export interface DiscoveryV1ApiCreateNamespacedEndpointSliceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1ApicreateNamespacedEndpointSlice
     */
    namespace: string
    /**
     * 
     * @type V1EndpointSlice
     * @memberof DiscoveryV1ApicreateNamespacedEndpointSlice
     */
    body: V1EndpointSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1ApicreateNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1ApicreateNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof DiscoveryV1ApicreateNamespacedEndpointSlice
     */
    fieldManager?: string
}

export interface DiscoveryV1ApiDeleteCollectionNamespacedEndpointSliceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    body?: V1DeleteOptions
}

export interface DiscoveryV1ApiDeleteNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    body?: V1DeleteOptions
}

export interface DiscoveryV1ApiGetAPIResourcesRequest {
}

export interface DiscoveryV1ApiListEndpointSliceForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    watch?: boolean
}

export interface DiscoveryV1ApiListNamespacedEndpointSliceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    watch?: boolean
}

export interface DiscoveryV1ApiPatchNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    force?: boolean
}

export interface DiscoveryV1ApiReadNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1ApireadNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1ApireadNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1ApireadNamespacedEndpointSlice
     */
    pretty?: string
}

export interface DiscoveryV1ApiReplaceNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    namespace: string
    /**
     * 
     * @type V1EndpointSlice
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    body: V1EndpointSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    fieldManager?: string
}

export class ObjectDiscoveryV1Api {
    private api: ObservableDiscoveryV1Api

    public constructor(configuration: Configuration, requestFactory?: DiscoveryV1ApiRequestFactory, responseProcessor?: DiscoveryV1ApiResponseProcessor) {
        this.api = new ObservableDiscoveryV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create an EndpointSlice
     * @param param the request object
     */
    public createNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiCreateNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1EndpointSlice>> {
        return this.api.createNamespacedEndpointSliceWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create an EndpointSlice
     * @param param the request object
     */
    public createNamespacedEndpointSlice(param: DiscoveryV1ApiCreateNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1EndpointSlice> {
        return this.api.createNamespacedEndpointSlice(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of EndpointSlice
     * @param param the request object
     */
    public deleteCollectionNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiDeleteCollectionNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedEndpointSliceWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of EndpointSlice
     * @param param the request object
     */
    public deleteCollectionNamespacedEndpointSlice(param: DiscoveryV1ApiDeleteCollectionNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedEndpointSlice(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete an EndpointSlice
     * @param param the request object
     */
    public deleteNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiDeleteNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an EndpointSlice
     * @param param the request object
     */
    public deleteNamespacedEndpointSlice(param: DiscoveryV1ApiDeleteNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedEndpointSlice(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: DiscoveryV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: DiscoveryV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listEndpointSliceForAllNamespacesWithHttpInfo(param: DiscoveryV1ApiListEndpointSliceForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1EndpointSliceList>> {
        return this.api.listEndpointSliceForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listEndpointSliceForAllNamespaces(param: DiscoveryV1ApiListEndpointSliceForAllNamespacesRequest = {}, options?: Configuration): Promise<V1EndpointSliceList> {
        return this.api.listEndpointSliceForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiListNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1EndpointSliceList>> {
        return this.api.listNamespacedEndpointSliceWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listNamespacedEndpointSlice(param: DiscoveryV1ApiListNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1EndpointSliceList> {
        return this.api.listNamespacedEndpointSlice(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified EndpointSlice
     * @param param the request object
     */
    public patchNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiPatchNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1EndpointSlice>> {
        return this.api.patchNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified EndpointSlice
     * @param param the request object
     */
    public patchNamespacedEndpointSlice(param: DiscoveryV1ApiPatchNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1EndpointSlice> {
        return this.api.patchNamespacedEndpointSlice(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified EndpointSlice
     * @param param the request object
     */
    public readNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiReadNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1EndpointSlice>> {
        return this.api.readNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified EndpointSlice
     * @param param the request object
     */
    public readNamespacedEndpointSlice(param: DiscoveryV1ApiReadNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1EndpointSlice> {
        return this.api.readNamespacedEndpointSlice(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified EndpointSlice
     * @param param the request object
     */
    public replaceNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiReplaceNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1EndpointSlice>> {
        return this.api.replaceNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified EndpointSlice
     * @param param the request object
     */
    public replaceNamespacedEndpointSlice(param: DiscoveryV1ApiReplaceNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1EndpointSlice> {
        return this.api.replaceNamespacedEndpointSlice(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableDiscoveryV1beta1Api } from "./ObservableAPI";
import { DiscoveryV1beta1ApiRequestFactory, DiscoveryV1beta1ApiResponseProcessor} from "../apis/DiscoveryV1beta1Api";

export interface DiscoveryV1beta1ApiCreateNamespacedEndpointSliceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApicreateNamespacedEndpointSlice
     */
    namespace: string
    /**
     * 
     * @type V1beta1EndpointSlice
     * @memberof DiscoveryV1beta1ApicreateNamespacedEndpointSlice
     */
    body: V1beta1EndpointSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApicreateNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1beta1ApicreateNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof DiscoveryV1beta1ApicreateNamespacedEndpointSlice
     */
    fieldManager?: string
}

export interface DiscoveryV1beta1ApiDeleteCollectionNamespacedEndpointSliceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof DiscoveryV1beta1ApideleteCollectionNamespacedEndpointSlice
     */
    body?: V1DeleteOptions
}

export interface DiscoveryV1beta1ApiDeleteNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1beta1ApideleteNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApideleteNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1beta1ApideleteNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof DiscoveryV1beta1ApideleteNamespacedEndpointSlice
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof DiscoveryV1beta1ApideleteNamespacedEndpointSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteNamespacedEndpointSlice
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof DiscoveryV1beta1ApideleteNamespacedEndpointSlice
     */
    body?: V1DeleteOptions
}

export interface DiscoveryV1beta1ApiGetAPIResourcesRequest {
}

export interface DiscoveryV1beta1ApiListEndpointSliceForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof DiscoveryV1beta1ApilistEndpointSliceForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1beta1ApilistEndpointSliceForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApilistEndpointSliceForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApilistEndpointSliceForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1beta1ApilistEndpointSliceForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApilistEndpointSliceForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApilistEndpointSliceForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApilistEndpointSliceForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1beta1ApilistEndpointSliceForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof DiscoveryV1beta1ApilistEndpointSliceForAllNamespaces
     */
    watch?: boolean
}

export interface DiscoveryV1beta1ApiListNamespacedEndpointSliceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApilistNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApilistNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof DiscoveryV1beta1ApilistNamespacedEndpointSlice
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1beta1ApilistNamespacedEndpointSlice
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApilistNamespacedEndpointSlice
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApilistNamespacedEndpointSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1beta1ApilistNamespacedEndpointSlice
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApilistNamespacedEndpointSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApilistNamespacedEndpointSlice
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1beta1ApilistNamespacedEndpointSlice
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof DiscoveryV1beta1ApilistNamespacedEndpointSlice
     */
    watch?: boolean
}

export interface DiscoveryV1beta1ApiPatchNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1beta1ApipatchNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApipatchNamespacedEndpointSlice
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof DiscoveryV1beta1ApipatchNamespacedEndpointSlice
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApipatchNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1beta1ApipatchNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof DiscoveryV1beta1ApipatchNamespacedEndpointSlice
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof DiscoveryV1beta1ApipatchNamespacedEndpointSlice
     */
    force?: boolean
}

export interface DiscoveryV1beta1ApiReadNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1beta1ApireadNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApireadNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApireadNamespacedEndpointSlice
     */
    pretty?: string
}

export interface DiscoveryV1beta1ApiReplaceNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1beta1ApireplaceNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApireplaceNamespacedEndpointSlice
     */
    namespace: string
    /**
     * 
     * @type V1beta1EndpointSlice
     * @memberof DiscoveryV1beta1ApireplaceNamespacedEndpointSlice
     */
    body: V1beta1EndpointSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApireplaceNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1beta1ApireplaceNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof DiscoveryV1beta1ApireplaceNamespacedEndpointSlice
     */
    fieldManager?: string
}

export class ObjectDiscoveryV1beta1Api {
    private api: ObservableDiscoveryV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: DiscoveryV1beta1ApiRequestFactory, responseProcessor?: DiscoveryV1beta1ApiResponseProcessor) {
        this.api = new ObservableDiscoveryV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create an EndpointSlice
     * @param param the request object
     */
    public createNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1beta1ApiCreateNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1beta1EndpointSlice>> {
        return this.api.createNamespacedEndpointSliceWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create an EndpointSlice
     * @param param the request object
     */
    public createNamespacedEndpointSlice(param: DiscoveryV1beta1ApiCreateNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1beta1EndpointSlice> {
        return this.api.createNamespacedEndpointSlice(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of EndpointSlice
     * @param param the request object
     */
    public deleteCollectionNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1beta1ApiDeleteCollectionNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedEndpointSliceWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of EndpointSlice
     * @param param the request object
     */
    public deleteCollectionNamespacedEndpointSlice(param: DiscoveryV1beta1ApiDeleteCollectionNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedEndpointSlice(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete an EndpointSlice
     * @param param the request object
     */
    public deleteNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1beta1ApiDeleteNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an EndpointSlice
     * @param param the request object
     */
    public deleteNamespacedEndpointSlice(param: DiscoveryV1beta1ApiDeleteNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedEndpointSlice(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: DiscoveryV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: DiscoveryV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listEndpointSliceForAllNamespacesWithHttpInfo(param: DiscoveryV1beta1ApiListEndpointSliceForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1beta1EndpointSliceList>> {
        return this.api.listEndpointSliceForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listEndpointSliceForAllNamespaces(param: DiscoveryV1beta1ApiListEndpointSliceForAllNamespacesRequest = {}, options?: Configuration): Promise<V1beta1EndpointSliceList> {
        return this.api.listEndpointSliceForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1beta1ApiListNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1beta1EndpointSliceList>> {
        return this.api.listNamespacedEndpointSliceWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listNamespacedEndpointSlice(param: DiscoveryV1beta1ApiListNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1beta1EndpointSliceList> {
        return this.api.listNamespacedEndpointSlice(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified EndpointSlice
     * @param param the request object
     */
    public patchNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1beta1ApiPatchNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1beta1EndpointSlice>> {
        return this.api.patchNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified EndpointSlice
     * @param param the request object
     */
    public patchNamespacedEndpointSlice(param: DiscoveryV1beta1ApiPatchNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1beta1EndpointSlice> {
        return this.api.patchNamespacedEndpointSlice(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified EndpointSlice
     * @param param the request object
     */
    public readNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1beta1ApiReadNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1beta1EndpointSlice>> {
        return this.api.readNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified EndpointSlice
     * @param param the request object
     */
    public readNamespacedEndpointSlice(param: DiscoveryV1beta1ApiReadNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1beta1EndpointSlice> {
        return this.api.readNamespacedEndpointSlice(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified EndpointSlice
     * @param param the request object
     */
    public replaceNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1beta1ApiReplaceNamespacedEndpointSliceRequest, options?: Configuration): Promise<HttpInfo<V1beta1EndpointSlice>> {
        return this.api.replaceNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified EndpointSlice
     * @param param the request object
     */
    public replaceNamespacedEndpointSlice(param: DiscoveryV1beta1ApiReplaceNamespacedEndpointSliceRequest, options?: Configuration): Promise<V1beta1EndpointSlice> {
        return this.api.replaceNamespacedEndpointSlice(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableEventsApi } from "./ObservableAPI";
import { EventsApiRequestFactory, EventsApiResponseProcessor} from "../apis/EventsApi";

export interface EventsApiGetAPIGroupRequest {
}

export class ObjectEventsApi {
    private api: ObservableEventsApi

    public constructor(configuration: Configuration, requestFactory?: EventsApiRequestFactory, responseProcessor?: EventsApiResponseProcessor) {
        this.api = new ObservableEventsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: EventsApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: EventsApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableEventsV1Api } from "./ObservableAPI";
import { EventsV1ApiRequestFactory, EventsV1ApiResponseProcessor} from "../apis/EventsV1Api";

export interface EventsV1ApiCreateNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApicreateNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type EventsV1Event
     * @memberof EventsV1ApicreateNamespacedEvent
     */
    body: EventsV1Event
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApicreateNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1ApicreateNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof EventsV1ApicreateNamespacedEvent
     */
    fieldManager?: string
}

export interface EventsV1ApiDeleteCollectionNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    body?: V1DeleteOptions
}

export interface EventsV1ApiDeleteNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    body?: V1DeleteOptions
}

export interface EventsV1ApiGetAPIResourcesRequest {
}

export interface EventsV1ApiListEventForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    watch?: boolean
}

export interface EventsV1ApiListNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof EventsV1ApilistNamespacedEvent
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1ApilistNamespacedEvent
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1ApilistNamespacedEvent
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1ApilistNamespacedEvent
     */
    watch?: boolean
}

export interface EventsV1ApiPatchNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    force?: boolean
}

export interface EventsV1ApiReadNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof EventsV1ApireadNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApireadNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApireadNamespacedEvent
     */
    pretty?: string
}

export interface EventsV1ApiReplaceNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type EventsV1Event
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    body: EventsV1Event
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    fieldManager?: string
}

export class ObjectEventsV1Api {
    private api: ObservableEventsV1Api

    public constructor(configuration: Configuration, requestFactory?: EventsV1ApiRequestFactory, responseProcessor?: EventsV1ApiResponseProcessor) {
        this.api = new ObservableEventsV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create an Event
     * @param param the request object
     */
    public createNamespacedEventWithHttpInfo(param: EventsV1ApiCreateNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<EventsV1Event>> {
        return this.api.createNamespacedEventWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create an Event
     * @param param the request object
     */
    public createNamespacedEvent(param: EventsV1ApiCreateNamespacedEventRequest, options?: Configuration): Promise<EventsV1Event> {
        return this.api.createNamespacedEvent(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of Event
     * @param param the request object
     */
    public deleteCollectionNamespacedEventWithHttpInfo(param: EventsV1ApiDeleteCollectionNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedEventWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Event
     * @param param the request object
     */
    public deleteCollectionNamespacedEvent(param: EventsV1ApiDeleteCollectionNamespacedEventRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedEvent(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete an Event
     * @param param the request object
     */
    public deleteNamespacedEventWithHttpInfo(param: EventsV1ApiDeleteNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedEventWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an Event
     * @param param the request object
     */
    public deleteNamespacedEvent(param: EventsV1ApiDeleteNamespacedEventRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedEvent(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: EventsV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: EventsV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listEventForAllNamespacesWithHttpInfo(param: EventsV1ApiListEventForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<EventsV1EventList>> {
        return this.api.listEventForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listEventForAllNamespaces(param: EventsV1ApiListEventForAllNamespacesRequest = {}, options?: Configuration): Promise<EventsV1EventList> {
        return this.api.listEventForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listNamespacedEventWithHttpInfo(param: EventsV1ApiListNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<EventsV1EventList>> {
        return this.api.listNamespacedEventWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listNamespacedEvent(param: EventsV1ApiListNamespacedEventRequest, options?: Configuration): Promise<EventsV1EventList> {
        return this.api.listNamespacedEvent(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified Event
     * @param param the request object
     */
    public patchNamespacedEventWithHttpInfo(param: EventsV1ApiPatchNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<EventsV1Event>> {
        return this.api.patchNamespacedEventWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Event
     * @param param the request object
     */
    public patchNamespacedEvent(param: EventsV1ApiPatchNamespacedEventRequest, options?: Configuration): Promise<EventsV1Event> {
        return this.api.patchNamespacedEvent(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified Event
     * @param param the request object
     */
    public readNamespacedEventWithHttpInfo(param: EventsV1ApiReadNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<EventsV1Event>> {
        return this.api.readNamespacedEventWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Event
     * @param param the request object
     */
    public readNamespacedEvent(param: EventsV1ApiReadNamespacedEventRequest, options?: Configuration): Promise<EventsV1Event> {
        return this.api.readNamespacedEvent(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified Event
     * @param param the request object
     */
    public replaceNamespacedEventWithHttpInfo(param: EventsV1ApiReplaceNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<EventsV1Event>> {
        return this.api.replaceNamespacedEventWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Event
     * @param param the request object
     */
    public replaceNamespacedEvent(param: EventsV1ApiReplaceNamespacedEventRequest, options?: Configuration): Promise<EventsV1Event> {
        return this.api.replaceNamespacedEvent(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableEventsV1beta1Api } from "./ObservableAPI";
import { EventsV1beta1ApiRequestFactory, EventsV1beta1ApiResponseProcessor} from "../apis/EventsV1beta1Api";

export interface EventsV1beta1ApiCreateNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApicreateNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type V1beta1Event
     * @memberof EventsV1beta1ApicreateNamespacedEvent
     */
    body: V1beta1Event
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApicreateNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1beta1ApicreateNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof EventsV1beta1ApicreateNamespacedEvent
     */
    fieldManager?: string
}

export interface EventsV1beta1ApiDeleteCollectionNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof EventsV1beta1ApideleteCollectionNamespacedEvent
     */
    body?: V1DeleteOptions
}

export interface EventsV1beta1ApiDeleteNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof EventsV1beta1ApideleteNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApideleteNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApideleteNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1beta1ApideleteNamespacedEvent
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof EventsV1beta1ApideleteNamespacedEvent
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof EventsV1beta1ApideleteNamespacedEvent
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof EventsV1beta1ApideleteNamespacedEvent
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof EventsV1beta1ApideleteNamespacedEvent
     */
    body?: V1DeleteOptions
}

export interface EventsV1beta1ApiGetAPIResourcesRequest {
}

export interface EventsV1beta1ApiListEventForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof EventsV1beta1ApilistEventForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1beta1ApilistEventForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApilistEventForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApilistEventForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1beta1ApilistEventForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApilistEventForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApilistEventForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApilistEventForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1beta1ApilistEventForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1beta1ApilistEventForAllNamespaces
     */
    watch?: boolean
}

export interface EventsV1beta1ApiListNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApilistNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApilistNamespacedEvent
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof EventsV1beta1ApilistNamespacedEvent
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1beta1ApilistNamespacedEvent
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApilistNamespacedEvent
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApilistNamespacedEvent
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1beta1ApilistNamespacedEvent
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApilistNamespacedEvent
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApilistNamespacedEvent
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1beta1ApilistNamespacedEvent
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1beta1ApilistNamespacedEvent
     */
    watch?: boolean
}

export interface EventsV1beta1ApiPatchNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof EventsV1beta1ApipatchNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApipatchNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof EventsV1beta1ApipatchNamespacedEvent
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApipatchNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1beta1ApipatchNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof EventsV1beta1ApipatchNamespacedEvent
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof EventsV1beta1ApipatchNamespacedEvent
     */
    force?: boolean
}

export interface EventsV1beta1ApiReadNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof EventsV1beta1ApireadNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApireadNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApireadNamespacedEvent
     */
    pretty?: string
}

export interface EventsV1beta1ApiReplaceNamespacedEventRequest {
    /**
     * name of the Event
     * @type string
     * @memberof EventsV1beta1ApireplaceNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApireplaceNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type V1beta1Event
     * @memberof EventsV1beta1ApireplaceNamespacedEvent
     */
    body: V1beta1Event
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApireplaceNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1beta1ApireplaceNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof EventsV1beta1ApireplaceNamespacedEvent
     */
    fieldManager?: string
}

export class ObjectEventsV1beta1Api {
    private api: ObservableEventsV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: EventsV1beta1ApiRequestFactory, responseProcessor?: EventsV1beta1ApiResponseProcessor) {
        this.api = new ObservableEventsV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create an Event
     * @param param the request object
     */
    public createNamespacedEventWithHttpInfo(param: EventsV1beta1ApiCreateNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<V1beta1Event>> {
        return this.api.createNamespacedEventWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create an Event
     * @param param the request object
     */
    public createNamespacedEvent(param: EventsV1beta1ApiCreateNamespacedEventRequest, options?: Configuration): Promise<V1beta1Event> {
        return this.api.createNamespacedEvent(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of Event
     * @param param the request object
     */
    public deleteCollectionNamespacedEventWithHttpInfo(param: EventsV1beta1ApiDeleteCollectionNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedEventWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Event
     * @param param the request object
     */
    public deleteCollectionNamespacedEvent(param: EventsV1beta1ApiDeleteCollectionNamespacedEventRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedEvent(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete an Event
     * @param param the request object
     */
    public deleteNamespacedEventWithHttpInfo(param: EventsV1beta1ApiDeleteNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedEventWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an Event
     * @param param the request object
     */
    public deleteNamespacedEvent(param: EventsV1beta1ApiDeleteNamespacedEventRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedEvent(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: EventsV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: EventsV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listEventForAllNamespacesWithHttpInfo(param: EventsV1beta1ApiListEventForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1beta1EventList>> {
        return this.api.listEventForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listEventForAllNamespaces(param: EventsV1beta1ApiListEventForAllNamespacesRequest = {}, options?: Configuration): Promise<V1beta1EventList> {
        return this.api.listEventForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listNamespacedEventWithHttpInfo(param: EventsV1beta1ApiListNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<V1beta1EventList>> {
        return this.api.listNamespacedEventWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listNamespacedEvent(param: EventsV1beta1ApiListNamespacedEventRequest, options?: Configuration): Promise<V1beta1EventList> {
        return this.api.listNamespacedEvent(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified Event
     * @param param the request object
     */
    public patchNamespacedEventWithHttpInfo(param: EventsV1beta1ApiPatchNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<V1beta1Event>> {
        return this.api.patchNamespacedEventWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Event
     * @param param the request object
     */
    public patchNamespacedEvent(param: EventsV1beta1ApiPatchNamespacedEventRequest, options?: Configuration): Promise<V1beta1Event> {
        return this.api.patchNamespacedEvent(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified Event
     * @param param the request object
     */
    public readNamespacedEventWithHttpInfo(param: EventsV1beta1ApiReadNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<V1beta1Event>> {
        return this.api.readNamespacedEventWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Event
     * @param param the request object
     */
    public readNamespacedEvent(param: EventsV1beta1ApiReadNamespacedEventRequest, options?: Configuration): Promise<V1beta1Event> {
        return this.api.readNamespacedEvent(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified Event
     * @param param the request object
     */
    public replaceNamespacedEventWithHttpInfo(param: EventsV1beta1ApiReplaceNamespacedEventRequest, options?: Configuration): Promise<HttpInfo<V1beta1Event>> {
        return this.api.replaceNamespacedEventWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Event
     * @param param the request object
     */
    public replaceNamespacedEvent(param: EventsV1beta1ApiReplaceNamespacedEventRequest, options?: Configuration): Promise<V1beta1Event> {
        return this.api.replaceNamespacedEvent(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableFlowcontrolApiserverApi } from "./ObservableAPI";
import { FlowcontrolApiserverApiRequestFactory, FlowcontrolApiserverApiResponseProcessor} from "../apis/FlowcontrolApiserverApi";

export interface FlowcontrolApiserverApiGetAPIGroupRequest {
}

export class ObjectFlowcontrolApiserverApi {
    private api: ObservableFlowcontrolApiserverApi

    public constructor(configuration: Configuration, requestFactory?: FlowcontrolApiserverApiRequestFactory, responseProcessor?: FlowcontrolApiserverApiResponseProcessor) {
        this.api = new ObservableFlowcontrolApiserverApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: FlowcontrolApiserverApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: FlowcontrolApiserverApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableFlowcontrolApiserverV1beta1Api } from "./ObservableAPI";
import { FlowcontrolApiserverV1beta1ApiRequestFactory, FlowcontrolApiserverV1beta1ApiResponseProcessor} from "../apis/FlowcontrolApiserverV1beta1Api";

export interface FlowcontrolApiserverV1beta1ApiCreateFlowSchemaRequest {
    /**
     * 
     * @type V1beta1FlowSchema
     * @memberof FlowcontrolApiserverV1beta1ApicreateFlowSchema
     */
    body: V1beta1FlowSchema
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApicreateFlowSchema
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApicreateFlowSchema
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApicreateFlowSchema
     */
    fieldManager?: string
}

export interface FlowcontrolApiserverV1beta1ApiCreatePriorityLevelConfigurationRequest {
    /**
     * 
     * @type V1beta1PriorityLevelConfiguration
     * @memberof FlowcontrolApiserverV1beta1ApicreatePriorityLevelConfiguration
     */
    body: V1beta1PriorityLevelConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApicreatePriorityLevelConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApicreatePriorityLevelConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApicreatePriorityLevelConfiguration
     */
    fieldManager?: string
}

export interface FlowcontrolApiserverV1beta1ApiDeleteCollectionFlowSchemaRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionFlowSchema
     */
    body?: V1DeleteOptions
}

export interface FlowcontrolApiserverV1beta1ApiDeleteCollectionPriorityLevelConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof FlowcontrolApiserverV1beta1ApideleteCollectionPriorityLevelConfiguration
     */
    body?: V1DeleteOptions
}

export interface FlowcontrolApiserverV1beta1ApiDeleteFlowSchemaRequest {
    /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteFlowSchema
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteFlowSchema
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteFlowSchema
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApideleteFlowSchema
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApideleteFlowSchema
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideleteFlowSchema
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof FlowcontrolApiserverV1beta1ApideleteFlowSchema
     */
    body?: V1DeleteOptions
}

export interface FlowcontrolApiserverV1beta1ApiDeletePriorityLevelConfigurationRequest {
    /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideletePriorityLevelConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideletePriorityLevelConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideletePriorityLevelConfiguration
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApideletePriorityLevelConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApideletePriorityLevelConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApideletePriorityLevelConfiguration
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof FlowcontrolApiserverV1beta1ApideletePriorityLevelConfiguration
     */
    body?: V1DeleteOptions
}

export interface FlowcontrolApiserverV1beta1ApiGetAPIResourcesRequest {
}

export interface FlowcontrolApiserverV1beta1ApiListFlowSchemaRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistFlowSchema
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApilistFlowSchema
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistFlowSchema
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistFlowSchema
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistFlowSchema
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApilistFlowSchema
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistFlowSchema
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistFlowSchema
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApilistFlowSchema
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApilistFlowSchema
     */
    watch?: boolean
}

export interface FlowcontrolApiserverV1beta1ApiListPriorityLevelConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistPriorityLevelConfiguration
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApilistPriorityLevelConfiguration
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistPriorityLevelConfiguration
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistPriorityLevelConfiguration
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistPriorityLevelConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApilistPriorityLevelConfiguration
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistPriorityLevelConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApilistPriorityLevelConfiguration
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1beta1ApilistPriorityLevelConfiguration
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApilistPriorityLevelConfiguration
     */
    watch?: boolean
}

export interface FlowcontrolApiserverV1beta1ApiPatchFlowSchemaRequest {
    /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchema
     */
    name: string
    /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchema
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchema
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchema
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchema
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchema
     */
    force?: boolean
}

export interface FlowcontrolApiserverV1beta1ApiPatchFlowSchemaStatusRequest {
    /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchemaStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchemaStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchemaStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchemaStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchemaStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApipatchFlowSchemaStatus
     */
    force?: boolean
}

export interface FlowcontrolApiserverV1beta1ApiPatchPriorityLevelConfigurationRequest {
    /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfiguration
     */
    name: string
    /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfiguration
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfiguration
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfiguration
     */
    force?: boolean
}

export interface FlowcontrolApiserverV1beta1ApiPatchPriorityLevelConfigurationStatusRequest {
    /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfigurationStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfigurationStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfigurationStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfigurationStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfigurationStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof FlowcontrolApiserverV1beta1ApipatchPriorityLevelConfigurationStatus
     */
    force?: boolean
}

export interface FlowcontrolApiserverV1beta1ApiReadFlowSchemaRequest {
    /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireadFlowSchema
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireadFlowSchema
     */
    pretty?: string
}

export interface FlowcontrolApiserverV1beta1ApiReadFlowSchemaStatusRequest {
    /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireadFlowSchemaStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireadFlowSchemaStatus
     */
    pretty?: string
}

export interface FlowcontrolApiserverV1beta1ApiReadPriorityLevelConfigurationRequest {
    /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireadPriorityLevelConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireadPriorityLevelConfiguration
     */
    pretty?: string
}

export interface FlowcontrolApiserverV1beta1ApiReadPriorityLevelConfigurationStatusRequest {
    /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireadPriorityLevelConfigurationStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireadPriorityLevelConfigurationStatus
     */
    pretty?: string
}

export interface FlowcontrolApiserverV1beta1ApiReplaceFlowSchemaRequest {
    /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplaceFlowSchema
     */
    name: string
    /**
     * 
     * @type V1beta1FlowSchema
     * @memberof FlowcontrolApiserverV1beta1ApireplaceFlowSchema
     */
    body: V1beta1FlowSchema
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplaceFlowSchema
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplaceFlowSchema
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplaceFlowSchema
     */
    fieldManager?: string
}

export interface FlowcontrolApiserverV1beta1ApiReplaceFlowSchemaStatusRequest {
    /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplaceFlowSchemaStatus
     */
    name: string
    /**
     * 
     * @type V1beta1FlowSchema
     * @memberof FlowcontrolApiserverV1beta1ApireplaceFlowSchemaStatus
     */
    body: V1beta1FlowSchema
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplaceFlowSchemaStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplaceFlowSchemaStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplaceFlowSchemaStatus
     */
    fieldManager?: string
}

export interface FlowcontrolApiserverV1beta1ApiReplacePriorityLevelConfigurationRequest {
    /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplacePriorityLevelConfiguration
     */
    name: string
    /**
     * 
     * @type V1beta1PriorityLevelConfiguration
     * @memberof FlowcontrolApiserverV1beta1ApireplacePriorityLevelConfiguration
     */
    body: V1beta1PriorityLevelConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplacePriorityLevelConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplacePriorityLevelConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplacePriorityLevelConfiguration
     */
    fieldManager?: string
}

export interface FlowcontrolApiserverV1beta1ApiReplacePriorityLevelConfigurationStatusRequest {
    /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplacePriorityLevelConfigurationStatus
     */
    name: string
    /**
     * 
     * @type V1beta1PriorityLevelConfiguration
     * @memberof FlowcontrolApiserverV1beta1ApireplacePriorityLevelConfigurationStatus
     */
    body: V1beta1PriorityLevelConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplacePriorityLevelConfigurationStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplacePriorityLevelConfigurationStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1beta1ApireplacePriorityLevelConfigurationStatus
     */
    fieldManager?: string
}

export class ObjectFlowcontrolApiserverV1beta1Api {
    private api: ObservableFlowcontrolApiserverV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: FlowcontrolApiserverV1beta1ApiRequestFactory, responseProcessor?: FlowcontrolApiserverV1beta1ApiResponseProcessor) {
        this.api = new ObservableFlowcontrolApiserverV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a FlowSchema
     * @param param the request object
     */
    public createFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiCreateFlowSchemaRequest, options?: Configuration): Promise<HttpInfo<V1beta1FlowSchema>> {
        return this.api.createFlowSchemaWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a FlowSchema
     * @param param the request object
     */
    public createFlowSchema(param: FlowcontrolApiserverV1beta1ApiCreateFlowSchemaRequest, options?: Configuration): Promise<V1beta1FlowSchema> {
        return this.api.createFlowSchema(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PriorityLevelConfiguration
     * @param param the request object
     */
    public createPriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiCreatePriorityLevelConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1beta1PriorityLevelConfiguration>> {
        return this.api.createPriorityLevelConfigurationWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PriorityLevelConfiguration
     * @param param the request object
     */
    public createPriorityLevelConfiguration(param: FlowcontrolApiserverV1beta1ApiCreatePriorityLevelConfigurationRequest, options?: Configuration): Promise<V1beta1PriorityLevelConfiguration> {
        return this.api.createPriorityLevelConfiguration(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of FlowSchema
     * @param param the request object
     */
    public deleteCollectionFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiDeleteCollectionFlowSchemaRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionFlowSchemaWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of FlowSchema
     * @param param the request object
     */
    public deleteCollectionFlowSchema(param: FlowcontrolApiserverV1beta1ApiDeleteCollectionFlowSchemaRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionFlowSchema(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PriorityLevelConfiguration
     * @param param the request object
     */
    public deleteCollectionPriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiDeleteCollectionPriorityLevelConfigurationRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionPriorityLevelConfigurationWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PriorityLevelConfiguration
     * @param param the request object
     */
    public deleteCollectionPriorityLevelConfiguration(param: FlowcontrolApiserverV1beta1ApiDeleteCollectionPriorityLevelConfigurationRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionPriorityLevelConfiguration(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a FlowSchema
     * @param param the request object
     */
    public deleteFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiDeleteFlowSchemaRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteFlowSchemaWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a FlowSchema
     * @param param the request object
     */
    public deleteFlowSchema(param: FlowcontrolApiserverV1beta1ApiDeleteFlowSchemaRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteFlowSchema(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PriorityLevelConfiguration
     * @param param the request object
     */
    public deletePriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiDeletePriorityLevelConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deletePriorityLevelConfigurationWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PriorityLevelConfiguration
     * @param param the request object
     */
    public deletePriorityLevelConfiguration(param: FlowcontrolApiserverV1beta1ApiDeletePriorityLevelConfigurationRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deletePriorityLevelConfiguration(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: FlowcontrolApiserverV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind FlowSchema
     * @param param the request object
     */
    public listFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiListFlowSchemaRequest = {}, options?: Configuration): Promise<HttpInfo<V1beta1FlowSchemaList>> {
        return this.api.listFlowSchemaWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind FlowSchema
     * @param param the request object
     */
    public listFlowSchema(param: FlowcontrolApiserverV1beta1ApiListFlowSchemaRequest = {}, options?: Configuration): Promise<V1beta1FlowSchemaList> {
        return this.api.listFlowSchema(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PriorityLevelConfiguration
     * @param param the request object
     */
    public listPriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiListPriorityLevelConfigurationRequest = {}, options?: Configuration): Promise<HttpInfo<V1beta1PriorityLevelConfigurationList>> {
        return this.api.listPriorityLevelConfigurationWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PriorityLevelConfiguration
     * @param param the request object
     */
    public listPriorityLevelConfiguration(param: FlowcontrolApiserverV1beta1ApiListPriorityLevelConfigurationRequest = {}, options?: Configuration): Promise<V1beta1PriorityLevelConfigurationList> {
        return this.api.listPriorityLevelConfiguration(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified FlowSchema
     * @param param the request object
     */
    public patchFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiPatchFlowSchemaRequest, options?: Configuration): Promise<HttpInfo<V1beta1FlowSchema>> {
        return this.api.patchFlowSchemaWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified FlowSchema
     * @param param the request object
     */
    public patchFlowSchema(param: FlowcontrolApiserverV1beta1ApiPatchFlowSchemaRequest, options?: Configuration): Promise<V1beta1FlowSchema> {
        return this.api.patchFlowSchema(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified FlowSchema
     * @param param the request object
     */
    public patchFlowSchemaStatusWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiPatchFlowSchemaStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1FlowSchema>> {
        return this.api.patchFlowSchemaStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified FlowSchema
     * @param param the request object
     */
    public patchFlowSchemaStatus(param: FlowcontrolApiserverV1beta1ApiPatchFlowSchemaStatusRequest, options?: Configuration): Promise<V1beta1FlowSchema> {
        return this.api.patchFlowSchemaStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public patchPriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiPatchPriorityLevelConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1beta1PriorityLevelConfiguration>> {
        return this.api.patchPriorityLevelConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public patchPriorityLevelConfiguration(param: FlowcontrolApiserverV1beta1ApiPatchPriorityLevelConfigurationRequest, options?: Configuration): Promise<V1beta1PriorityLevelConfiguration> {
        return this.api.patchPriorityLevelConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public patchPriorityLevelConfigurationStatusWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiPatchPriorityLevelConfigurationStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1PriorityLevelConfiguration>> {
        return this.api.patchPriorityLevelConfigurationStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public patchPriorityLevelConfigurationStatus(param: FlowcontrolApiserverV1beta1ApiPatchPriorityLevelConfigurationStatusRequest, options?: Configuration): Promise<V1beta1PriorityLevelConfiguration> {
        return this.api.patchPriorityLevelConfigurationStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified FlowSchema
     * @param param the request object
     */
    public readFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiReadFlowSchemaRequest, options?: Configuration): Promise<HttpInfo<V1beta1FlowSchema>> {
        return this.api.readFlowSchemaWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified FlowSchema
     * @param param the request object
     */
    public readFlowSchema(param: FlowcontrolApiserverV1beta1ApiReadFlowSchemaRequest, options?: Configuration): Promise<V1beta1FlowSchema> {
        return this.api.readFlowSchema(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified FlowSchema
     * @param param the request object
     */
    public readFlowSchemaStatusWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiReadFlowSchemaStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1FlowSchema>> {
        return this.api.readFlowSchemaStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified FlowSchema
     * @param param the request object
     */
    public readFlowSchemaStatus(param: FlowcontrolApiserverV1beta1ApiReadFlowSchemaStatusRequest, options?: Configuration): Promise<V1beta1FlowSchema> {
        return this.api.readFlowSchemaStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public readPriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiReadPriorityLevelConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1beta1PriorityLevelConfiguration>> {
        return this.api.readPriorityLevelConfigurationWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public readPriorityLevelConfiguration(param: FlowcontrolApiserverV1beta1ApiReadPriorityLevelConfigurationRequest, options?: Configuration): Promise<V1beta1PriorityLevelConfiguration> {
        return this.api.readPriorityLevelConfiguration(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public readPriorityLevelConfigurationStatusWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiReadPriorityLevelConfigurationStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1PriorityLevelConfiguration>> {
        return this.api.readPriorityLevelConfigurationStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public readPriorityLevelConfigurationStatus(param: FlowcontrolApiserverV1beta1ApiReadPriorityLevelConfigurationStatusRequest, options?: Configuration): Promise<V1beta1PriorityLevelConfiguration> {
        return this.api.readPriorityLevelConfigurationStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified FlowSchema
     * @param param the request object
     */
    public replaceFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiReplaceFlowSchemaRequest, options?: Configuration): Promise<HttpInfo<V1beta1FlowSchema>> {
        return this.api.replaceFlowSchemaWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified FlowSchema
     * @param param the request object
     */
    public replaceFlowSchema(param: FlowcontrolApiserverV1beta1ApiReplaceFlowSchemaRequest, options?: Configuration): Promise<V1beta1FlowSchema> {
        return this.api.replaceFlowSchema(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified FlowSchema
     * @param param the request object
     */
    public replaceFlowSchemaStatusWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiReplaceFlowSchemaStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1FlowSchema>> {
        return this.api.replaceFlowSchemaStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified FlowSchema
     * @param param the request object
     */
    public replaceFlowSchemaStatus(param: FlowcontrolApiserverV1beta1ApiReplaceFlowSchemaStatusRequest, options?: Configuration): Promise<V1beta1FlowSchema> {
        return this.api.replaceFlowSchemaStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public replacePriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiReplacePriorityLevelConfigurationRequest, options?: Configuration): Promise<HttpInfo<V1beta1PriorityLevelConfiguration>> {
        return this.api.replacePriorityLevelConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public replacePriorityLevelConfiguration(param: FlowcontrolApiserverV1beta1ApiReplacePriorityLevelConfigurationRequest, options?: Configuration): Promise<V1beta1PriorityLevelConfiguration> {
        return this.api.replacePriorityLevelConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public replacePriorityLevelConfigurationStatusWithHttpInfo(param: FlowcontrolApiserverV1beta1ApiReplacePriorityLevelConfigurationStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1PriorityLevelConfiguration>> {
        return this.api.replacePriorityLevelConfigurationStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public replacePriorityLevelConfigurationStatus(param: FlowcontrolApiserverV1beta1ApiReplacePriorityLevelConfigurationStatusRequest, options?: Configuration): Promise<V1beta1PriorityLevelConfiguration> {
        return this.api.replacePriorityLevelConfigurationStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableInternalApiserverApi } from "./ObservableAPI";
import { InternalApiserverApiRequestFactory, InternalApiserverApiResponseProcessor} from "../apis/InternalApiserverApi";

export interface InternalApiserverApiGetAPIGroupRequest {
}

export class ObjectInternalApiserverApi {
    private api: ObservableInternalApiserverApi

    public constructor(configuration: Configuration, requestFactory?: InternalApiserverApiRequestFactory, responseProcessor?: InternalApiserverApiResponseProcessor) {
        this.api = new ObservableInternalApiserverApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: InternalApiserverApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: InternalApiserverApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableInternalApiserverV1alpha1Api } from "./ObservableAPI";
import { InternalApiserverV1alpha1ApiRequestFactory, InternalApiserverV1alpha1ApiResponseProcessor} from "../apis/InternalApiserverV1alpha1Api";

export interface InternalApiserverV1alpha1ApiCreateStorageVersionRequest {
    /**
     * 
     * @type V1alpha1StorageVersion
     * @memberof InternalApiserverV1alpha1ApicreateStorageVersion
     */
    body: V1alpha1StorageVersion
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof InternalApiserverV1alpha1ApicreateStorageVersion
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof InternalApiserverV1alpha1ApicreateStorageVersion
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof InternalApiserverV1alpha1ApicreateStorageVersion
     */
    fieldManager?: string
}

export interface InternalApiserverV1alpha1ApiDeleteCollectionStorageVersionRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    body?: V1DeleteOptions
}

export interface InternalApiserverV1alpha1ApiDeleteStorageVersionRequest {
    /**
     * name of the StorageVersion
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    body?: V1DeleteOptions
}

export interface InternalApiserverV1alpha1ApiGetAPIResourcesRequest {
}

export interface InternalApiserverV1alpha1ApiListStorageVersionRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    watch?: boolean
}

export interface InternalApiserverV1alpha1ApiPatchStorageVersionRequest {
    /**
     * name of the StorageVersion
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    name: string
    /**
     * 
     * @type any
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    force?: boolean
}

export interface InternalApiserverV1alpha1ApiPatchStorageVersionStatusRequest {
    /**
     * name of the StorageVersion
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    force?: boolean
}

export interface InternalApiserverV1alpha1ApiReadStorageVersionRequest {
    /**
     * name of the StorageVersion
     * @type string
     * @memberof InternalApiserverV1alpha1ApireadStorageVersion
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof InternalApiserverV1alpha1ApireadStorageVersion
     */
    pretty?: string
}

export interface InternalApiserverV1alpha1ApiReadStorageVersionStatusRequest {
    /**
     * name of the StorageVersion
     * @type string
     * @memberof InternalApiserverV1alpha1ApireadStorageVersionStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof InternalApiserverV1alpha1ApireadStorageVersionStatus
     */
    pretty?: string
}

export interface InternalApiserverV1alpha1ApiReplaceStorageVersionRequest {
    /**
     * name of the StorageVersion
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersion
     */
    name: string
    /**
     * 
     * @type V1alpha1StorageVersion
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersion
     */
    body: V1alpha1StorageVersion
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersion
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersion
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersion
     */
    fieldManager?: string
}

export interface InternalApiserverV1alpha1ApiReplaceStorageVersionStatusRequest {
    /**
     * name of the StorageVersion
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersionStatus
     */
    name: string
    /**
     * 
     * @type V1alpha1StorageVersion
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersionStatus
     */
    body: V1alpha1StorageVersion
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersionStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersionStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersionStatus
     */
    fieldManager?: string
}

export class ObjectInternalApiserverV1alpha1Api {
    private api: ObservableInternalApiserverV1alpha1Api

    public constructor(configuration: Configuration, requestFactory?: InternalApiserverV1alpha1ApiRequestFactory, responseProcessor?: InternalApiserverV1alpha1ApiResponseProcessor) {
        this.api = new ObservableInternalApiserverV1alpha1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a StorageVersion
     * @param param the request object
     */
    public createStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiCreateStorageVersionRequest, options?: Configuration): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.createStorageVersionWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a StorageVersion
     * @param param the request object
     */
    public createStorageVersion(param: InternalApiserverV1alpha1ApiCreateStorageVersionRequest, options?: Configuration): Promise<V1alpha1StorageVersion> {
        return this.api.createStorageVersion(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of StorageVersion
     * @param param the request object
     */
    public deleteCollectionStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiDeleteCollectionStorageVersionRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionStorageVersionWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of StorageVersion
     * @param param the request object
     */
    public deleteCollectionStorageVersion(param: InternalApiserverV1alpha1ApiDeleteCollectionStorageVersionRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionStorageVersion(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a StorageVersion
     * @param param the request object
     */
    public deleteStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiDeleteStorageVersionRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteStorageVersionWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a StorageVersion
     * @param param the request object
     */
    public deleteStorageVersion(param: InternalApiserverV1alpha1ApiDeleteStorageVersionRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteStorageVersion(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: InternalApiserverV1alpha1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: InternalApiserverV1alpha1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind StorageVersion
     * @param param the request object
     */
    public listStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiListStorageVersionRequest = {}, options?: Configuration): Promise<HttpInfo<V1alpha1StorageVersionList>> {
        return this.api.listStorageVersionWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StorageVersion
     * @param param the request object
     */
    public listStorageVersion(param: InternalApiserverV1alpha1ApiListStorageVersionRequest = {}, options?: Configuration): Promise<V1alpha1StorageVersionList> {
        return this.api.listStorageVersion(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified StorageVersion
     * @param param the request object
     */
    public patchStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiPatchStorageVersionRequest, options?: Configuration): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.patchStorageVersionWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified StorageVersion
     * @param param the request object
     */
    public patchStorageVersion(param: InternalApiserverV1alpha1ApiPatchStorageVersionRequest, options?: Configuration): Promise<V1alpha1StorageVersion> {
        return this.api.patchStorageVersion(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified StorageVersion
     * @param param the request object
     */
    public patchStorageVersionStatusWithHttpInfo(param: InternalApiserverV1alpha1ApiPatchStorageVersionStatusRequest, options?: Configuration): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.patchStorageVersionStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified StorageVersion
     * @param param the request object
     */
    public patchStorageVersionStatus(param: InternalApiserverV1alpha1ApiPatchStorageVersionStatusRequest, options?: Configuration): Promise<V1alpha1StorageVersion> {
        return this.api.patchStorageVersionStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified StorageVersion
     * @param param the request object
     */
    public readStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiReadStorageVersionRequest, options?: Configuration): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.readStorageVersionWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified StorageVersion
     * @param param the request object
     */
    public readStorageVersion(param: InternalApiserverV1alpha1ApiReadStorageVersionRequest, options?: Configuration): Promise<V1alpha1StorageVersion> {
        return this.api.readStorageVersion(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified StorageVersion
     * @param param the request object
     */
    public readStorageVersionStatusWithHttpInfo(param: InternalApiserverV1alpha1ApiReadStorageVersionStatusRequest, options?: Configuration): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.readStorageVersionStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified StorageVersion
     * @param param the request object
     */
    public readStorageVersionStatus(param: InternalApiserverV1alpha1ApiReadStorageVersionStatusRequest, options?: Configuration): Promise<V1alpha1StorageVersion> {
        return this.api.readStorageVersionStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified StorageVersion
     * @param param the request object
     */
    public replaceStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiReplaceStorageVersionRequest, options?: Configuration): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.replaceStorageVersionWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified StorageVersion
     * @param param the request object
     */
    public replaceStorageVersion(param: InternalApiserverV1alpha1ApiReplaceStorageVersionRequest, options?: Configuration): Promise<V1alpha1StorageVersion> {
        return this.api.replaceStorageVersion(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified StorageVersion
     * @param param the request object
     */
    public replaceStorageVersionStatusWithHttpInfo(param: InternalApiserverV1alpha1ApiReplaceStorageVersionStatusRequest, options?: Configuration): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.replaceStorageVersionStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified StorageVersion
     * @param param the request object
     */
    public replaceStorageVersionStatus(param: InternalApiserverV1alpha1ApiReplaceStorageVersionStatusRequest, options?: Configuration): Promise<V1alpha1StorageVersion> {
        return this.api.replaceStorageVersionStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableLogsApi } from "./ObservableAPI";
import { LogsApiRequestFactory, LogsApiResponseProcessor} from "../apis/LogsApi";

export interface LogsApiLogFileHandlerRequest {
    /**
     * path to the log
     * @type string
     * @memberof LogsApilogFileHandler
     */
    logpath: string
}

export interface LogsApiLogFileListHandlerRequest {
}

export class ObjectLogsApi {
    private api: ObservableLogsApi

    public constructor(configuration: Configuration, requestFactory?: LogsApiRequestFactory, responseProcessor?: LogsApiResponseProcessor) {
        this.api = new ObservableLogsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param param the request object
     */
    public logFileHandlerWithHttpInfo(param: LogsApiLogFileHandlerRequest, options?: Configuration): Promise<HttpInfo<void>> {
        return this.api.logFileHandlerWithHttpInfo(param.logpath,  options).toPromise();
    }

    /**
     * @param param the request object
     */
    public logFileHandler(param: LogsApiLogFileHandlerRequest, options?: Configuration): Promise<void> {
        return this.api.logFileHandler(param.logpath,  options).toPromise();
    }

    /**
     * @param param the request object
     */
    public logFileListHandlerWithHttpInfo(param: LogsApiLogFileListHandlerRequest = {}, options?: Configuration): Promise<HttpInfo<void>> {
        return this.api.logFileListHandlerWithHttpInfo( options).toPromise();
    }

    /**
     * @param param the request object
     */
    public logFileListHandler(param: LogsApiLogFileListHandlerRequest = {}, options?: Configuration): Promise<void> {
        return this.api.logFileListHandler( options).toPromise();
    }

}

import { ObservableNetworkingApi } from "./ObservableAPI";
import { NetworkingApiRequestFactory, NetworkingApiResponseProcessor} from "../apis/NetworkingApi";

export interface NetworkingApiGetAPIGroupRequest {
}

export class ObjectNetworkingApi {
    private api: ObservableNetworkingApi

    public constructor(configuration: Configuration, requestFactory?: NetworkingApiRequestFactory, responseProcessor?: NetworkingApiResponseProcessor) {
        this.api = new ObservableNetworkingApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: NetworkingApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: NetworkingApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableNetworkingV1Api } from "./ObservableAPI";
import { NetworkingV1ApiRequestFactory, NetworkingV1ApiResponseProcessor} from "../apis/NetworkingV1Api";

export interface NetworkingV1ApiCreateIngressClassRequest {
    /**
     * 
     * @type V1IngressClass
     * @memberof NetworkingV1ApicreateIngressClass
     */
    body: V1IngressClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApicreateIngressClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApicreateIngressClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApicreateIngressClass
     */
    fieldManager?: string
}

export interface NetworkingV1ApiCreateNamespacedIngressRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedIngress
     */
    namespace: string
    /**
     * 
     * @type V1Ingress
     * @memberof NetworkingV1ApicreateNamespacedIngress
     */
    body: V1Ingress
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedIngress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedIngress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedIngress
     */
    fieldManager?: string
}

export interface NetworkingV1ApiCreateNamespacedNetworkPolicyRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * 
     * @type V1NetworkPolicy
     * @memberof NetworkingV1ApicreateNamespacedNetworkPolicy
     */
    body: V1NetworkPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedNetworkPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedNetworkPolicy
     */
    fieldManager?: string
}

export interface NetworkingV1ApiDeleteCollectionIngressClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteCollectionNamespacedIngressRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteCollectionNamespacedNetworkPolicyRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteIngressClassRequest {
    /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1ApideleteIngressClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteIngressClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteIngressClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteIngressClass
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteIngressClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteIngressClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteIngressClass
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteNamespacedIngressRequest {
    /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteNamespacedNetworkPolicyRequest {
    /**
     * name of the NetworkPolicy
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiGetAPIResourcesRequest {
}

export interface NetworkingV1ApiListIngressClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApilistIngressClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApilistIngressClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApilistIngressClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApilistIngressClass
     */
    watch?: boolean
}

export interface NetworkingV1ApiListIngressForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    watch?: boolean
}

export interface NetworkingV1ApiListNamespacedIngressRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    watch?: boolean
}

export interface NetworkingV1ApiListNamespacedNetworkPolicyRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    watch?: boolean
}

export interface NetworkingV1ApiListNetworkPolicyForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    watch?: boolean
}

export interface NetworkingV1ApiPatchIngressClassRequest {
    /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1ApipatchIngressClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchIngressClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApipatchIngressClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApipatchIngressClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NetworkingV1ApipatchIngressClass
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NetworkingV1ApipatchIngressClass
     */
    force?: boolean
}

export interface NetworkingV1ApiPatchNamespacedIngressRequest {
    /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    force?: boolean
}

export interface NetworkingV1ApiPatchNamespacedIngressStatusRequest {
    /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    force?: boolean
}

export interface NetworkingV1ApiPatchNamespacedNetworkPolicyRequest {
    /**
     * name of the NetworkPolicy
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    force?: boolean
}

export interface NetworkingV1ApiReadIngressClassRequest {
    /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1ApireadIngressClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireadIngressClass
     */
    pretty?: string
}

export interface NetworkingV1ApiReadNamespacedIngressRequest {
    /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngress
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngress
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngress
     */
    pretty?: string
}

export interface NetworkingV1ApiReadNamespacedIngressStatusRequest {
    /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngressStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngressStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngressStatus
     */
    pretty?: string
}

export interface NetworkingV1ApiReadNamespacedNetworkPolicyRequest {
    /**
     * name of the NetworkPolicy
     * @type string
     * @memberof NetworkingV1ApireadNamespacedNetworkPolicy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireadNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireadNamespacedNetworkPolicy
     */
    pretty?: string
}

export interface NetworkingV1ApiReplaceIngressClassRequest {
    /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1ApireplaceIngressClass
     */
    name: string
    /**
     * 
     * @type V1IngressClass
     * @memberof NetworkingV1ApireplaceIngressClass
     */
    body: V1IngressClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireplaceIngressClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApireplaceIngressClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApireplaceIngressClass
     */
    fieldManager?: string
}

export interface NetworkingV1ApiReplaceNamespacedIngressRequest {
    /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    namespace: string
    /**
     * 
     * @type V1Ingress
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    body: V1Ingress
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    fieldManager?: string
}

export interface NetworkingV1ApiReplaceNamespacedIngressStatusRequest {
    /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    namespace: string
    /**
     * 
     * @type V1Ingress
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    body: V1Ingress
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    fieldManager?: string
}

export interface NetworkingV1ApiReplaceNamespacedNetworkPolicyRequest {
    /**
     * name of the NetworkPolicy
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * 
     * @type V1NetworkPolicy
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    body: V1NetworkPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    fieldManager?: string
}

export class ObjectNetworkingV1Api {
    private api: ObservableNetworkingV1Api

    public constructor(configuration: Configuration, requestFactory?: NetworkingV1ApiRequestFactory, responseProcessor?: NetworkingV1ApiResponseProcessor) {
        this.api = new ObservableNetworkingV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create an IngressClass
     * @param param the request object
     */
    public createIngressClassWithHttpInfo(param: NetworkingV1ApiCreateIngressClassRequest, options?: Configuration): Promise<HttpInfo<V1IngressClass>> {
        return this.api.createIngressClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create an IngressClass
     * @param param the request object
     */
    public createIngressClass(param: NetworkingV1ApiCreateIngressClassRequest, options?: Configuration): Promise<V1IngressClass> {
        return this.api.createIngressClass(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create an Ingress
     * @param param the request object
     */
    public createNamespacedIngressWithHttpInfo(param: NetworkingV1ApiCreateNamespacedIngressRequest, options?: Configuration): Promise<HttpInfo<V1Ingress>> {
        return this.api.createNamespacedIngressWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create an Ingress
     * @param param the request object
     */
    public createNamespacedIngress(param: NetworkingV1ApiCreateNamespacedIngressRequest, options?: Configuration): Promise<V1Ingress> {
        return this.api.createNamespacedIngress(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a NetworkPolicy
     * @param param the request object
     */
    public createNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiCreateNamespacedNetworkPolicyRequest, options?: Configuration): Promise<HttpInfo<V1NetworkPolicy>> {
        return this.api.createNamespacedNetworkPolicyWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a NetworkPolicy
     * @param param the request object
     */
    public createNamespacedNetworkPolicy(param: NetworkingV1ApiCreateNamespacedNetworkPolicyRequest, options?: Configuration): Promise<V1NetworkPolicy> {
        return this.api.createNamespacedNetworkPolicy(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of IngressClass
     * @param param the request object
     */
    public deleteCollectionIngressClassWithHttpInfo(param: NetworkingV1ApiDeleteCollectionIngressClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionIngressClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of IngressClass
     * @param param the request object
     */
    public deleteCollectionIngressClass(param: NetworkingV1ApiDeleteCollectionIngressClassRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionIngressClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Ingress
     * @param param the request object
     */
    public deleteCollectionNamespacedIngressWithHttpInfo(param: NetworkingV1ApiDeleteCollectionNamespacedIngressRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedIngressWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Ingress
     * @param param the request object
     */
    public deleteCollectionNamespacedIngress(param: NetworkingV1ApiDeleteCollectionNamespacedIngressRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedIngress(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of NetworkPolicy
     * @param param the request object
     */
    public deleteCollectionNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiDeleteCollectionNamespacedNetworkPolicyRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedNetworkPolicyWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of NetworkPolicy
     * @param param the request object
     */
    public deleteCollectionNamespacedNetworkPolicy(param: NetworkingV1ApiDeleteCollectionNamespacedNetworkPolicyRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedNetworkPolicy(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete an IngressClass
     * @param param the request object
     */
    public deleteIngressClassWithHttpInfo(param: NetworkingV1ApiDeleteIngressClassRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteIngressClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an IngressClass
     * @param param the request object
     */
    public deleteIngressClass(param: NetworkingV1ApiDeleteIngressClassRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteIngressClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an Ingress
     * @param param the request object
     */
    public deleteNamespacedIngressWithHttpInfo(param: NetworkingV1ApiDeleteNamespacedIngressRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedIngressWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an Ingress
     * @param param the request object
     */
    public deleteNamespacedIngress(param: NetworkingV1ApiDeleteNamespacedIngressRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedIngress(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a NetworkPolicy
     * @param param the request object
     */
    public deleteNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiDeleteNamespacedNetworkPolicyRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedNetworkPolicyWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a NetworkPolicy
     * @param param the request object
     */
    public deleteNamespacedNetworkPolicy(param: NetworkingV1ApiDeleteNamespacedNetworkPolicyRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedNetworkPolicy(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: NetworkingV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: NetworkingV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind IngressClass
     * @param param the request object
     */
    public listIngressClassWithHttpInfo(param: NetworkingV1ApiListIngressClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1IngressClassList>> {
        return this.api.listIngressClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind IngressClass
     * @param param the request object
     */
    public listIngressClass(param: NetworkingV1ApiListIngressClassRequest = {}, options?: Configuration): Promise<V1IngressClassList> {
        return this.api.listIngressClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
    public listIngressForAllNamespacesWithHttpInfo(param: NetworkingV1ApiListIngressForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1IngressList>> {
        return this.api.listIngressForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
    public listIngressForAllNamespaces(param: NetworkingV1ApiListIngressForAllNamespacesRequest = {}, options?: Configuration): Promise<V1IngressList> {
        return this.api.listIngressForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
    public listNamespacedIngressWithHttpInfo(param: NetworkingV1ApiListNamespacedIngressRequest, options?: Configuration): Promise<HttpInfo<V1IngressList>> {
        return this.api.listNamespacedIngressWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
    public listNamespacedIngress(param: NetworkingV1ApiListNamespacedIngressRequest, options?: Configuration): Promise<V1IngressList> {
        return this.api.listNamespacedIngress(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind NetworkPolicy
     * @param param the request object
     */
    public listNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiListNamespacedNetworkPolicyRequest, options?: Configuration): Promise<HttpInfo<V1NetworkPolicyList>> {
        return this.api.listNamespacedNetworkPolicyWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind NetworkPolicy
     * @param param the request object
     */
    public listNamespacedNetworkPolicy(param: NetworkingV1ApiListNamespacedNetworkPolicyRequest, options?: Configuration): Promise<V1NetworkPolicyList> {
        return this.api.listNamespacedNetworkPolicy(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind NetworkPolicy
     * @param param the request object
     */
    public listNetworkPolicyForAllNamespacesWithHttpInfo(param: NetworkingV1ApiListNetworkPolicyForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1NetworkPolicyList>> {
        return this.api.listNetworkPolicyForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind NetworkPolicy
     * @param param the request object
     */
    public listNetworkPolicyForAllNamespaces(param: NetworkingV1ApiListNetworkPolicyForAllNamespacesRequest = {}, options?: Configuration): Promise<V1NetworkPolicyList> {
        return this.api.listNetworkPolicyForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified IngressClass
     * @param param the request object
     */
    public patchIngressClassWithHttpInfo(param: NetworkingV1ApiPatchIngressClassRequest, options?: Configuration): Promise<HttpInfo<V1IngressClass>> {
        return this.api.patchIngressClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified IngressClass
     * @param param the request object
     */
    public patchIngressClass(param: NetworkingV1ApiPatchIngressClassRequest, options?: Configuration): Promise<V1IngressClass> {
        return this.api.patchIngressClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Ingress
     * @param param the request object
     */
    public patchNamespacedIngressWithHttpInfo(param: NetworkingV1ApiPatchNamespacedIngressRequest, options?: Configuration): Promise<HttpInfo<V1Ingress>> {
        return this.api.patchNamespacedIngressWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Ingress
     * @param param the request object
     */
    public patchNamespacedIngress(param: NetworkingV1ApiPatchNamespacedIngressRequest, options?: Configuration): Promise<V1Ingress> {
        return this.api.patchNamespacedIngress(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Ingress
     * @param param the request object
     */
    public patchNamespacedIngressStatusWithHttpInfo(param: NetworkingV1ApiPatchNamespacedIngressStatusRequest, options?: Configuration): Promise<HttpInfo<V1Ingress>> {
        return this.api.patchNamespacedIngressStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Ingress
     * @param param the request object
     */
    public patchNamespacedIngressStatus(param: NetworkingV1ApiPatchNamespacedIngressStatusRequest, options?: Configuration): Promise<V1Ingress> {
        return this.api.patchNamespacedIngressStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified NetworkPolicy
     * @param param the request object
     */
    public patchNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiPatchNamespacedNetworkPolicyRequest, options?: Configuration): Promise<HttpInfo<V1NetworkPolicy>> {
        return this.api.patchNamespacedNetworkPolicyWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified NetworkPolicy
     * @param param the request object
     */
    public patchNamespacedNetworkPolicy(param: NetworkingV1ApiPatchNamespacedNetworkPolicyRequest, options?: Configuration): Promise<V1NetworkPolicy> {
        return this.api.patchNamespacedNetworkPolicy(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified IngressClass
     * @param param the request object
     */
    public readIngressClassWithHttpInfo(param: NetworkingV1ApiReadIngressClassRequest, options?: Configuration): Promise<HttpInfo<V1IngressClass>> {
        return this.api.readIngressClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified IngressClass
     * @param param the request object
     */
    public readIngressClass(param: NetworkingV1ApiReadIngressClassRequest, options?: Configuration): Promise<V1IngressClass> {
        return this.api.readIngressClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Ingress
     * @param param the request object
     */
    public readNamespacedIngressWithHttpInfo(param: NetworkingV1ApiReadNamespacedIngressRequest, options?: Configuration): Promise<HttpInfo<V1Ingress>> {
        return this.api.readNamespacedIngressWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Ingress
     * @param param the request object
     */
    public readNamespacedIngress(param: NetworkingV1ApiReadNamespacedIngressRequest, options?: Configuration): Promise<V1Ingress> {
        return this.api.readNamespacedIngress(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Ingress
     * @param param the request object
     */
    public readNamespacedIngressStatusWithHttpInfo(param: NetworkingV1ApiReadNamespacedIngressStatusRequest, options?: Configuration): Promise<HttpInfo<V1Ingress>> {
        return this.api.readNamespacedIngressStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Ingress
     * @param param the request object
     */
    public readNamespacedIngressStatus(param: NetworkingV1ApiReadNamespacedIngressStatusRequest, options?: Configuration): Promise<V1Ingress> {
        return this.api.readNamespacedIngressStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified NetworkPolicy
     * @param param the request object
     */
    public readNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiReadNamespacedNetworkPolicyRequest, options?: Configuration): Promise<HttpInfo<V1NetworkPolicy>> {
        return this.api.readNamespacedNetworkPolicyWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified NetworkPolicy
     * @param param the request object
     */
    public readNamespacedNetworkPolicy(param: NetworkingV1ApiReadNamespacedNetworkPolicyRequest, options?: Configuration): Promise<V1NetworkPolicy> {
        return this.api.readNamespacedNetworkPolicy(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified IngressClass
     * @param param the request object
     */
    public replaceIngressClassWithHttpInfo(param: NetworkingV1ApiReplaceIngressClassRequest, options?: Configuration): Promise<HttpInfo<V1IngressClass>> {
        return this.api.replaceIngressClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified IngressClass
     * @param param the request object
     */
    public replaceIngressClass(param: NetworkingV1ApiReplaceIngressClassRequest, options?: Configuration): Promise<V1IngressClass> {
        return this.api.replaceIngressClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Ingress
     * @param param the request object
     */
    public replaceNamespacedIngressWithHttpInfo(param: NetworkingV1ApiReplaceNamespacedIngressRequest, options?: Configuration): Promise<HttpInfo<V1Ingress>> {
        return this.api.replaceNamespacedIngressWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Ingress
     * @param param the request object
     */
    public replaceNamespacedIngress(param: NetworkingV1ApiReplaceNamespacedIngressRequest, options?: Configuration): Promise<V1Ingress> {
        return this.api.replaceNamespacedIngress(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Ingress
     * @param param the request object
     */
    public replaceNamespacedIngressStatusWithHttpInfo(param: NetworkingV1ApiReplaceNamespacedIngressStatusRequest, options?: Configuration): Promise<HttpInfo<V1Ingress>> {
        return this.api.replaceNamespacedIngressStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified Ingress
     * @param param the request object
     */
    public replaceNamespacedIngressStatus(param: NetworkingV1ApiReplaceNamespacedIngressStatusRequest, options?: Configuration): Promise<V1Ingress> {
        return this.api.replaceNamespacedIngressStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified NetworkPolicy
     * @param param the request object
     */
    public replaceNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiReplaceNamespacedNetworkPolicyRequest, options?: Configuration): Promise<HttpInfo<V1NetworkPolicy>> {
        return this.api.replaceNamespacedNetworkPolicyWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified NetworkPolicy
     * @param param the request object
     */
    public replaceNamespacedNetworkPolicy(param: NetworkingV1ApiReplaceNamespacedNetworkPolicyRequest, options?: Configuration): Promise<V1NetworkPolicy> {
        return this.api.replaceNamespacedNetworkPolicy(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableNodeApi } from "./ObservableAPI";
import { NodeApiRequestFactory, NodeApiResponseProcessor} from "../apis/NodeApi";

export interface NodeApiGetAPIGroupRequest {
}

export class ObjectNodeApi {
    private api: ObservableNodeApi

    public constructor(configuration: Configuration, requestFactory?: NodeApiRequestFactory, responseProcessor?: NodeApiResponseProcessor) {
        this.api = new ObservableNodeApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: NodeApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: NodeApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableNodeV1Api } from "./ObservableAPI";
import { NodeV1ApiRequestFactory, NodeV1ApiResponseProcessor} from "../apis/NodeV1Api";

export interface NodeV1ApiCreateRuntimeClassRequest {
    /**
     * 
     * @type V1RuntimeClass
     * @memberof NodeV1ApicreateRuntimeClass
     */
    body: V1RuntimeClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1ApicreateRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1ApicreateRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NodeV1ApicreateRuntimeClass
     */
    fieldManager?: string
}

export interface NodeV1ApiDeleteCollectionRuntimeClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    body?: V1DeleteOptions
}

export interface NodeV1ApiDeleteRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1ApideleteRuntimeClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1ApideleteRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1ApideleteRuntimeClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NodeV1ApideleteRuntimeClass
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NodeV1ApideleteRuntimeClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NodeV1ApideleteRuntimeClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NodeV1ApideleteRuntimeClass
     */
    body?: V1DeleteOptions
}

export interface NodeV1ApiGetAPIResourcesRequest {
}

export interface NodeV1ApiListRuntimeClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof NodeV1ApilistRuntimeClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1ApilistRuntimeClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1ApilistRuntimeClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NodeV1ApilistRuntimeClass
     */
    watch?: boolean
}

export interface NodeV1ApiPatchRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1ApipatchRuntimeClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NodeV1ApipatchRuntimeClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1ApipatchRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1ApipatchRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NodeV1ApipatchRuntimeClass
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NodeV1ApipatchRuntimeClass
     */
    force?: boolean
}

export interface NodeV1ApiReadRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1ApireadRuntimeClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1ApireadRuntimeClass
     */
    pretty?: string
}

export interface NodeV1ApiReplaceRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1ApireplaceRuntimeClass
     */
    name: string
    /**
     * 
     * @type V1RuntimeClass
     * @memberof NodeV1ApireplaceRuntimeClass
     */
    body: V1RuntimeClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1ApireplaceRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1ApireplaceRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NodeV1ApireplaceRuntimeClass
     */
    fieldManager?: string
}

export class ObjectNodeV1Api {
    private api: ObservableNodeV1Api

    public constructor(configuration: Configuration, requestFactory?: NodeV1ApiRequestFactory, responseProcessor?: NodeV1ApiResponseProcessor) {
        this.api = new ObservableNodeV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a RuntimeClass
     * @param param the request object
     */
    public createRuntimeClassWithHttpInfo(param: NodeV1ApiCreateRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1RuntimeClass>> {
        return this.api.createRuntimeClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a RuntimeClass
     * @param param the request object
     */
    public createRuntimeClass(param: NodeV1ApiCreateRuntimeClassRequest, options?: Configuration): Promise<V1RuntimeClass> {
        return this.api.createRuntimeClass(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of RuntimeClass
     * @param param the request object
     */
    public deleteCollectionRuntimeClassWithHttpInfo(param: NodeV1ApiDeleteCollectionRuntimeClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionRuntimeClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of RuntimeClass
     * @param param the request object
     */
    public deleteCollectionRuntimeClass(param: NodeV1ApiDeleteCollectionRuntimeClassRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionRuntimeClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a RuntimeClass
     * @param param the request object
     */
    public deleteRuntimeClassWithHttpInfo(param: NodeV1ApiDeleteRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteRuntimeClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a RuntimeClass
     * @param param the request object
     */
    public deleteRuntimeClass(param: NodeV1ApiDeleteRuntimeClassRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteRuntimeClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: NodeV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: NodeV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind RuntimeClass
     * @param param the request object
     */
    public listRuntimeClassWithHttpInfo(param: NodeV1ApiListRuntimeClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1RuntimeClassList>> {
        return this.api.listRuntimeClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RuntimeClass
     * @param param the request object
     */
    public listRuntimeClass(param: NodeV1ApiListRuntimeClassRequest = {}, options?: Configuration): Promise<V1RuntimeClassList> {
        return this.api.listRuntimeClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified RuntimeClass
     * @param param the request object
     */
    public patchRuntimeClassWithHttpInfo(param: NodeV1ApiPatchRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1RuntimeClass>> {
        return this.api.patchRuntimeClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified RuntimeClass
     * @param param the request object
     */
    public patchRuntimeClass(param: NodeV1ApiPatchRuntimeClassRequest, options?: Configuration): Promise<V1RuntimeClass> {
        return this.api.patchRuntimeClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified RuntimeClass
     * @param param the request object
     */
    public readRuntimeClassWithHttpInfo(param: NodeV1ApiReadRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1RuntimeClass>> {
        return this.api.readRuntimeClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified RuntimeClass
     * @param param the request object
     */
    public readRuntimeClass(param: NodeV1ApiReadRuntimeClassRequest, options?: Configuration): Promise<V1RuntimeClass> {
        return this.api.readRuntimeClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified RuntimeClass
     * @param param the request object
     */
    public replaceRuntimeClassWithHttpInfo(param: NodeV1ApiReplaceRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1RuntimeClass>> {
        return this.api.replaceRuntimeClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified RuntimeClass
     * @param param the request object
     */
    public replaceRuntimeClass(param: NodeV1ApiReplaceRuntimeClassRequest, options?: Configuration): Promise<V1RuntimeClass> {
        return this.api.replaceRuntimeClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableNodeV1alpha1Api } from "./ObservableAPI";
import { NodeV1alpha1ApiRequestFactory, NodeV1alpha1ApiResponseProcessor} from "../apis/NodeV1alpha1Api";

export interface NodeV1alpha1ApiCreateRuntimeClassRequest {
    /**
     * 
     * @type V1alpha1RuntimeClass
     * @memberof NodeV1alpha1ApicreateRuntimeClass
     */
    body: V1alpha1RuntimeClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApicreateRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1alpha1ApicreateRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NodeV1alpha1ApicreateRuntimeClass
     */
    fieldManager?: string
}

export interface NodeV1alpha1ApiDeleteCollectionRuntimeClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NodeV1alpha1ApideleteCollectionRuntimeClass
     */
    body?: V1DeleteOptions
}

export interface NodeV1alpha1ApiDeleteRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1alpha1ApideleteRuntimeClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApideleteRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1alpha1ApideleteRuntimeClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NodeV1alpha1ApideleteRuntimeClass
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NodeV1alpha1ApideleteRuntimeClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NodeV1alpha1ApideleteRuntimeClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NodeV1alpha1ApideleteRuntimeClass
     */
    body?: V1DeleteOptions
}

export interface NodeV1alpha1ApiGetAPIResourcesRequest {
}

export interface NodeV1alpha1ApiListRuntimeClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApilistRuntimeClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof NodeV1alpha1ApilistRuntimeClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1alpha1ApilistRuntimeClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApilistRuntimeClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApilistRuntimeClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1alpha1ApilistRuntimeClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApilistRuntimeClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApilistRuntimeClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1alpha1ApilistRuntimeClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NodeV1alpha1ApilistRuntimeClass
     */
    watch?: boolean
}

export interface NodeV1alpha1ApiPatchRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1alpha1ApipatchRuntimeClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NodeV1alpha1ApipatchRuntimeClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApipatchRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1alpha1ApipatchRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NodeV1alpha1ApipatchRuntimeClass
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NodeV1alpha1ApipatchRuntimeClass
     */
    force?: boolean
}

export interface NodeV1alpha1ApiReadRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1alpha1ApireadRuntimeClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApireadRuntimeClass
     */
    pretty?: string
}

export interface NodeV1alpha1ApiReplaceRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1alpha1ApireplaceRuntimeClass
     */
    name: string
    /**
     * 
     * @type V1alpha1RuntimeClass
     * @memberof NodeV1alpha1ApireplaceRuntimeClass
     */
    body: V1alpha1RuntimeClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApireplaceRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1alpha1ApireplaceRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NodeV1alpha1ApireplaceRuntimeClass
     */
    fieldManager?: string
}

export class ObjectNodeV1alpha1Api {
    private api: ObservableNodeV1alpha1Api

    public constructor(configuration: Configuration, requestFactory?: NodeV1alpha1ApiRequestFactory, responseProcessor?: NodeV1alpha1ApiResponseProcessor) {
        this.api = new ObservableNodeV1alpha1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a RuntimeClass
     * @param param the request object
     */
    public createRuntimeClassWithHttpInfo(param: NodeV1alpha1ApiCreateRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1alpha1RuntimeClass>> {
        return this.api.createRuntimeClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a RuntimeClass
     * @param param the request object
     */
    public createRuntimeClass(param: NodeV1alpha1ApiCreateRuntimeClassRequest, options?: Configuration): Promise<V1alpha1RuntimeClass> {
        return this.api.createRuntimeClass(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of RuntimeClass
     * @param param the request object
     */
    public deleteCollectionRuntimeClassWithHttpInfo(param: NodeV1alpha1ApiDeleteCollectionRuntimeClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionRuntimeClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of RuntimeClass
     * @param param the request object
     */
    public deleteCollectionRuntimeClass(param: NodeV1alpha1ApiDeleteCollectionRuntimeClassRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionRuntimeClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a RuntimeClass
     * @param param the request object
     */
    public deleteRuntimeClassWithHttpInfo(param: NodeV1alpha1ApiDeleteRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteRuntimeClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a RuntimeClass
     * @param param the request object
     */
    public deleteRuntimeClass(param: NodeV1alpha1ApiDeleteRuntimeClassRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteRuntimeClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: NodeV1alpha1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: NodeV1alpha1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind RuntimeClass
     * @param param the request object
     */
    public listRuntimeClassWithHttpInfo(param: NodeV1alpha1ApiListRuntimeClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1alpha1RuntimeClassList>> {
        return this.api.listRuntimeClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RuntimeClass
     * @param param the request object
     */
    public listRuntimeClass(param: NodeV1alpha1ApiListRuntimeClassRequest = {}, options?: Configuration): Promise<V1alpha1RuntimeClassList> {
        return this.api.listRuntimeClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified RuntimeClass
     * @param param the request object
     */
    public patchRuntimeClassWithHttpInfo(param: NodeV1alpha1ApiPatchRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1alpha1RuntimeClass>> {
        return this.api.patchRuntimeClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified RuntimeClass
     * @param param the request object
     */
    public patchRuntimeClass(param: NodeV1alpha1ApiPatchRuntimeClassRequest, options?: Configuration): Promise<V1alpha1RuntimeClass> {
        return this.api.patchRuntimeClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified RuntimeClass
     * @param param the request object
     */
    public readRuntimeClassWithHttpInfo(param: NodeV1alpha1ApiReadRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1alpha1RuntimeClass>> {
        return this.api.readRuntimeClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified RuntimeClass
     * @param param the request object
     */
    public readRuntimeClass(param: NodeV1alpha1ApiReadRuntimeClassRequest, options?: Configuration): Promise<V1alpha1RuntimeClass> {
        return this.api.readRuntimeClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified RuntimeClass
     * @param param the request object
     */
    public replaceRuntimeClassWithHttpInfo(param: NodeV1alpha1ApiReplaceRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1alpha1RuntimeClass>> {
        return this.api.replaceRuntimeClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified RuntimeClass
     * @param param the request object
     */
    public replaceRuntimeClass(param: NodeV1alpha1ApiReplaceRuntimeClassRequest, options?: Configuration): Promise<V1alpha1RuntimeClass> {
        return this.api.replaceRuntimeClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableNodeV1beta1Api } from "./ObservableAPI";
import { NodeV1beta1ApiRequestFactory, NodeV1beta1ApiResponseProcessor} from "../apis/NodeV1beta1Api";

export interface NodeV1beta1ApiCreateRuntimeClassRequest {
    /**
     * 
     * @type V1beta1RuntimeClass
     * @memberof NodeV1beta1ApicreateRuntimeClass
     */
    body: V1beta1RuntimeClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApicreateRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1beta1ApicreateRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NodeV1beta1ApicreateRuntimeClass
     */
    fieldManager?: string
}

export interface NodeV1beta1ApiDeleteCollectionRuntimeClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NodeV1beta1ApideleteCollectionRuntimeClass
     */
    body?: V1DeleteOptions
}

export interface NodeV1beta1ApiDeleteRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1beta1ApideleteRuntimeClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApideleteRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1beta1ApideleteRuntimeClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NodeV1beta1ApideleteRuntimeClass
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NodeV1beta1ApideleteRuntimeClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NodeV1beta1ApideleteRuntimeClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NodeV1beta1ApideleteRuntimeClass
     */
    body?: V1DeleteOptions
}

export interface NodeV1beta1ApiGetAPIResourcesRequest {
}

export interface NodeV1beta1ApiListRuntimeClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApilistRuntimeClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof NodeV1beta1ApilistRuntimeClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1beta1ApilistRuntimeClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApilistRuntimeClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApilistRuntimeClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1beta1ApilistRuntimeClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApilistRuntimeClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApilistRuntimeClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1beta1ApilistRuntimeClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NodeV1beta1ApilistRuntimeClass
     */
    watch?: boolean
}

export interface NodeV1beta1ApiPatchRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1beta1ApipatchRuntimeClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NodeV1beta1ApipatchRuntimeClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApipatchRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1beta1ApipatchRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NodeV1beta1ApipatchRuntimeClass
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NodeV1beta1ApipatchRuntimeClass
     */
    force?: boolean
}

export interface NodeV1beta1ApiReadRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1beta1ApireadRuntimeClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApireadRuntimeClass
     */
    pretty?: string
}

export interface NodeV1beta1ApiReplaceRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1beta1ApireplaceRuntimeClass
     */
    name: string
    /**
     * 
     * @type V1beta1RuntimeClass
     * @memberof NodeV1beta1ApireplaceRuntimeClass
     */
    body: V1beta1RuntimeClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApireplaceRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1beta1ApireplaceRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NodeV1beta1ApireplaceRuntimeClass
     */
    fieldManager?: string
}

export class ObjectNodeV1beta1Api {
    private api: ObservableNodeV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: NodeV1beta1ApiRequestFactory, responseProcessor?: NodeV1beta1ApiResponseProcessor) {
        this.api = new ObservableNodeV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a RuntimeClass
     * @param param the request object
     */
    public createRuntimeClassWithHttpInfo(param: NodeV1beta1ApiCreateRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1beta1RuntimeClass>> {
        return this.api.createRuntimeClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a RuntimeClass
     * @param param the request object
     */
    public createRuntimeClass(param: NodeV1beta1ApiCreateRuntimeClassRequest, options?: Configuration): Promise<V1beta1RuntimeClass> {
        return this.api.createRuntimeClass(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of RuntimeClass
     * @param param the request object
     */
    public deleteCollectionRuntimeClassWithHttpInfo(param: NodeV1beta1ApiDeleteCollectionRuntimeClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionRuntimeClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of RuntimeClass
     * @param param the request object
     */
    public deleteCollectionRuntimeClass(param: NodeV1beta1ApiDeleteCollectionRuntimeClassRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionRuntimeClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a RuntimeClass
     * @param param the request object
     */
    public deleteRuntimeClassWithHttpInfo(param: NodeV1beta1ApiDeleteRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteRuntimeClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a RuntimeClass
     * @param param the request object
     */
    public deleteRuntimeClass(param: NodeV1beta1ApiDeleteRuntimeClassRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteRuntimeClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: NodeV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: NodeV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind RuntimeClass
     * @param param the request object
     */
    public listRuntimeClassWithHttpInfo(param: NodeV1beta1ApiListRuntimeClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1beta1RuntimeClassList>> {
        return this.api.listRuntimeClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RuntimeClass
     * @param param the request object
     */
    public listRuntimeClass(param: NodeV1beta1ApiListRuntimeClassRequest = {}, options?: Configuration): Promise<V1beta1RuntimeClassList> {
        return this.api.listRuntimeClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified RuntimeClass
     * @param param the request object
     */
    public patchRuntimeClassWithHttpInfo(param: NodeV1beta1ApiPatchRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1beta1RuntimeClass>> {
        return this.api.patchRuntimeClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified RuntimeClass
     * @param param the request object
     */
    public patchRuntimeClass(param: NodeV1beta1ApiPatchRuntimeClassRequest, options?: Configuration): Promise<V1beta1RuntimeClass> {
        return this.api.patchRuntimeClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified RuntimeClass
     * @param param the request object
     */
    public readRuntimeClassWithHttpInfo(param: NodeV1beta1ApiReadRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1beta1RuntimeClass>> {
        return this.api.readRuntimeClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified RuntimeClass
     * @param param the request object
     */
    public readRuntimeClass(param: NodeV1beta1ApiReadRuntimeClassRequest, options?: Configuration): Promise<V1beta1RuntimeClass> {
        return this.api.readRuntimeClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified RuntimeClass
     * @param param the request object
     */
    public replaceRuntimeClassWithHttpInfo(param: NodeV1beta1ApiReplaceRuntimeClassRequest, options?: Configuration): Promise<HttpInfo<V1beta1RuntimeClass>> {
        return this.api.replaceRuntimeClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified RuntimeClass
     * @param param the request object
     */
    public replaceRuntimeClass(param: NodeV1beta1ApiReplaceRuntimeClassRequest, options?: Configuration): Promise<V1beta1RuntimeClass> {
        return this.api.replaceRuntimeClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableOpenidApi } from "./ObservableAPI";
import { OpenidApiRequestFactory, OpenidApiResponseProcessor} from "../apis/OpenidApi";

export interface OpenidApiGetServiceAccountIssuerOpenIDKeysetRequest {
}

export class ObjectOpenidApi {
    private api: ObservableOpenidApi

    public constructor(configuration: Configuration, requestFactory?: OpenidApiRequestFactory, responseProcessor?: OpenidApiResponseProcessor) {
        this.api = new ObservableOpenidApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get service account issuer OpenID JSON Web Key Set (contains public token verification keys)
     * @param param the request object
     */
    public getServiceAccountIssuerOpenIDKeysetWithHttpInfo(param: OpenidApiGetServiceAccountIssuerOpenIDKeysetRequest = {}, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.getServiceAccountIssuerOpenIDKeysetWithHttpInfo( options).toPromise();
    }

    /**
     * get service account issuer OpenID JSON Web Key Set (contains public token verification keys)
     * @param param the request object
     */
    public getServiceAccountIssuerOpenIDKeyset(param: OpenidApiGetServiceAccountIssuerOpenIDKeysetRequest = {}, options?: Configuration): Promise<string> {
        return this.api.getServiceAccountIssuerOpenIDKeyset( options).toPromise();
    }

}

import { ObservablePolicyApi } from "./ObservableAPI";
import { PolicyApiRequestFactory, PolicyApiResponseProcessor} from "../apis/PolicyApi";

export interface PolicyApiGetAPIGroupRequest {
}

export class ObjectPolicyApi {
    private api: ObservablePolicyApi

    public constructor(configuration: Configuration, requestFactory?: PolicyApiRequestFactory, responseProcessor?: PolicyApiResponseProcessor) {
        this.api = new ObservablePolicyApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: PolicyApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: PolicyApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservablePolicyV1Api } from "./ObservableAPI";
import { PolicyV1ApiRequestFactory, PolicyV1ApiResponseProcessor} from "../apis/PolicyV1Api";

export interface PolicyV1ApiCreateNamespacedPodDisruptionBudgetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1ApicreateNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * 
     * @type V1PodDisruptionBudget
     * @memberof PolicyV1ApicreateNamespacedPodDisruptionBudget
     */
    body: V1PodDisruptionBudget
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1ApicreateNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1ApicreateNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1ApicreateNamespacedPodDisruptionBudget
     */
    fieldManager?: string
}

export interface PolicyV1ApiDeleteCollectionNamespacedPodDisruptionBudgetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    body?: V1DeleteOptions
}

export interface PolicyV1ApiDeleteNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    body?: V1DeleteOptions
}

export interface PolicyV1ApiGetAPIResourcesRequest {
}

export interface PolicyV1ApiListNamespacedPodDisruptionBudgetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    watch?: boolean
}

export interface PolicyV1ApiListPodDisruptionBudgetForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    watch?: boolean
}

export interface PolicyV1ApiPatchNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    force?: boolean
}

export interface PolicyV1ApiPatchNamespacedPodDisruptionBudgetStatusRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    force?: boolean
}

export interface PolicyV1ApiReadNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudget
     */
    pretty?: string
}

export interface PolicyV1ApiReadNamespacedPodDisruptionBudgetStatusRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudgetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudgetStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudgetStatus
     */
    pretty?: string
}

export interface PolicyV1ApiReplaceNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * 
     * @type V1PodDisruptionBudget
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    body: V1PodDisruptionBudget
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    fieldManager?: string
}

export interface PolicyV1ApiReplaceNamespacedPodDisruptionBudgetStatusRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    namespace: string
    /**
     * 
     * @type V1PodDisruptionBudget
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    body: V1PodDisruptionBudget
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    fieldManager?: string
}

export class ObjectPolicyV1Api {
    private api: ObservablePolicyV1Api

    public constructor(configuration: Configuration, requestFactory?: PolicyV1ApiRequestFactory, responseProcessor?: PolicyV1ApiResponseProcessor) {
        this.api = new ObservablePolicyV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a PodDisruptionBudget
     * @param param the request object
     */
    public createNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiCreateNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.createNamespacedPodDisruptionBudgetWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PodDisruptionBudget
     * @param param the request object
     */
    public createNamespacedPodDisruptionBudget(param: PolicyV1ApiCreateNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1PodDisruptionBudget> {
        return this.api.createNamespacedPodDisruptionBudget(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of PodDisruptionBudget
     * @param param the request object
     */
    public deleteCollectionNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiDeleteCollectionNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedPodDisruptionBudgetWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PodDisruptionBudget
     * @param param the request object
     */
    public deleteCollectionNamespacedPodDisruptionBudget(param: PolicyV1ApiDeleteCollectionNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedPodDisruptionBudget(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a PodDisruptionBudget
     * @param param the request object
     */
    public deleteNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiDeleteNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PodDisruptionBudget
     * @param param the request object
     */
    public deleteNamespacedPodDisruptionBudget(param: PolicyV1ApiDeleteNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedPodDisruptionBudget(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: PolicyV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: PolicyV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiListNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1PodDisruptionBudgetList>> {
        return this.api.listNamespacedPodDisruptionBudgetWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listNamespacedPodDisruptionBudget(param: PolicyV1ApiListNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1PodDisruptionBudgetList> {
        return this.api.listNamespacedPodDisruptionBudget(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listPodDisruptionBudgetForAllNamespacesWithHttpInfo(param: PolicyV1ApiListPodDisruptionBudgetForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1PodDisruptionBudgetList>> {
        return this.api.listPodDisruptionBudgetForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listPodDisruptionBudgetForAllNamespaces(param: PolicyV1ApiListPodDisruptionBudgetForAllNamespacesRequest = {}, options?: Configuration): Promise<V1PodDisruptionBudgetList> {
        return this.api.listPodDisruptionBudgetForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiPatchNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.patchNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudget(param: PolicyV1ApiPatchNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1PodDisruptionBudget> {
        return this.api.patchNamespacedPodDisruptionBudget(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudgetStatusWithHttpInfo(param: PolicyV1ApiPatchNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.patchNamespacedPodDisruptionBudgetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudgetStatus(param: PolicyV1ApiPatchNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<V1PodDisruptionBudget> {
        return this.api.patchNamespacedPodDisruptionBudgetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiReadNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.readNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudget(param: PolicyV1ApiReadNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1PodDisruptionBudget> {
        return this.api.readNamespacedPodDisruptionBudget(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudgetStatusWithHttpInfo(param: PolicyV1ApiReadNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.readNamespacedPodDisruptionBudgetStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudgetStatus(param: PolicyV1ApiReadNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<V1PodDisruptionBudget> {
        return this.api.readNamespacedPodDisruptionBudgetStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiReplaceNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.replaceNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudget(param: PolicyV1ApiReplaceNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1PodDisruptionBudget> {
        return this.api.replaceNamespacedPodDisruptionBudget(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudgetStatusWithHttpInfo(param: PolicyV1ApiReplaceNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.replaceNamespacedPodDisruptionBudgetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudgetStatus(param: PolicyV1ApiReplaceNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<V1PodDisruptionBudget> {
        return this.api.replaceNamespacedPodDisruptionBudgetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservablePolicyV1beta1Api } from "./ObservableAPI";
import { PolicyV1beta1ApiRequestFactory, PolicyV1beta1ApiResponseProcessor} from "../apis/PolicyV1beta1Api";

export interface PolicyV1beta1ApiCreateNamespacedPodDisruptionBudgetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApicreateNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * 
     * @type V1beta1PodDisruptionBudget
     * @memberof PolicyV1beta1ApicreateNamespacedPodDisruptionBudget
     */
    body: V1beta1PodDisruptionBudget
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApicreateNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApicreateNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1beta1ApicreateNamespacedPodDisruptionBudget
     */
    fieldManager?: string
}

export interface PolicyV1beta1ApiCreatePodSecurityPolicyRequest {
    /**
     * 
     * @type V1beta1PodSecurityPolicy
     * @memberof PolicyV1beta1ApicreatePodSecurityPolicy
     */
    body: V1beta1PodSecurityPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApicreatePodSecurityPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApicreatePodSecurityPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1beta1ApicreatePodSecurityPolicy
     */
    fieldManager?: string
}

export interface PolicyV1beta1ApiDeleteCollectionNamespacedPodDisruptionBudgetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof PolicyV1beta1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    body?: V1DeleteOptions
}

export interface PolicyV1beta1ApiDeleteCollectionPodSecurityPolicyRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof PolicyV1beta1ApideleteCollectionPodSecurityPolicy
     */
    body?: V1DeleteOptions
}

export interface PolicyV1beta1ApiDeleteNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApideleteNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApideleteNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApideleteNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApideleteNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof PolicyV1beta1ApideleteNamespacedPodDisruptionBudget
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof PolicyV1beta1ApideleteNamespacedPodDisruptionBudget
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof PolicyV1beta1ApideleteNamespacedPodDisruptionBudget
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof PolicyV1beta1ApideleteNamespacedPodDisruptionBudget
     */
    body?: V1DeleteOptions
}

export interface PolicyV1beta1ApiDeletePodSecurityPolicyRequest {
    /**
     * name of the PodSecurityPolicy
     * @type string
     * @memberof PolicyV1beta1ApideletePodSecurityPolicy
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApideletePodSecurityPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApideletePodSecurityPolicy
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof PolicyV1beta1ApideletePodSecurityPolicy
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof PolicyV1beta1ApideletePodSecurityPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof PolicyV1beta1ApideletePodSecurityPolicy
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof PolicyV1beta1ApideletePodSecurityPolicy
     */
    body?: V1DeleteOptions
}

export interface PolicyV1beta1ApiGetAPIResourcesRequest {
}

export interface PolicyV1beta1ApiListNamespacedPodDisruptionBudgetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApilistNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApilistNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof PolicyV1beta1ApilistNamespacedPodDisruptionBudget
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApilistNamespacedPodDisruptionBudget
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistNamespacedPodDisruptionBudget
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistNamespacedPodDisruptionBudget
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApilistNamespacedPodDisruptionBudget
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistNamespacedPodDisruptionBudget
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistNamespacedPodDisruptionBudget
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApilistNamespacedPodDisruptionBudget
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1beta1ApilistNamespacedPodDisruptionBudget
     */
    watch?: boolean
}

export interface PolicyV1beta1ApiListPodDisruptionBudgetForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof PolicyV1beta1ApilistPodDisruptionBudgetForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApilistPodDisruptionBudgetForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistPodDisruptionBudgetForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistPodDisruptionBudgetForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApilistPodDisruptionBudgetForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApilistPodDisruptionBudgetForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistPodDisruptionBudgetForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistPodDisruptionBudgetForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApilistPodDisruptionBudgetForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1beta1ApilistPodDisruptionBudgetForAllNamespaces
     */
    watch?: boolean
}

export interface PolicyV1beta1ApiListPodSecurityPolicyRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApilistPodSecurityPolicy
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof PolicyV1beta1ApilistPodSecurityPolicy
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApilistPodSecurityPolicy
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistPodSecurityPolicy
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistPodSecurityPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApilistPodSecurityPolicy
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistPodSecurityPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistPodSecurityPolicy
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApilistPodSecurityPolicy
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1beta1ApilistPodSecurityPolicy
     */
    watch?: boolean
}

export interface PolicyV1beta1ApiPatchNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudget
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudget
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudget
     */
    force?: boolean
}

export interface PolicyV1beta1ApiPatchNamespacedPodDisruptionBudgetStatusRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof PolicyV1beta1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    force?: boolean
}

export interface PolicyV1beta1ApiPatchPodSecurityPolicyRequest {
    /**
     * name of the PodSecurityPolicy
     * @type string
     * @memberof PolicyV1beta1ApipatchPodSecurityPolicy
     */
    name: string
    /**
     * 
     * @type any
     * @memberof PolicyV1beta1ApipatchPodSecurityPolicy
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApipatchPodSecurityPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApipatchPodSecurityPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof PolicyV1beta1ApipatchPodSecurityPolicy
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof PolicyV1beta1ApipatchPodSecurityPolicy
     */
    force?: boolean
}

export interface PolicyV1beta1ApiReadNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApireadNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApireadNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireadNamespacedPodDisruptionBudget
     */
    pretty?: string
}

export interface PolicyV1beta1ApiReadNamespacedPodDisruptionBudgetStatusRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApireadNamespacedPodDisruptionBudgetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApireadNamespacedPodDisruptionBudgetStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireadNamespacedPodDisruptionBudgetStatus
     */
    pretty?: string
}

export interface PolicyV1beta1ApiReadPodSecurityPolicyRequest {
    /**
     * name of the PodSecurityPolicy
     * @type string
     * @memberof PolicyV1beta1ApireadPodSecurityPolicy
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireadPodSecurityPolicy
     */
    pretty?: string
}

export interface PolicyV1beta1ApiReplaceNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * 
     * @type V1beta1PodDisruptionBudget
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudget
     */
    body: V1beta1PodDisruptionBudget
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudget
     */
    fieldManager?: string
}

export interface PolicyV1beta1ApiReplaceNamespacedPodDisruptionBudgetStatusRequest {
    /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    namespace: string
    /**
     * 
     * @type V1beta1PodDisruptionBudget
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    body: V1beta1PodDisruptionBudget
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1beta1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    fieldManager?: string
}

export interface PolicyV1beta1ApiReplacePodSecurityPolicyRequest {
    /**
     * name of the PodSecurityPolicy
     * @type string
     * @memberof PolicyV1beta1ApireplacePodSecurityPolicy
     */
    name: string
    /**
     * 
     * @type V1beta1PodSecurityPolicy
     * @memberof PolicyV1beta1ApireplacePodSecurityPolicy
     */
    body: V1beta1PodSecurityPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireplacePodSecurityPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApireplacePodSecurityPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1beta1ApireplacePodSecurityPolicy
     */
    fieldManager?: string
}

export class ObjectPolicyV1beta1Api {
    private api: ObservablePolicyV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: PolicyV1beta1ApiRequestFactory, responseProcessor?: PolicyV1beta1ApiResponseProcessor) {
        this.api = new ObservablePolicyV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a PodDisruptionBudget
     * @param param the request object
     */
    public createNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1beta1ApiCreateNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodDisruptionBudget>> {
        return this.api.createNamespacedPodDisruptionBudgetWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PodDisruptionBudget
     * @param param the request object
     */
    public createNamespacedPodDisruptionBudget(param: PolicyV1beta1ApiCreateNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1beta1PodDisruptionBudget> {
        return this.api.createNamespacedPodDisruptionBudget(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PodSecurityPolicy
     * @param param the request object
     */
    public createPodSecurityPolicyWithHttpInfo(param: PolicyV1beta1ApiCreatePodSecurityPolicyRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodSecurityPolicy>> {
        return this.api.createPodSecurityPolicyWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PodSecurityPolicy
     * @param param the request object
     */
    public createPodSecurityPolicy(param: PolicyV1beta1ApiCreatePodSecurityPolicyRequest, options?: Configuration): Promise<V1beta1PodSecurityPolicy> {
        return this.api.createPodSecurityPolicy(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of PodDisruptionBudget
     * @param param the request object
     */
    public deleteCollectionNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1beta1ApiDeleteCollectionNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedPodDisruptionBudgetWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PodDisruptionBudget
     * @param param the request object
     */
    public deleteCollectionNamespacedPodDisruptionBudget(param: PolicyV1beta1ApiDeleteCollectionNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedPodDisruptionBudget(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PodSecurityPolicy
     * @param param the request object
     */
    public deleteCollectionPodSecurityPolicyWithHttpInfo(param: PolicyV1beta1ApiDeleteCollectionPodSecurityPolicyRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionPodSecurityPolicyWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PodSecurityPolicy
     * @param param the request object
     */
    public deleteCollectionPodSecurityPolicy(param: PolicyV1beta1ApiDeleteCollectionPodSecurityPolicyRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionPodSecurityPolicy(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a PodDisruptionBudget
     * @param param the request object
     */
    public deleteNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1beta1ApiDeleteNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PodDisruptionBudget
     * @param param the request object
     */
    public deleteNamespacedPodDisruptionBudget(param: PolicyV1beta1ApiDeleteNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedPodDisruptionBudget(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PodSecurityPolicy
     * @param param the request object
     */
    public deletePodSecurityPolicyWithHttpInfo(param: PolicyV1beta1ApiDeletePodSecurityPolicyRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodSecurityPolicy>> {
        return this.api.deletePodSecurityPolicyWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PodSecurityPolicy
     * @param param the request object
     */
    public deletePodSecurityPolicy(param: PolicyV1beta1ApiDeletePodSecurityPolicyRequest, options?: Configuration): Promise<V1beta1PodSecurityPolicy> {
        return this.api.deletePodSecurityPolicy(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: PolicyV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: PolicyV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1beta1ApiListNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodDisruptionBudgetList>> {
        return this.api.listNamespacedPodDisruptionBudgetWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listNamespacedPodDisruptionBudget(param: PolicyV1beta1ApiListNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1beta1PodDisruptionBudgetList> {
        return this.api.listNamespacedPodDisruptionBudget(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listPodDisruptionBudgetForAllNamespacesWithHttpInfo(param: PolicyV1beta1ApiListPodDisruptionBudgetForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1beta1PodDisruptionBudgetList>> {
        return this.api.listPodDisruptionBudgetForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listPodDisruptionBudgetForAllNamespaces(param: PolicyV1beta1ApiListPodDisruptionBudgetForAllNamespacesRequest = {}, options?: Configuration): Promise<V1beta1PodDisruptionBudgetList> {
        return this.api.listPodDisruptionBudgetForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodSecurityPolicy
     * @param param the request object
     */
    public listPodSecurityPolicyWithHttpInfo(param: PolicyV1beta1ApiListPodSecurityPolicyRequest = {}, options?: Configuration): Promise<HttpInfo<V1beta1PodSecurityPolicyList>> {
        return this.api.listPodSecurityPolicyWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodSecurityPolicy
     * @param param the request object
     */
    public listPodSecurityPolicy(param: PolicyV1beta1ApiListPodSecurityPolicyRequest = {}, options?: Configuration): Promise<V1beta1PodSecurityPolicyList> {
        return this.api.listPodSecurityPolicy(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1beta1ApiPatchNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodDisruptionBudget>> {
        return this.api.patchNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudget(param: PolicyV1beta1ApiPatchNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1beta1PodDisruptionBudget> {
        return this.api.patchNamespacedPodDisruptionBudget(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudgetStatusWithHttpInfo(param: PolicyV1beta1ApiPatchNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodDisruptionBudget>> {
        return this.api.patchNamespacedPodDisruptionBudgetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudgetStatus(param: PolicyV1beta1ApiPatchNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<V1beta1PodDisruptionBudget> {
        return this.api.patchNamespacedPodDisruptionBudgetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PodSecurityPolicy
     * @param param the request object
     */
    public patchPodSecurityPolicyWithHttpInfo(param: PolicyV1beta1ApiPatchPodSecurityPolicyRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodSecurityPolicy>> {
        return this.api.patchPodSecurityPolicyWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PodSecurityPolicy
     * @param param the request object
     */
    public patchPodSecurityPolicy(param: PolicyV1beta1ApiPatchPodSecurityPolicyRequest, options?: Configuration): Promise<V1beta1PodSecurityPolicy> {
        return this.api.patchPodSecurityPolicy(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1beta1ApiReadNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodDisruptionBudget>> {
        return this.api.readNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudget(param: PolicyV1beta1ApiReadNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1beta1PodDisruptionBudget> {
        return this.api.readNamespacedPodDisruptionBudget(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudgetStatusWithHttpInfo(param: PolicyV1beta1ApiReadNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodDisruptionBudget>> {
        return this.api.readNamespacedPodDisruptionBudgetStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudgetStatus(param: PolicyV1beta1ApiReadNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<V1beta1PodDisruptionBudget> {
        return this.api.readNamespacedPodDisruptionBudgetStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PodSecurityPolicy
     * @param param the request object
     */
    public readPodSecurityPolicyWithHttpInfo(param: PolicyV1beta1ApiReadPodSecurityPolicyRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodSecurityPolicy>> {
        return this.api.readPodSecurityPolicyWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PodSecurityPolicy
     * @param param the request object
     */
    public readPodSecurityPolicy(param: PolicyV1beta1ApiReadPodSecurityPolicyRequest, options?: Configuration): Promise<V1beta1PodSecurityPolicy> {
        return this.api.readPodSecurityPolicy(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1beta1ApiReplaceNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodDisruptionBudget>> {
        return this.api.replaceNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudget(param: PolicyV1beta1ApiReplaceNamespacedPodDisruptionBudgetRequest, options?: Configuration): Promise<V1beta1PodDisruptionBudget> {
        return this.api.replaceNamespacedPodDisruptionBudget(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudgetStatusWithHttpInfo(param: PolicyV1beta1ApiReplaceNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodDisruptionBudget>> {
        return this.api.replaceNamespacedPodDisruptionBudgetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudgetStatus(param: PolicyV1beta1ApiReplaceNamespacedPodDisruptionBudgetStatusRequest, options?: Configuration): Promise<V1beta1PodDisruptionBudget> {
        return this.api.replaceNamespacedPodDisruptionBudgetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PodSecurityPolicy
     * @param param the request object
     */
    public replacePodSecurityPolicyWithHttpInfo(param: PolicyV1beta1ApiReplacePodSecurityPolicyRequest, options?: Configuration): Promise<HttpInfo<V1beta1PodSecurityPolicy>> {
        return this.api.replacePodSecurityPolicyWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PodSecurityPolicy
     * @param param the request object
     */
    public replacePodSecurityPolicy(param: PolicyV1beta1ApiReplacePodSecurityPolicyRequest, options?: Configuration): Promise<V1beta1PodSecurityPolicy> {
        return this.api.replacePodSecurityPolicy(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableRbacAuthorizationApi } from "./ObservableAPI";
import { RbacAuthorizationApiRequestFactory, RbacAuthorizationApiResponseProcessor} from "../apis/RbacAuthorizationApi";

export interface RbacAuthorizationApiGetAPIGroupRequest {
}

export class ObjectRbacAuthorizationApi {
    private api: ObservableRbacAuthorizationApi

    public constructor(configuration: Configuration, requestFactory?: RbacAuthorizationApiRequestFactory, responseProcessor?: RbacAuthorizationApiResponseProcessor) {
        this.api = new ObservableRbacAuthorizationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: RbacAuthorizationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: RbacAuthorizationApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableRbacAuthorizationV1Api } from "./ObservableAPI";
import { RbacAuthorizationV1ApiRequestFactory, RbacAuthorizationV1ApiResponseProcessor} from "../apis/RbacAuthorizationV1Api";

export interface RbacAuthorizationV1ApiCreateClusterRoleRequest {
    /**
     * 
     * @type V1ClusterRole
     * @memberof RbacAuthorizationV1ApicreateClusterRole
     */
    body: V1ClusterRole
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRole
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1ApiCreateClusterRoleBindingRequest {
    /**
     * 
     * @type V1ClusterRoleBinding
     * @memberof RbacAuthorizationV1ApicreateClusterRoleBinding
     */
    body: V1ClusterRoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRoleBinding
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1ApiCreateNamespacedRoleRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRole
     */
    namespace: string
    /**
     * 
     * @type V1Role
     * @memberof RbacAuthorizationV1ApicreateNamespacedRole
     */
    body: V1Role
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRole
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1ApiCreateNamespacedRoleBindingRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRoleBinding
     */
    namespace: string
    /**
     * 
     * @type V1RoleBinding
     * @memberof RbacAuthorizationV1ApicreateNamespacedRoleBinding
     */
    body: V1RoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRoleBinding
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1ApiDeleteClusterRoleRequest {
    /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteCollectionClusterRoleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteCollectionClusterRoleBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleBindingRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteNamespacedRoleRequest {
    /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiGetAPIResourcesRequest {
}

export interface RbacAuthorizationV1ApiListClusterRoleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiListClusterRoleBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiListNamespacedRoleRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiListNamespacedRoleBindingRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiListRoleBindingForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiListRoleForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiPatchClusterRoleRequest {
    /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    name: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    force?: boolean
}

export interface RbacAuthorizationV1ApiPatchClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    name: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    force?: boolean
}

export interface RbacAuthorizationV1ApiPatchNamespacedRoleRequest {
    /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    force?: boolean
}

export interface RbacAuthorizationV1ApiPatchNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    force?: boolean
}

export interface RbacAuthorizationV1ApiReadClusterRoleRequest {
    /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1ApireadClusterRole
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireadClusterRole
     */
    pretty?: string
}

export interface RbacAuthorizationV1ApiReadClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApireadClusterRoleBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireadClusterRoleBinding
     */
    pretty?: string
}

export interface RbacAuthorizationV1ApiReadNamespacedRoleRequest {
    /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRole
     */
    pretty?: string
}

export interface RbacAuthorizationV1ApiReadNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRoleBinding
     */
    pretty?: string
}

export interface RbacAuthorizationV1ApiReplaceClusterRoleRequest {
    /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRole
     */
    name: string
    /**
     * 
     * @type V1ClusterRole
     * @memberof RbacAuthorizationV1ApireplaceClusterRole
     */
    body: V1ClusterRole
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRole
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1ApiReplaceClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRoleBinding
     */
    name: string
    /**
     * 
     * @type V1ClusterRoleBinding
     * @memberof RbacAuthorizationV1ApireplaceClusterRoleBinding
     */
    body: V1ClusterRoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRoleBinding
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1ApiReplaceNamespacedRoleRequest {
    /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    namespace: string
    /**
     * 
     * @type V1Role
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    body: V1Role
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1ApiReplaceNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    namespace: string
    /**
     * 
     * @type V1RoleBinding
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    body: V1RoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    fieldManager?: string
}

export class ObjectRbacAuthorizationV1Api {
    private api: ObservableRbacAuthorizationV1Api

    public constructor(configuration: Configuration, requestFactory?: RbacAuthorizationV1ApiRequestFactory, responseProcessor?: RbacAuthorizationV1ApiResponseProcessor) {
        this.api = new ObservableRbacAuthorizationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a ClusterRole
     * @param param the request object
     */
    public createClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiCreateClusterRoleRequest, options?: Configuration): Promise<HttpInfo<V1ClusterRole>> {
        return this.api.createClusterRoleWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ClusterRole
     * @param param the request object
     */
    public createClusterRole(param: RbacAuthorizationV1ApiCreateClusterRoleRequest, options?: Configuration): Promise<V1ClusterRole> {
        return this.api.createClusterRole(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ClusterRoleBinding
     * @param param the request object
     */
    public createClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiCreateClusterRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1ClusterRoleBinding>> {
        return this.api.createClusterRoleBindingWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ClusterRoleBinding
     * @param param the request object
     */
    public createClusterRoleBinding(param: RbacAuthorizationV1ApiCreateClusterRoleBindingRequest, options?: Configuration): Promise<V1ClusterRoleBinding> {
        return this.api.createClusterRoleBinding(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Role
     * @param param the request object
     */
    public createNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiCreateNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1Role>> {
        return this.api.createNamespacedRoleWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Role
     * @param param the request object
     */
    public createNamespacedRole(param: RbacAuthorizationV1ApiCreateNamespacedRoleRequest, options?: Configuration): Promise<V1Role> {
        return this.api.createNamespacedRole(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a RoleBinding
     * @param param the request object
     */
    public createNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiCreateNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1RoleBinding>> {
        return this.api.createNamespacedRoleBindingWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a RoleBinding
     * @param param the request object
     */
    public createNamespacedRoleBinding(param: RbacAuthorizationV1ApiCreateNamespacedRoleBindingRequest, options?: Configuration): Promise<V1RoleBinding> {
        return this.api.createNamespacedRoleBinding(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete a ClusterRole
     * @param param the request object
     */
    public deleteClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiDeleteClusterRoleRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteClusterRoleWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ClusterRole
     * @param param the request object
     */
    public deleteClusterRole(param: RbacAuthorizationV1ApiDeleteClusterRoleRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteClusterRole(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ClusterRoleBinding
     * @param param the request object
     */
    public deleteClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiDeleteClusterRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteClusterRoleBindingWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ClusterRoleBinding
     * @param param the request object
     */
    public deleteClusterRoleBinding(param: RbacAuthorizationV1ApiDeleteClusterRoleBindingRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteClusterRoleBinding(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRole
     * @param param the request object
     */
    public deleteCollectionClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiDeleteCollectionClusterRoleRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionClusterRoleWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRole
     * @param param the request object
     */
    public deleteCollectionClusterRole(param: RbacAuthorizationV1ApiDeleteCollectionClusterRoleRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionClusterRole(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRoleBinding
     * @param param the request object
     */
    public deleteCollectionClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiDeleteCollectionClusterRoleBindingRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionClusterRoleBindingWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRoleBinding
     * @param param the request object
     */
    public deleteCollectionClusterRoleBinding(param: RbacAuthorizationV1ApiDeleteCollectionClusterRoleBindingRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionClusterRoleBinding(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Role
     * @param param the request object
     */
    public deleteCollectionNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedRoleWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Role
     * @param param the request object
     */
    public deleteCollectionNamespacedRole(param: RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedRole(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of RoleBinding
     * @param param the request object
     */
    public deleteCollectionNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedRoleBindingWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of RoleBinding
     * @param param the request object
     */
    public deleteCollectionNamespacedRoleBinding(param: RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleBindingRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedRoleBinding(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a Role
     * @param param the request object
     */
    public deleteNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiDeleteNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedRoleWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Role
     * @param param the request object
     */
    public deleteNamespacedRole(param: RbacAuthorizationV1ApiDeleteNamespacedRoleRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedRole(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a RoleBinding
     * @param param the request object
     */
    public deleteNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiDeleteNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a RoleBinding
     * @param param the request object
     */
    public deleteNamespacedRoleBinding(param: RbacAuthorizationV1ApiDeleteNamespacedRoleBindingRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedRoleBinding(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: RbacAuthorizationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: RbacAuthorizationV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRole
     * @param param the request object
     */
    public listClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiListClusterRoleRequest = {}, options?: Configuration): Promise<HttpInfo<V1ClusterRoleList>> {
        return this.api.listClusterRoleWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRole
     * @param param the request object
     */
    public listClusterRole(param: RbacAuthorizationV1ApiListClusterRoleRequest = {}, options?: Configuration): Promise<V1ClusterRoleList> {
        return this.api.listClusterRole(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRoleBinding
     * @param param the request object
     */
    public listClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiListClusterRoleBindingRequest = {}, options?: Configuration): Promise<HttpInfo<V1ClusterRoleBindingList>> {
        return this.api.listClusterRoleBindingWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRoleBinding
     * @param param the request object
     */
    public listClusterRoleBinding(param: RbacAuthorizationV1ApiListClusterRoleBindingRequest = {}, options?: Configuration): Promise<V1ClusterRoleBindingList> {
        return this.api.listClusterRoleBinding(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiListNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1RoleList>> {
        return this.api.listNamespacedRoleWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listNamespacedRole(param: RbacAuthorizationV1ApiListNamespacedRoleRequest, options?: Configuration): Promise<V1RoleList> {
        return this.api.listNamespacedRole(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiListNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1RoleBindingList>> {
        return this.api.listNamespacedRoleBindingWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listNamespacedRoleBinding(param: RbacAuthorizationV1ApiListNamespacedRoleBindingRequest, options?: Configuration): Promise<V1RoleBindingList> {
        return this.api.listNamespacedRoleBinding(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listRoleBindingForAllNamespacesWithHttpInfo(param: RbacAuthorizationV1ApiListRoleBindingForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1RoleBindingList>> {
        return this.api.listRoleBindingForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listRoleBindingForAllNamespaces(param: RbacAuthorizationV1ApiListRoleBindingForAllNamespacesRequest = {}, options?: Configuration): Promise<V1RoleBindingList> {
        return this.api.listRoleBindingForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listRoleForAllNamespacesWithHttpInfo(param: RbacAuthorizationV1ApiListRoleForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1RoleList>> {
        return this.api.listRoleForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listRoleForAllNamespaces(param: RbacAuthorizationV1ApiListRoleForAllNamespacesRequest = {}, options?: Configuration): Promise<V1RoleList> {
        return this.api.listRoleForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRole
     * @param param the request object
     */
    public patchClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiPatchClusterRoleRequest, options?: Configuration): Promise<HttpInfo<V1ClusterRole>> {
        return this.api.patchClusterRoleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRole
     * @param param the request object
     */
    public patchClusterRole(param: RbacAuthorizationV1ApiPatchClusterRoleRequest, options?: Configuration): Promise<V1ClusterRole> {
        return this.api.patchClusterRole(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRoleBinding
     * @param param the request object
     */
    public patchClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiPatchClusterRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1ClusterRoleBinding>> {
        return this.api.patchClusterRoleBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRoleBinding
     * @param param the request object
     */
    public patchClusterRoleBinding(param: RbacAuthorizationV1ApiPatchClusterRoleBindingRequest, options?: Configuration): Promise<V1ClusterRoleBinding> {
        return this.api.patchClusterRoleBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Role
     * @param param the request object
     */
    public patchNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiPatchNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1Role>> {
        return this.api.patchNamespacedRoleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Role
     * @param param the request object
     */
    public patchNamespacedRole(param: RbacAuthorizationV1ApiPatchNamespacedRoleRequest, options?: Configuration): Promise<V1Role> {
        return this.api.patchNamespacedRole(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified RoleBinding
     * @param param the request object
     */
    public patchNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiPatchNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1RoleBinding>> {
        return this.api.patchNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified RoleBinding
     * @param param the request object
     */
    public patchNamespacedRoleBinding(param: RbacAuthorizationV1ApiPatchNamespacedRoleBindingRequest, options?: Configuration): Promise<V1RoleBinding> {
        return this.api.patchNamespacedRoleBinding(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified ClusterRole
     * @param param the request object
     */
    public readClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiReadClusterRoleRequest, options?: Configuration): Promise<HttpInfo<V1ClusterRole>> {
        return this.api.readClusterRoleWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ClusterRole
     * @param param the request object
     */
    public readClusterRole(param: RbacAuthorizationV1ApiReadClusterRoleRequest, options?: Configuration): Promise<V1ClusterRole> {
        return this.api.readClusterRole(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ClusterRoleBinding
     * @param param the request object
     */
    public readClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiReadClusterRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1ClusterRoleBinding>> {
        return this.api.readClusterRoleBindingWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ClusterRoleBinding
     * @param param the request object
     */
    public readClusterRoleBinding(param: RbacAuthorizationV1ApiReadClusterRoleBindingRequest, options?: Configuration): Promise<V1ClusterRoleBinding> {
        return this.api.readClusterRoleBinding(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Role
     * @param param the request object
     */
    public readNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiReadNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1Role>> {
        return this.api.readNamespacedRoleWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Role
     * @param param the request object
     */
    public readNamespacedRole(param: RbacAuthorizationV1ApiReadNamespacedRoleRequest, options?: Configuration): Promise<V1Role> {
        return this.api.readNamespacedRole(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified RoleBinding
     * @param param the request object
     */
    public readNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiReadNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1RoleBinding>> {
        return this.api.readNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified RoleBinding
     * @param param the request object
     */
    public readNamespacedRoleBinding(param: RbacAuthorizationV1ApiReadNamespacedRoleBindingRequest, options?: Configuration): Promise<V1RoleBinding> {
        return this.api.readNamespacedRoleBinding(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified ClusterRole
     * @param param the request object
     */
    public replaceClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiReplaceClusterRoleRequest, options?: Configuration): Promise<HttpInfo<V1ClusterRole>> {
        return this.api.replaceClusterRoleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ClusterRole
     * @param param the request object
     */
    public replaceClusterRole(param: RbacAuthorizationV1ApiReplaceClusterRoleRequest, options?: Configuration): Promise<V1ClusterRole> {
        return this.api.replaceClusterRole(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ClusterRoleBinding
     * @param param the request object
     */
    public replaceClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiReplaceClusterRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1ClusterRoleBinding>> {
        return this.api.replaceClusterRoleBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ClusterRoleBinding
     * @param param the request object
     */
    public replaceClusterRoleBinding(param: RbacAuthorizationV1ApiReplaceClusterRoleBindingRequest, options?: Configuration): Promise<V1ClusterRoleBinding> {
        return this.api.replaceClusterRoleBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Role
     * @param param the request object
     */
    public replaceNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiReplaceNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1Role>> {
        return this.api.replaceNamespacedRoleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Role
     * @param param the request object
     */
    public replaceNamespacedRole(param: RbacAuthorizationV1ApiReplaceNamespacedRoleRequest, options?: Configuration): Promise<V1Role> {
        return this.api.replaceNamespacedRole(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified RoleBinding
     * @param param the request object
     */
    public replaceNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiReplaceNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1RoleBinding>> {
        return this.api.replaceNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified RoleBinding
     * @param param the request object
     */
    public replaceNamespacedRoleBinding(param: RbacAuthorizationV1ApiReplaceNamespacedRoleBindingRequest, options?: Configuration): Promise<V1RoleBinding> {
        return this.api.replaceNamespacedRoleBinding(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableRbacAuthorizationV1alpha1Api } from "./ObservableAPI";
import { RbacAuthorizationV1alpha1ApiRequestFactory, RbacAuthorizationV1alpha1ApiResponseProcessor} from "../apis/RbacAuthorizationV1alpha1Api";

export interface RbacAuthorizationV1alpha1ApiCreateClusterRoleRequest {
    /**
     * 
     * @type V1alpha1ClusterRole
     * @memberof RbacAuthorizationV1alpha1ApicreateClusterRole
     */
    body: V1alpha1ClusterRole
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateClusterRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateClusterRole
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1alpha1ApiCreateClusterRoleBindingRequest {
    /**
     * 
     * @type V1alpha1ClusterRoleBinding
     * @memberof RbacAuthorizationV1alpha1ApicreateClusterRoleBinding
     */
    body: V1alpha1ClusterRoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateClusterRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateClusterRoleBinding
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1alpha1ApiCreateNamespacedRoleRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateNamespacedRole
     */
    namespace: string
    /**
     * 
     * @type V1alpha1Role
     * @memberof RbacAuthorizationV1alpha1ApicreateNamespacedRole
     */
    body: V1alpha1Role
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateNamespacedRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateNamespacedRole
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1alpha1ApiCreateNamespacedRoleBindingRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateNamespacedRoleBinding
     */
    namespace: string
    /**
     * 
     * @type V1alpha1RoleBinding
     * @memberof RbacAuthorizationV1alpha1ApicreateNamespacedRoleBinding
     */
    body: V1alpha1RoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateNamespacedRoleBinding
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1alpha1ApiDeleteClusterRoleRequest {
    /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRole
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRole
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRole
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRole
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1alpha1ApiDeleteClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRoleBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRoleBinding
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRoleBinding
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteClusterRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1alpha1ApiDeleteCollectionClusterRoleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1alpha1ApiDeleteCollectionClusterRoleBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionClusterRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1alpha1ApiDeleteCollectionNamespacedRoleRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1alpha1ApiDeleteCollectionNamespacedRoleBindingRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteCollectionNamespacedRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1alpha1ApiDeleteNamespacedRoleRequest {
    /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRole
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRole
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRole
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1alpha1ApiDeleteNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRoleBinding
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteNamespacedRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1alpha1ApiGetAPIResourcesRequest {
}

export interface RbacAuthorizationV1alpha1ApiListClusterRoleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRole
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRole
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRole
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRole
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRole
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRole
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRole
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRole
     */
    watch?: boolean
}

export interface RbacAuthorizationV1alpha1ApiListClusterRoleBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRoleBinding
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRoleBinding
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRoleBinding
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRoleBinding
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRoleBinding
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRoleBinding
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistClusterRoleBinding
     */
    watch?: boolean
}

export interface RbacAuthorizationV1alpha1ApiListNamespacedRoleRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRole
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRole
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRole
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRole
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRole
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRole
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRole
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRole
     */
    watch?: boolean
}

export interface RbacAuthorizationV1alpha1ApiListNamespacedRoleBindingRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRoleBinding
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRoleBinding
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRoleBinding
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRoleBinding
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRoleBinding
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRoleBinding
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistNamespacedRoleBinding
     */
    watch?: boolean
}

export interface RbacAuthorizationV1alpha1ApiListRoleBindingForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRoleBindingForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleBindingForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleBindingForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleBindingForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRoleBindingForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleBindingForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleBindingForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleBindingForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRoleBindingForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRoleBindingForAllNamespaces
     */
    watch?: boolean
}

export interface RbacAuthorizationV1alpha1ApiListRoleForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRoleForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRoleForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRoleForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRoleForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRoleForAllNamespaces
     */
    watch?: boolean
}

export interface RbacAuthorizationV1alpha1ApiPatchClusterRoleRequest {
    /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRole
     */
    name: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRole
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRole
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRole
     */
    force?: boolean
}

export interface RbacAuthorizationV1alpha1ApiPatchClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRoleBinding
     */
    name: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRoleBinding
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRoleBinding
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApipatchClusterRoleBinding
     */
    force?: boolean
}

export interface RbacAuthorizationV1alpha1ApiPatchNamespacedRoleRequest {
    /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRole
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRole
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRole
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRole
     */
    force?: boolean
}

export interface RbacAuthorizationV1alpha1ApiPatchNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRoleBinding
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRoleBinding
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRoleBinding
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApipatchNamespacedRoleBinding
     */
    force?: boolean
}

export interface RbacAuthorizationV1alpha1ApiReadClusterRoleRequest {
    /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadClusterRole
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadClusterRole
     */
    pretty?: string
}

export interface RbacAuthorizationV1alpha1ApiReadClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadClusterRoleBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadClusterRoleBinding
     */
    pretty?: string
}

export interface RbacAuthorizationV1alpha1ApiReadNamespacedRoleRequest {
    /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadNamespacedRole
     */
    pretty?: string
}

export interface RbacAuthorizationV1alpha1ApiReadNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadNamespacedRoleBinding
     */
    pretty?: string
}

export interface RbacAuthorizationV1alpha1ApiReplaceClusterRoleRequest {
    /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceClusterRole
     */
    name: string
    /**
     * 
     * @type V1alpha1ClusterRole
     * @memberof RbacAuthorizationV1alpha1ApireplaceClusterRole
     */
    body: V1alpha1ClusterRole
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceClusterRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceClusterRole
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1alpha1ApiReplaceClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceClusterRoleBinding
     */
    name: string
    /**
     * 
     * @type V1alpha1ClusterRoleBinding
     * @memberof RbacAuthorizationV1alpha1ApireplaceClusterRoleBinding
     */
    body: V1alpha1ClusterRoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceClusterRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceClusterRoleBinding
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1alpha1ApiReplaceNamespacedRoleRequest {
    /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRole
     */
    namespace: string
    /**
     * 
     * @type V1alpha1Role
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRole
     */
    body: V1alpha1Role
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRole
     */
    fieldManager?: string
}

export interface RbacAuthorizationV1alpha1ApiReplaceNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRoleBinding
     */
    namespace: string
    /**
     * 
     * @type V1alpha1RoleBinding
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRoleBinding
     */
    body: V1alpha1RoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceNamespacedRoleBinding
     */
    fieldManager?: string
}

export class ObjectRbacAuthorizationV1alpha1Api {
    private api: ObservableRbacAuthorizationV1alpha1Api

    public constructor(configuration: Configuration, requestFactory?: RbacAuthorizationV1alpha1ApiRequestFactory, responseProcessor?: RbacAuthorizationV1alpha1ApiResponseProcessor) {
        this.api = new ObservableRbacAuthorizationV1alpha1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a ClusterRole
     * @param param the request object
     */
    public createClusterRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiCreateClusterRoleRequest, options?: Configuration): Promise<HttpInfo<V1alpha1ClusterRole>> {
        return this.api.createClusterRoleWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ClusterRole
     * @param param the request object
     */
    public createClusterRole(param: RbacAuthorizationV1alpha1ApiCreateClusterRoleRequest, options?: Configuration): Promise<V1alpha1ClusterRole> {
        return this.api.createClusterRole(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ClusterRoleBinding
     * @param param the request object
     */
    public createClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiCreateClusterRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1alpha1ClusterRoleBinding>> {
        return this.api.createClusterRoleBindingWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a ClusterRoleBinding
     * @param param the request object
     */
    public createClusterRoleBinding(param: RbacAuthorizationV1alpha1ApiCreateClusterRoleBindingRequest, options?: Configuration): Promise<V1alpha1ClusterRoleBinding> {
        return this.api.createClusterRoleBinding(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Role
     * @param param the request object
     */
    public createNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiCreateNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1alpha1Role>> {
        return this.api.createNamespacedRoleWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a Role
     * @param param the request object
     */
    public createNamespacedRole(param: RbacAuthorizationV1alpha1ApiCreateNamespacedRoleRequest, options?: Configuration): Promise<V1alpha1Role> {
        return this.api.createNamespacedRole(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a RoleBinding
     * @param param the request object
     */
    public createNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiCreateNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1alpha1RoleBinding>> {
        return this.api.createNamespacedRoleBindingWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a RoleBinding
     * @param param the request object
     */
    public createNamespacedRoleBinding(param: RbacAuthorizationV1alpha1ApiCreateNamespacedRoleBindingRequest, options?: Configuration): Promise<V1alpha1RoleBinding> {
        return this.api.createNamespacedRoleBinding(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete a ClusterRole
     * @param param the request object
     */
    public deleteClusterRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiDeleteClusterRoleRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteClusterRoleWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ClusterRole
     * @param param the request object
     */
    public deleteClusterRole(param: RbacAuthorizationV1alpha1ApiDeleteClusterRoleRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteClusterRole(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ClusterRoleBinding
     * @param param the request object
     */
    public deleteClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiDeleteClusterRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteClusterRoleBindingWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ClusterRoleBinding
     * @param param the request object
     */
    public deleteClusterRoleBinding(param: RbacAuthorizationV1alpha1ApiDeleteClusterRoleBindingRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteClusterRoleBinding(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRole
     * @param param the request object
     */
    public deleteCollectionClusterRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiDeleteCollectionClusterRoleRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionClusterRoleWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRole
     * @param param the request object
     */
    public deleteCollectionClusterRole(param: RbacAuthorizationV1alpha1ApiDeleteCollectionClusterRoleRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionClusterRole(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRoleBinding
     * @param param the request object
     */
    public deleteCollectionClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiDeleteCollectionClusterRoleBindingRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionClusterRoleBindingWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRoleBinding
     * @param param the request object
     */
    public deleteCollectionClusterRoleBinding(param: RbacAuthorizationV1alpha1ApiDeleteCollectionClusterRoleBindingRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionClusterRoleBinding(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Role
     * @param param the request object
     */
    public deleteCollectionNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiDeleteCollectionNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedRoleWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Role
     * @param param the request object
     */
    public deleteCollectionNamespacedRole(param: RbacAuthorizationV1alpha1ApiDeleteCollectionNamespacedRoleRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedRole(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of RoleBinding
     * @param param the request object
     */
    public deleteCollectionNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiDeleteCollectionNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedRoleBindingWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of RoleBinding
     * @param param the request object
     */
    public deleteCollectionNamespacedRoleBinding(param: RbacAuthorizationV1alpha1ApiDeleteCollectionNamespacedRoleBindingRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedRoleBinding(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a Role
     * @param param the request object
     */
    public deleteNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiDeleteNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedRoleWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Role
     * @param param the request object
     */
    public deleteNamespacedRole(param: RbacAuthorizationV1alpha1ApiDeleteNamespacedRoleRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedRole(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a RoleBinding
     * @param param the request object
     */
    public deleteNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiDeleteNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a RoleBinding
     * @param param the request object
     */
    public deleteNamespacedRoleBinding(param: RbacAuthorizationV1alpha1ApiDeleteNamespacedRoleBindingRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedRoleBinding(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: RbacAuthorizationV1alpha1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: RbacAuthorizationV1alpha1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRole
     * @param param the request object
     */
    public listClusterRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiListClusterRoleRequest = {}, options?: Configuration): Promise<HttpInfo<V1alpha1ClusterRoleList>> {
        return this.api.listClusterRoleWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRole
     * @param param the request object
     */
    public listClusterRole(param: RbacAuthorizationV1alpha1ApiListClusterRoleRequest = {}, options?: Configuration): Promise<V1alpha1ClusterRoleList> {
        return this.api.listClusterRole(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRoleBinding
     * @param param the request object
     */
    public listClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiListClusterRoleBindingRequest = {}, options?: Configuration): Promise<HttpInfo<V1alpha1ClusterRoleBindingList>> {
        return this.api.listClusterRoleBindingWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRoleBinding
     * @param param the request object
     */
    public listClusterRoleBinding(param: RbacAuthorizationV1alpha1ApiListClusterRoleBindingRequest = {}, options?: Configuration): Promise<V1alpha1ClusterRoleBindingList> {
        return this.api.listClusterRoleBinding(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiListNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1alpha1RoleList>> {
        return this.api.listNamespacedRoleWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listNamespacedRole(param: RbacAuthorizationV1alpha1ApiListNamespacedRoleRequest, options?: Configuration): Promise<V1alpha1RoleList> {
        return this.api.listNamespacedRole(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiListNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1alpha1RoleBindingList>> {
        return this.api.listNamespacedRoleBindingWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listNamespacedRoleBinding(param: RbacAuthorizationV1alpha1ApiListNamespacedRoleBindingRequest, options?: Configuration): Promise<V1alpha1RoleBindingList> {
        return this.api.listNamespacedRoleBinding(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listRoleBindingForAllNamespacesWithHttpInfo(param: RbacAuthorizationV1alpha1ApiListRoleBindingForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1alpha1RoleBindingList>> {
        return this.api.listRoleBindingForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listRoleBindingForAllNamespaces(param: RbacAuthorizationV1alpha1ApiListRoleBindingForAllNamespacesRequest = {}, options?: Configuration): Promise<V1alpha1RoleBindingList> {
        return this.api.listRoleBindingForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listRoleForAllNamespacesWithHttpInfo(param: RbacAuthorizationV1alpha1ApiListRoleForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1alpha1RoleList>> {
        return this.api.listRoleForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listRoleForAllNamespaces(param: RbacAuthorizationV1alpha1ApiListRoleForAllNamespacesRequest = {}, options?: Configuration): Promise<V1alpha1RoleList> {
        return this.api.listRoleForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRole
     * @param param the request object
     */
    public patchClusterRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiPatchClusterRoleRequest, options?: Configuration): Promise<HttpInfo<V1alpha1ClusterRole>> {
        return this.api.patchClusterRoleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRole
     * @param param the request object
     */
    public patchClusterRole(param: RbacAuthorizationV1alpha1ApiPatchClusterRoleRequest, options?: Configuration): Promise<V1alpha1ClusterRole> {
        return this.api.patchClusterRole(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRoleBinding
     * @param param the request object
     */
    public patchClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiPatchClusterRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1alpha1ClusterRoleBinding>> {
        return this.api.patchClusterRoleBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRoleBinding
     * @param param the request object
     */
    public patchClusterRoleBinding(param: RbacAuthorizationV1alpha1ApiPatchClusterRoleBindingRequest, options?: Configuration): Promise<V1alpha1ClusterRoleBinding> {
        return this.api.patchClusterRoleBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Role
     * @param param the request object
     */
    public patchNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiPatchNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1alpha1Role>> {
        return this.api.patchNamespacedRoleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Role
     * @param param the request object
     */
    public patchNamespacedRole(param: RbacAuthorizationV1alpha1ApiPatchNamespacedRoleRequest, options?: Configuration): Promise<V1alpha1Role> {
        return this.api.patchNamespacedRole(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified RoleBinding
     * @param param the request object
     */
    public patchNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiPatchNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1alpha1RoleBinding>> {
        return this.api.patchNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified RoleBinding
     * @param param the request object
     */
    public patchNamespacedRoleBinding(param: RbacAuthorizationV1alpha1ApiPatchNamespacedRoleBindingRequest, options?: Configuration): Promise<V1alpha1RoleBinding> {
        return this.api.patchNamespacedRoleBinding(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified ClusterRole
     * @param param the request object
     */
    public readClusterRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiReadClusterRoleRequest, options?: Configuration): Promise<HttpInfo<V1alpha1ClusterRole>> {
        return this.api.readClusterRoleWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ClusterRole
     * @param param the request object
     */
    public readClusterRole(param: RbacAuthorizationV1alpha1ApiReadClusterRoleRequest, options?: Configuration): Promise<V1alpha1ClusterRole> {
        return this.api.readClusterRole(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ClusterRoleBinding
     * @param param the request object
     */
    public readClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiReadClusterRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1alpha1ClusterRoleBinding>> {
        return this.api.readClusterRoleBindingWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ClusterRoleBinding
     * @param param the request object
     */
    public readClusterRoleBinding(param: RbacAuthorizationV1alpha1ApiReadClusterRoleBindingRequest, options?: Configuration): Promise<V1alpha1ClusterRoleBinding> {
        return this.api.readClusterRoleBinding(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Role
     * @param param the request object
     */
    public readNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiReadNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1alpha1Role>> {
        return this.api.readNamespacedRoleWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Role
     * @param param the request object
     */
    public readNamespacedRole(param: RbacAuthorizationV1alpha1ApiReadNamespacedRoleRequest, options?: Configuration): Promise<V1alpha1Role> {
        return this.api.readNamespacedRole(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified RoleBinding
     * @param param the request object
     */
    public readNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiReadNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1alpha1RoleBinding>> {
        return this.api.readNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified RoleBinding
     * @param param the request object
     */
    public readNamespacedRoleBinding(param: RbacAuthorizationV1alpha1ApiReadNamespacedRoleBindingRequest, options?: Configuration): Promise<V1alpha1RoleBinding> {
        return this.api.readNamespacedRoleBinding(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified ClusterRole
     * @param param the request object
     */
    public replaceClusterRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiReplaceClusterRoleRequest, options?: Configuration): Promise<HttpInfo<V1alpha1ClusterRole>> {
        return this.api.replaceClusterRoleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ClusterRole
     * @param param the request object
     */
    public replaceClusterRole(param: RbacAuthorizationV1alpha1ApiReplaceClusterRoleRequest, options?: Configuration): Promise<V1alpha1ClusterRole> {
        return this.api.replaceClusterRole(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ClusterRoleBinding
     * @param param the request object
     */
    public replaceClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiReplaceClusterRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1alpha1ClusterRoleBinding>> {
        return this.api.replaceClusterRoleBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified ClusterRoleBinding
     * @param param the request object
     */
    public replaceClusterRoleBinding(param: RbacAuthorizationV1alpha1ApiReplaceClusterRoleBindingRequest, options?: Configuration): Promise<V1alpha1ClusterRoleBinding> {
        return this.api.replaceClusterRoleBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Role
     * @param param the request object
     */
    public replaceNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1alpha1ApiReplaceNamespacedRoleRequest, options?: Configuration): Promise<HttpInfo<V1alpha1Role>> {
        return this.api.replaceNamespacedRoleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified Role
     * @param param the request object
     */
    public replaceNamespacedRole(param: RbacAuthorizationV1alpha1ApiReplaceNamespacedRoleRequest, options?: Configuration): Promise<V1alpha1Role> {
        return this.api.replaceNamespacedRole(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified RoleBinding
     * @param param the request object
     */
    public replaceNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1alpha1ApiReplaceNamespacedRoleBindingRequest, options?: Configuration): Promise<HttpInfo<V1alpha1RoleBinding>> {
        return this.api.replaceNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified RoleBinding
     * @param param the request object
     */
    public replaceNamespacedRoleBinding(param: RbacAuthorizationV1alpha1ApiReplaceNamespacedRoleBindingRequest, options?: Configuration): Promise<V1alpha1RoleBinding> {
        return this.api.replaceNamespacedRoleBinding(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableSchedulingApi } from "./ObservableAPI";
import { SchedulingApiRequestFactory, SchedulingApiResponseProcessor} from "../apis/SchedulingApi";

export interface SchedulingApiGetAPIGroupRequest {
}

export class ObjectSchedulingApi {
    private api: ObservableSchedulingApi

    public constructor(configuration: Configuration, requestFactory?: SchedulingApiRequestFactory, responseProcessor?: SchedulingApiResponseProcessor) {
        this.api = new ObservableSchedulingApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: SchedulingApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: SchedulingApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableSchedulingV1Api } from "./ObservableAPI";
import { SchedulingV1ApiRequestFactory, SchedulingV1ApiResponseProcessor} from "../apis/SchedulingV1Api";

export interface SchedulingV1ApiCreatePriorityClassRequest {
    /**
     * 
     * @type V1PriorityClass
     * @memberof SchedulingV1ApicreatePriorityClass
     */
    body: V1PriorityClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApicreatePriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1ApicreatePriorityClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SchedulingV1ApicreatePriorityClass
     */
    fieldManager?: string
}

export interface SchedulingV1ApiDeleteCollectionPriorityClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    body?: V1DeleteOptions
}

export interface SchedulingV1ApiDeletePriorityClassRequest {
    /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1ApideletePriorityClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApideletePriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1ApideletePriorityClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SchedulingV1ApideletePriorityClass
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SchedulingV1ApideletePriorityClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SchedulingV1ApideletePriorityClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof SchedulingV1ApideletePriorityClass
     */
    body?: V1DeleteOptions
}

export interface SchedulingV1ApiGetAPIResourcesRequest {
}

export interface SchedulingV1ApiListPriorityClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof SchedulingV1ApilistPriorityClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1ApilistPriorityClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1ApilistPriorityClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SchedulingV1ApilistPriorityClass
     */
    watch?: boolean
}

export interface SchedulingV1ApiPatchPriorityClassRequest {
    /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    force?: boolean
}

export interface SchedulingV1ApiReadPriorityClassRequest {
    /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1ApireadPriorityClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApireadPriorityClass
     */
    pretty?: string
}

export interface SchedulingV1ApiReplacePriorityClassRequest {
    /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1ApireplacePriorityClass
     */
    name: string
    /**
     * 
     * @type V1PriorityClass
     * @memberof SchedulingV1ApireplacePriorityClass
     */
    body: V1PriorityClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApireplacePriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1ApireplacePriorityClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SchedulingV1ApireplacePriorityClass
     */
    fieldManager?: string
}

export class ObjectSchedulingV1Api {
    private api: ObservableSchedulingV1Api

    public constructor(configuration: Configuration, requestFactory?: SchedulingV1ApiRequestFactory, responseProcessor?: SchedulingV1ApiResponseProcessor) {
        this.api = new ObservableSchedulingV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a PriorityClass
     * @param param the request object
     */
    public createPriorityClassWithHttpInfo(param: SchedulingV1ApiCreatePriorityClassRequest, options?: Configuration): Promise<HttpInfo<V1PriorityClass>> {
        return this.api.createPriorityClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PriorityClass
     * @param param the request object
     */
    public createPriorityClass(param: SchedulingV1ApiCreatePriorityClassRequest, options?: Configuration): Promise<V1PriorityClass> {
        return this.api.createPriorityClass(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of PriorityClass
     * @param param the request object
     */
    public deleteCollectionPriorityClassWithHttpInfo(param: SchedulingV1ApiDeleteCollectionPriorityClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionPriorityClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PriorityClass
     * @param param the request object
     */
    public deleteCollectionPriorityClass(param: SchedulingV1ApiDeleteCollectionPriorityClassRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionPriorityClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a PriorityClass
     * @param param the request object
     */
    public deletePriorityClassWithHttpInfo(param: SchedulingV1ApiDeletePriorityClassRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deletePriorityClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PriorityClass
     * @param param the request object
     */
    public deletePriorityClass(param: SchedulingV1ApiDeletePriorityClassRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deletePriorityClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: SchedulingV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: SchedulingV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind PriorityClass
     * @param param the request object
     */
    public listPriorityClassWithHttpInfo(param: SchedulingV1ApiListPriorityClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1PriorityClassList>> {
        return this.api.listPriorityClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PriorityClass
     * @param param the request object
     */
    public listPriorityClass(param: SchedulingV1ApiListPriorityClassRequest = {}, options?: Configuration): Promise<V1PriorityClassList> {
        return this.api.listPriorityClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified PriorityClass
     * @param param the request object
     */
    public patchPriorityClassWithHttpInfo(param: SchedulingV1ApiPatchPriorityClassRequest, options?: Configuration): Promise<HttpInfo<V1PriorityClass>> {
        return this.api.patchPriorityClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PriorityClass
     * @param param the request object
     */
    public patchPriorityClass(param: SchedulingV1ApiPatchPriorityClassRequest, options?: Configuration): Promise<V1PriorityClass> {
        return this.api.patchPriorityClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified PriorityClass
     * @param param the request object
     */
    public readPriorityClassWithHttpInfo(param: SchedulingV1ApiReadPriorityClassRequest, options?: Configuration): Promise<HttpInfo<V1PriorityClass>> {
        return this.api.readPriorityClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PriorityClass
     * @param param the request object
     */
    public readPriorityClass(param: SchedulingV1ApiReadPriorityClassRequest, options?: Configuration): Promise<V1PriorityClass> {
        return this.api.readPriorityClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified PriorityClass
     * @param param the request object
     */
    public replacePriorityClassWithHttpInfo(param: SchedulingV1ApiReplacePriorityClassRequest, options?: Configuration): Promise<HttpInfo<V1PriorityClass>> {
        return this.api.replacePriorityClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PriorityClass
     * @param param the request object
     */
    public replacePriorityClass(param: SchedulingV1ApiReplacePriorityClassRequest, options?: Configuration): Promise<V1PriorityClass> {
        return this.api.replacePriorityClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableSchedulingV1alpha1Api } from "./ObservableAPI";
import { SchedulingV1alpha1ApiRequestFactory, SchedulingV1alpha1ApiResponseProcessor} from "../apis/SchedulingV1alpha1Api";

export interface SchedulingV1alpha1ApiCreatePriorityClassRequest {
    /**
     * 
     * @type V1alpha1PriorityClass
     * @memberof SchedulingV1alpha1ApicreatePriorityClass
     */
    body: V1alpha1PriorityClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApicreatePriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1alpha1ApicreatePriorityClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SchedulingV1alpha1ApicreatePriorityClass
     */
    fieldManager?: string
}

export interface SchedulingV1alpha1ApiDeleteCollectionPriorityClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof SchedulingV1alpha1ApideleteCollectionPriorityClass
     */
    body?: V1DeleteOptions
}

export interface SchedulingV1alpha1ApiDeletePriorityClassRequest {
    /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1alpha1ApideletePriorityClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApideletePriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1alpha1ApideletePriorityClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SchedulingV1alpha1ApideletePriorityClass
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SchedulingV1alpha1ApideletePriorityClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SchedulingV1alpha1ApideletePriorityClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof SchedulingV1alpha1ApideletePriorityClass
     */
    body?: V1DeleteOptions
}

export interface SchedulingV1alpha1ApiGetAPIResourcesRequest {
}

export interface SchedulingV1alpha1ApiListPriorityClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApilistPriorityClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof SchedulingV1alpha1ApilistPriorityClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1alpha1ApilistPriorityClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApilistPriorityClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApilistPriorityClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1alpha1ApilistPriorityClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApilistPriorityClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApilistPriorityClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1alpha1ApilistPriorityClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SchedulingV1alpha1ApilistPriorityClass
     */
    watch?: boolean
}

export interface SchedulingV1alpha1ApiPatchPriorityClassRequest {
    /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1alpha1ApipatchPriorityClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof SchedulingV1alpha1ApipatchPriorityClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApipatchPriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1alpha1ApipatchPriorityClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof SchedulingV1alpha1ApipatchPriorityClass
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof SchedulingV1alpha1ApipatchPriorityClass
     */
    force?: boolean
}

export interface SchedulingV1alpha1ApiReadPriorityClassRequest {
    /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1alpha1ApireadPriorityClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApireadPriorityClass
     */
    pretty?: string
}

export interface SchedulingV1alpha1ApiReplacePriorityClassRequest {
    /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1alpha1ApireplacePriorityClass
     */
    name: string
    /**
     * 
     * @type V1alpha1PriorityClass
     * @memberof SchedulingV1alpha1ApireplacePriorityClass
     */
    body: V1alpha1PriorityClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApireplacePriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1alpha1ApireplacePriorityClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SchedulingV1alpha1ApireplacePriorityClass
     */
    fieldManager?: string
}

export class ObjectSchedulingV1alpha1Api {
    private api: ObservableSchedulingV1alpha1Api

    public constructor(configuration: Configuration, requestFactory?: SchedulingV1alpha1ApiRequestFactory, responseProcessor?: SchedulingV1alpha1ApiResponseProcessor) {
        this.api = new ObservableSchedulingV1alpha1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a PriorityClass
     * @param param the request object
     */
    public createPriorityClassWithHttpInfo(param: SchedulingV1alpha1ApiCreatePriorityClassRequest, options?: Configuration): Promise<HttpInfo<V1alpha1PriorityClass>> {
        return this.api.createPriorityClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a PriorityClass
     * @param param the request object
     */
    public createPriorityClass(param: SchedulingV1alpha1ApiCreatePriorityClassRequest, options?: Configuration): Promise<V1alpha1PriorityClass> {
        return this.api.createPriorityClass(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of PriorityClass
     * @param param the request object
     */
    public deleteCollectionPriorityClassWithHttpInfo(param: SchedulingV1alpha1ApiDeleteCollectionPriorityClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionPriorityClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PriorityClass
     * @param param the request object
     */
    public deleteCollectionPriorityClass(param: SchedulingV1alpha1ApiDeleteCollectionPriorityClassRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionPriorityClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a PriorityClass
     * @param param the request object
     */
    public deletePriorityClassWithHttpInfo(param: SchedulingV1alpha1ApiDeletePriorityClassRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deletePriorityClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PriorityClass
     * @param param the request object
     */
    public deletePriorityClass(param: SchedulingV1alpha1ApiDeletePriorityClassRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deletePriorityClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: SchedulingV1alpha1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: SchedulingV1alpha1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind PriorityClass
     * @param param the request object
     */
    public listPriorityClassWithHttpInfo(param: SchedulingV1alpha1ApiListPriorityClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1alpha1PriorityClassList>> {
        return this.api.listPriorityClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PriorityClass
     * @param param the request object
     */
    public listPriorityClass(param: SchedulingV1alpha1ApiListPriorityClassRequest = {}, options?: Configuration): Promise<V1alpha1PriorityClassList> {
        return this.api.listPriorityClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified PriorityClass
     * @param param the request object
     */
    public patchPriorityClassWithHttpInfo(param: SchedulingV1alpha1ApiPatchPriorityClassRequest, options?: Configuration): Promise<HttpInfo<V1alpha1PriorityClass>> {
        return this.api.patchPriorityClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PriorityClass
     * @param param the request object
     */
    public patchPriorityClass(param: SchedulingV1alpha1ApiPatchPriorityClassRequest, options?: Configuration): Promise<V1alpha1PriorityClass> {
        return this.api.patchPriorityClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified PriorityClass
     * @param param the request object
     */
    public readPriorityClassWithHttpInfo(param: SchedulingV1alpha1ApiReadPriorityClassRequest, options?: Configuration): Promise<HttpInfo<V1alpha1PriorityClass>> {
        return this.api.readPriorityClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PriorityClass
     * @param param the request object
     */
    public readPriorityClass(param: SchedulingV1alpha1ApiReadPriorityClassRequest, options?: Configuration): Promise<V1alpha1PriorityClass> {
        return this.api.readPriorityClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified PriorityClass
     * @param param the request object
     */
    public replacePriorityClassWithHttpInfo(param: SchedulingV1alpha1ApiReplacePriorityClassRequest, options?: Configuration): Promise<HttpInfo<V1alpha1PriorityClass>> {
        return this.api.replacePriorityClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified PriorityClass
     * @param param the request object
     */
    public replacePriorityClass(param: SchedulingV1alpha1ApiReplacePriorityClassRequest, options?: Configuration): Promise<V1alpha1PriorityClass> {
        return this.api.replacePriorityClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableStorageApi } from "./ObservableAPI";
import { StorageApiRequestFactory, StorageApiResponseProcessor} from "../apis/StorageApi";

export interface StorageApiGetAPIGroupRequest {
}

export class ObjectStorageApi {
    private api: ObservableStorageApi

    public constructor(configuration: Configuration, requestFactory?: StorageApiRequestFactory, responseProcessor?: StorageApiResponseProcessor) {
        this.api = new ObservableStorageApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: StorageApiGetAPIGroupRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: StorageApiGetAPIGroupRequest = {}, options?: Configuration): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableStorageV1Api } from "./ObservableAPI";
import { StorageV1ApiRequestFactory, StorageV1ApiResponseProcessor} from "../apis/StorageV1Api";

export interface StorageV1ApiCreateCSIDriverRequest {
    /**
     * 
     * @type V1CSIDriver
     * @memberof StorageV1ApicreateCSIDriver
     */
    body: V1CSIDriver
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApicreateCSIDriver
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApicreateCSIDriver
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApicreateCSIDriver
     */
    fieldManager?: string
}

export interface StorageV1ApiCreateCSINodeRequest {
    /**
     * 
     * @type V1CSINode
     * @memberof StorageV1ApicreateCSINode
     */
    body: V1CSINode
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApicreateCSINode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApicreateCSINode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApicreateCSINode
     */
    fieldManager?: string
}

export interface StorageV1ApiCreateStorageClassRequest {
    /**
     * 
     * @type V1StorageClass
     * @memberof StorageV1ApicreateStorageClass
     */
    body: V1StorageClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApicreateStorageClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApicreateStorageClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApicreateStorageClass
     */
    fieldManager?: string
}

export interface StorageV1ApiCreateVolumeAttachmentRequest {
    /**
     * 
     * @type V1VolumeAttachment
     * @memberof StorageV1ApicreateVolumeAttachment
     */
    body: V1VolumeAttachment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApicreateVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApicreateVolumeAttachment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApicreateVolumeAttachment
     */
    fieldManager?: string
}

export interface StorageV1ApiDeleteCSIDriverRequest {
    /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1ApideleteCSIDriver
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteCSIDriver
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteCSIDriver
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteCSIDriver
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteCSIDriver
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteCSIDriver
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCSIDriver
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteCSINodeRequest {
    /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1ApideleteCSINode
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteCSINode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteCSINode
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteCSINode
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteCSINode
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteCSINode
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCSINode
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteCollectionCSIDriverRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteCollectionCSINodeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteCollectionStorageClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteCollectionVolumeAttachmentRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteStorageClassRequest {
    /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1ApideleteStorageClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteStorageClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteStorageClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteStorageClass
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteStorageClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteStorageClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteStorageClass
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiGetAPIResourcesRequest {
}

export interface StorageV1ApiListCSIDriverRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApilistCSIDriver
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApilistCSIDriver
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApilistCSIDriver
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApilistCSIDriver
     */
    watch?: boolean
}

export interface StorageV1ApiListCSINodeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApilistCSINode
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApilistCSINode
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApilistCSINode
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApilistCSINode
     */
    watch?: boolean
}

export interface StorageV1ApiListStorageClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApilistStorageClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApilistStorageClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApilistStorageClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApilistStorageClass
     */
    watch?: boolean
}

export interface StorageV1ApiListVolumeAttachmentRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApilistVolumeAttachment
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApilistVolumeAttachment
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApilistVolumeAttachment
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApilistVolumeAttachment
     */
    watch?: boolean
}

export interface StorageV1ApiPatchCSIDriverRequest {
    /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1ApipatchCSIDriver
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1ApipatchCSIDriver
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApipatchCSIDriver
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApipatchCSIDriver
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1ApipatchCSIDriver
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1ApipatchCSIDriver
     */
    force?: boolean
}

export interface StorageV1ApiPatchCSINodeRequest {
    /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1ApipatchCSINode
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1ApipatchCSINode
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApipatchCSINode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApipatchCSINode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1ApipatchCSINode
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1ApipatchCSINode
     */
    force?: boolean
}

export interface StorageV1ApiPatchStorageClassRequest {
    /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1ApipatchStorageClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1ApipatchStorageClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApipatchStorageClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApipatchStorageClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1ApipatchStorageClass
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1ApipatchStorageClass
     */
    force?: boolean
}

export interface StorageV1ApiPatchVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    force?: boolean
}

export interface StorageV1ApiPatchVolumeAttachmentStatusRequest {
    /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    force?: boolean
}

export interface StorageV1ApiReadCSIDriverRequest {
    /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1ApireadCSIDriver
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireadCSIDriver
     */
    pretty?: string
}

export interface StorageV1ApiReadCSINodeRequest {
    /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1ApireadCSINode
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireadCSINode
     */
    pretty?: string
}

export interface StorageV1ApiReadStorageClassRequest {
    /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1ApireadStorageClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireadStorageClass
     */
    pretty?: string
}

export interface StorageV1ApiReadVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApireadVolumeAttachment
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireadVolumeAttachment
     */
    pretty?: string
}

export interface StorageV1ApiReadVolumeAttachmentStatusRequest {
    /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApireadVolumeAttachmentStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireadVolumeAttachmentStatus
     */
    pretty?: string
}

export interface StorageV1ApiReplaceCSIDriverRequest {
    /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1ApireplaceCSIDriver
     */
    name: string
    /**
     * 
     * @type V1CSIDriver
     * @memberof StorageV1ApireplaceCSIDriver
     */
    body: V1CSIDriver
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireplaceCSIDriver
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApireplaceCSIDriver
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApireplaceCSIDriver
     */
    fieldManager?: string
}

export interface StorageV1ApiReplaceCSINodeRequest {
    /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1ApireplaceCSINode
     */
    name: string
    /**
     * 
     * @type V1CSINode
     * @memberof StorageV1ApireplaceCSINode
     */
    body: V1CSINode
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireplaceCSINode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApireplaceCSINode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApireplaceCSINode
     */
    fieldManager?: string
}

export interface StorageV1ApiReplaceStorageClassRequest {
    /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1ApireplaceStorageClass
     */
    name: string
    /**
     * 
     * @type V1StorageClass
     * @memberof StorageV1ApireplaceStorageClass
     */
    body: V1StorageClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireplaceStorageClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApireplaceStorageClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApireplaceStorageClass
     */
    fieldManager?: string
}

export interface StorageV1ApiReplaceVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachment
     */
    name: string
    /**
     * 
     * @type V1VolumeAttachment
     * @memberof StorageV1ApireplaceVolumeAttachment
     */
    body: V1VolumeAttachment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachment
     */
    fieldManager?: string
}

export interface StorageV1ApiReplaceVolumeAttachmentStatusRequest {
    /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachmentStatus
     */
    name: string
    /**
     * 
     * @type V1VolumeAttachment
     * @memberof StorageV1ApireplaceVolumeAttachmentStatus
     */
    body: V1VolumeAttachment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachmentStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachmentStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachmentStatus
     */
    fieldManager?: string
}

export class ObjectStorageV1Api {
    private api: ObservableStorageV1Api

    public constructor(configuration: Configuration, requestFactory?: StorageV1ApiRequestFactory, responseProcessor?: StorageV1ApiResponseProcessor) {
        this.api = new ObservableStorageV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a CSIDriver
     * @param param the request object
     */
    public createCSIDriverWithHttpInfo(param: StorageV1ApiCreateCSIDriverRequest, options?: Configuration): Promise<HttpInfo<V1CSIDriver>> {
        return this.api.createCSIDriverWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a CSIDriver
     * @param param the request object
     */
    public createCSIDriver(param: StorageV1ApiCreateCSIDriverRequest, options?: Configuration): Promise<V1CSIDriver> {
        return this.api.createCSIDriver(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a CSINode
     * @param param the request object
     */
    public createCSINodeWithHttpInfo(param: StorageV1ApiCreateCSINodeRequest, options?: Configuration): Promise<HttpInfo<V1CSINode>> {
        return this.api.createCSINodeWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a CSINode
     * @param param the request object
     */
    public createCSINode(param: StorageV1ApiCreateCSINodeRequest, options?: Configuration): Promise<V1CSINode> {
        return this.api.createCSINode(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a StorageClass
     * @param param the request object
     */
    public createStorageClassWithHttpInfo(param: StorageV1ApiCreateStorageClassRequest, options?: Configuration): Promise<HttpInfo<V1StorageClass>> {
        return this.api.createStorageClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a StorageClass
     * @param param the request object
     */
    public createStorageClass(param: StorageV1ApiCreateStorageClassRequest, options?: Configuration): Promise<V1StorageClass> {
        return this.api.createStorageClass(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a VolumeAttachment
     * @param param the request object
     */
    public createVolumeAttachmentWithHttpInfo(param: StorageV1ApiCreateVolumeAttachmentRequest, options?: Configuration): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.createVolumeAttachmentWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a VolumeAttachment
     * @param param the request object
     */
    public createVolumeAttachment(param: StorageV1ApiCreateVolumeAttachmentRequest, options?: Configuration): Promise<V1VolumeAttachment> {
        return this.api.createVolumeAttachment(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete a CSIDriver
     * @param param the request object
     */
    public deleteCSIDriverWithHttpInfo(param: StorageV1ApiDeleteCSIDriverRequest, options?: Configuration): Promise<HttpInfo<V1CSIDriver>> {
        return this.api.deleteCSIDriverWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CSIDriver
     * @param param the request object
     */
    public deleteCSIDriver(param: StorageV1ApiDeleteCSIDriverRequest, options?: Configuration): Promise<V1CSIDriver> {
        return this.api.deleteCSIDriver(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CSINode
     * @param param the request object
     */
    public deleteCSINodeWithHttpInfo(param: StorageV1ApiDeleteCSINodeRequest, options?: Configuration): Promise<HttpInfo<V1CSINode>> {
        return this.api.deleteCSINodeWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CSINode
     * @param param the request object
     */
    public deleteCSINode(param: StorageV1ApiDeleteCSINodeRequest, options?: Configuration): Promise<V1CSINode> {
        return this.api.deleteCSINode(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSIDriver
     * @param param the request object
     */
    public deleteCollectionCSIDriverWithHttpInfo(param: StorageV1ApiDeleteCollectionCSIDriverRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionCSIDriverWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSIDriver
     * @param param the request object
     */
    public deleteCollectionCSIDriver(param: StorageV1ApiDeleteCollectionCSIDriverRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionCSIDriver(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSINode
     * @param param the request object
     */
    public deleteCollectionCSINodeWithHttpInfo(param: StorageV1ApiDeleteCollectionCSINodeRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionCSINodeWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSINode
     * @param param the request object
     */
    public deleteCollectionCSINode(param: StorageV1ApiDeleteCollectionCSINodeRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionCSINode(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of StorageClass
     * @param param the request object
     */
    public deleteCollectionStorageClassWithHttpInfo(param: StorageV1ApiDeleteCollectionStorageClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionStorageClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of StorageClass
     * @param param the request object
     */
    public deleteCollectionStorageClass(param: StorageV1ApiDeleteCollectionStorageClassRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionStorageClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of VolumeAttachment
     * @param param the request object
     */
    public deleteCollectionVolumeAttachmentWithHttpInfo(param: StorageV1ApiDeleteCollectionVolumeAttachmentRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionVolumeAttachmentWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of VolumeAttachment
     * @param param the request object
     */
    public deleteCollectionVolumeAttachment(param: StorageV1ApiDeleteCollectionVolumeAttachmentRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionVolumeAttachment(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a StorageClass
     * @param param the request object
     */
    public deleteStorageClassWithHttpInfo(param: StorageV1ApiDeleteStorageClassRequest, options?: Configuration): Promise<HttpInfo<V1StorageClass>> {
        return this.api.deleteStorageClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a StorageClass
     * @param param the request object
     */
    public deleteStorageClass(param: StorageV1ApiDeleteStorageClassRequest, options?: Configuration): Promise<V1StorageClass> {
        return this.api.deleteStorageClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a VolumeAttachment
     * @param param the request object
     */
    public deleteVolumeAttachmentWithHttpInfo(param: StorageV1ApiDeleteVolumeAttachmentRequest, options?: Configuration): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.deleteVolumeAttachmentWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a VolumeAttachment
     * @param param the request object
     */
    public deleteVolumeAttachment(param: StorageV1ApiDeleteVolumeAttachmentRequest, options?: Configuration): Promise<V1VolumeAttachment> {
        return this.api.deleteVolumeAttachment(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: StorageV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: StorageV1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind CSIDriver
     * @param param the request object
     */
    public listCSIDriverWithHttpInfo(param: StorageV1ApiListCSIDriverRequest = {}, options?: Configuration): Promise<HttpInfo<V1CSIDriverList>> {
        return this.api.listCSIDriverWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIDriver
     * @param param the request object
     */
    public listCSIDriver(param: StorageV1ApiListCSIDriverRequest = {}, options?: Configuration): Promise<V1CSIDriverList> {
        return this.api.listCSIDriver(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSINode
     * @param param the request object
     */
    public listCSINodeWithHttpInfo(param: StorageV1ApiListCSINodeRequest = {}, options?: Configuration): Promise<HttpInfo<V1CSINodeList>> {
        return this.api.listCSINodeWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSINode
     * @param param the request object
     */
    public listCSINode(param: StorageV1ApiListCSINodeRequest = {}, options?: Configuration): Promise<V1CSINodeList> {
        return this.api.listCSINode(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StorageClass
     * @param param the request object
     */
    public listStorageClassWithHttpInfo(param: StorageV1ApiListStorageClassRequest = {}, options?: Configuration): Promise<HttpInfo<V1StorageClassList>> {
        return this.api.listStorageClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StorageClass
     * @param param the request object
     */
    public listStorageClass(param: StorageV1ApiListStorageClassRequest = {}, options?: Configuration): Promise<V1StorageClassList> {
        return this.api.listStorageClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind VolumeAttachment
     * @param param the request object
     */
    public listVolumeAttachmentWithHttpInfo(param: StorageV1ApiListVolumeAttachmentRequest = {}, options?: Configuration): Promise<HttpInfo<V1VolumeAttachmentList>> {
        return this.api.listVolumeAttachmentWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind VolumeAttachment
     * @param param the request object
     */
    public listVolumeAttachment(param: StorageV1ApiListVolumeAttachmentRequest = {}, options?: Configuration): Promise<V1VolumeAttachmentList> {
        return this.api.listVolumeAttachment(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified CSIDriver
     * @param param the request object
     */
    public patchCSIDriverWithHttpInfo(param: StorageV1ApiPatchCSIDriverRequest, options?: Configuration): Promise<HttpInfo<V1CSIDriver>> {
        return this.api.patchCSIDriverWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CSIDriver
     * @param param the request object
     */
    public patchCSIDriver(param: StorageV1ApiPatchCSIDriverRequest, options?: Configuration): Promise<V1CSIDriver> {
        return this.api.patchCSIDriver(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CSINode
     * @param param the request object
     */
    public patchCSINodeWithHttpInfo(param: StorageV1ApiPatchCSINodeRequest, options?: Configuration): Promise<HttpInfo<V1CSINode>> {
        return this.api.patchCSINodeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CSINode
     * @param param the request object
     */
    public patchCSINode(param: StorageV1ApiPatchCSINodeRequest, options?: Configuration): Promise<V1CSINode> {
        return this.api.patchCSINode(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified StorageClass
     * @param param the request object
     */
    public patchStorageClassWithHttpInfo(param: StorageV1ApiPatchStorageClassRequest, options?: Configuration): Promise<HttpInfo<V1StorageClass>> {
        return this.api.patchStorageClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified StorageClass
     * @param param the request object
     */
    public patchStorageClass(param: StorageV1ApiPatchStorageClassRequest, options?: Configuration): Promise<V1StorageClass> {
        return this.api.patchStorageClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified VolumeAttachment
     * @param param the request object
     */
    public patchVolumeAttachmentWithHttpInfo(param: StorageV1ApiPatchVolumeAttachmentRequest, options?: Configuration): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.patchVolumeAttachmentWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified VolumeAttachment
     * @param param the request object
     */
    public patchVolumeAttachment(param: StorageV1ApiPatchVolumeAttachmentRequest, options?: Configuration): Promise<V1VolumeAttachment> {
        return this.api.patchVolumeAttachment(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified VolumeAttachment
     * @param param the request object
     */
    public patchVolumeAttachmentStatusWithHttpInfo(param: StorageV1ApiPatchVolumeAttachmentStatusRequest, options?: Configuration): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.patchVolumeAttachmentStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified VolumeAttachment
     * @param param the request object
     */
    public patchVolumeAttachmentStatus(param: StorageV1ApiPatchVolumeAttachmentStatusRequest, options?: Configuration): Promise<V1VolumeAttachment> {
        return this.api.patchVolumeAttachmentStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified CSIDriver
     * @param param the request object
     */
    public readCSIDriverWithHttpInfo(param: StorageV1ApiReadCSIDriverRequest, options?: Configuration): Promise<HttpInfo<V1CSIDriver>> {
        return this.api.readCSIDriverWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CSIDriver
     * @param param the request object
     */
    public readCSIDriver(param: StorageV1ApiReadCSIDriverRequest, options?: Configuration): Promise<V1CSIDriver> {
        return this.api.readCSIDriver(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CSINode
     * @param param the request object
     */
    public readCSINodeWithHttpInfo(param: StorageV1ApiReadCSINodeRequest, options?: Configuration): Promise<HttpInfo<V1CSINode>> {
        return this.api.readCSINodeWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CSINode
     * @param param the request object
     */
    public readCSINode(param: StorageV1ApiReadCSINodeRequest, options?: Configuration): Promise<V1CSINode> {
        return this.api.readCSINode(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified StorageClass
     * @param param the request object
     */
    public readStorageClassWithHttpInfo(param: StorageV1ApiReadStorageClassRequest, options?: Configuration): Promise<HttpInfo<V1StorageClass>> {
        return this.api.readStorageClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified StorageClass
     * @param param the request object
     */
    public readStorageClass(param: StorageV1ApiReadStorageClassRequest, options?: Configuration): Promise<V1StorageClass> {
        return this.api.readStorageClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified VolumeAttachment
     * @param param the request object
     */
    public readVolumeAttachmentWithHttpInfo(param: StorageV1ApiReadVolumeAttachmentRequest, options?: Configuration): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.readVolumeAttachmentWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified VolumeAttachment
     * @param param the request object
     */
    public readVolumeAttachment(param: StorageV1ApiReadVolumeAttachmentRequest, options?: Configuration): Promise<V1VolumeAttachment> {
        return this.api.readVolumeAttachment(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified VolumeAttachment
     * @param param the request object
     */
    public readVolumeAttachmentStatusWithHttpInfo(param: StorageV1ApiReadVolumeAttachmentStatusRequest, options?: Configuration): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.readVolumeAttachmentStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified VolumeAttachment
     * @param param the request object
     */
    public readVolumeAttachmentStatus(param: StorageV1ApiReadVolumeAttachmentStatusRequest, options?: Configuration): Promise<V1VolumeAttachment> {
        return this.api.readVolumeAttachmentStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified CSIDriver
     * @param param the request object
     */
    public replaceCSIDriverWithHttpInfo(param: StorageV1ApiReplaceCSIDriverRequest, options?: Configuration): Promise<HttpInfo<V1CSIDriver>> {
        return this.api.replaceCSIDriverWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified CSIDriver
     * @param param the request object
     */
    public replaceCSIDriver(param: StorageV1ApiReplaceCSIDriverRequest, options?: Configuration): Promise<V1CSIDriver> {
        return this.api.replaceCSIDriver(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified CSINode
     * @param param the request object
     */
    public replaceCSINodeWithHttpInfo(param: StorageV1ApiReplaceCSINodeRequest, options?: Configuration): Promise<HttpInfo<V1CSINode>> {
        return this.api.replaceCSINodeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified CSINode
     * @param param the request object
     */
    public replaceCSINode(param: StorageV1ApiReplaceCSINodeRequest, options?: Configuration): Promise<V1CSINode> {
        return this.api.replaceCSINode(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified StorageClass
     * @param param the request object
     */
    public replaceStorageClassWithHttpInfo(param: StorageV1ApiReplaceStorageClassRequest, options?: Configuration): Promise<HttpInfo<V1StorageClass>> {
        return this.api.replaceStorageClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified StorageClass
     * @param param the request object
     */
    public replaceStorageClass(param: StorageV1ApiReplaceStorageClassRequest, options?: Configuration): Promise<V1StorageClass> {
        return this.api.replaceStorageClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified VolumeAttachment
     * @param param the request object
     */
    public replaceVolumeAttachmentWithHttpInfo(param: StorageV1ApiReplaceVolumeAttachmentRequest, options?: Configuration): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.replaceVolumeAttachmentWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified VolumeAttachment
     * @param param the request object
     */
    public replaceVolumeAttachment(param: StorageV1ApiReplaceVolumeAttachmentRequest, options?: Configuration): Promise<V1VolumeAttachment> {
        return this.api.replaceVolumeAttachment(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified VolumeAttachment
     * @param param the request object
     */
    public replaceVolumeAttachmentStatusWithHttpInfo(param: StorageV1ApiReplaceVolumeAttachmentStatusRequest, options?: Configuration): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.replaceVolumeAttachmentStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace status of the specified VolumeAttachment
     * @param param the request object
     */
    public replaceVolumeAttachmentStatus(param: StorageV1ApiReplaceVolumeAttachmentStatusRequest, options?: Configuration): Promise<V1VolumeAttachment> {
        return this.api.replaceVolumeAttachmentStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableStorageV1alpha1Api } from "./ObservableAPI";
import { StorageV1alpha1ApiRequestFactory, StorageV1alpha1ApiResponseProcessor} from "../apis/StorageV1alpha1Api";

export interface StorageV1alpha1ApiCreateNamespacedCSIStorageCapacityRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1alpha1ApicreateNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * 
     * @type V1alpha1CSIStorageCapacity
     * @memberof StorageV1alpha1ApicreateNamespacedCSIStorageCapacity
     */
    body: V1alpha1CSIStorageCapacity
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApicreateNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApicreateNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1alpha1ApicreateNamespacedCSIStorageCapacity
     */
    fieldManager?: string
}

export interface StorageV1alpha1ApiCreateVolumeAttachmentRequest {
    /**
     * 
     * @type V1alpha1VolumeAttachment
     * @memberof StorageV1alpha1ApicreateVolumeAttachment
     */
    body: V1alpha1VolumeAttachment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApicreateVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApicreateVolumeAttachment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1alpha1ApicreateVolumeAttachment
     */
    fieldManager?: string
}

export interface StorageV1alpha1ApiDeleteCollectionNamespacedCSIStorageCapacityRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1alpha1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    body?: V1DeleteOptions
}

export interface StorageV1alpha1ApiDeleteCollectionVolumeAttachmentRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttachment
     */
    body?: V1DeleteOptions
}

export interface StorageV1alpha1ApiDeleteNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * @type string
     * @memberof StorageV1alpha1ApideleteNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1alpha1ApideleteNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApideleteNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApideleteNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1alpha1ApideleteNamespacedCSIStorageCapacity
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1alpha1ApideleteNamespacedCSIStorageCapacity
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1alpha1ApideleteNamespacedCSIStorageCapacity
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1alpha1ApideleteNamespacedCSIStorageCapacity
     */
    body?: V1DeleteOptions
}

export interface StorageV1alpha1ApiDeleteVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1alpha1ApideleteVolumeAttachment
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApideleteVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApideleteVolumeAttachment
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1alpha1ApideleteVolumeAttachment
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1alpha1ApideleteVolumeAttachment
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1alpha1ApideleteVolumeAttachment
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1alpha1ApideleteVolumeAttachment
     */
    body?: V1DeleteOptions
}

export interface StorageV1alpha1ApiGetAPIResourcesRequest {
}

export interface StorageV1alpha1ApiListCSIStorageCapacityForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof StorageV1alpha1ApilistCSIStorageCapacityForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1alpha1ApilistCSIStorageCapacityForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApilistCSIStorageCapacityForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApilistCSIStorageCapacityForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1alpha1ApilistCSIStorageCapacityForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApilistCSIStorageCapacityForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApilistCSIStorageCapacityForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApilistCSIStorageCapacityForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1alpha1ApilistCSIStorageCapacityForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1alpha1ApilistCSIStorageCapacityForAllNamespaces
     */
    watch?: boolean
}

export interface StorageV1alpha1ApiListNamespacedCSIStorageCapacityRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1alpha1ApilistNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApilistNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof StorageV1alpha1ApilistNamespacedCSIStorageCapacity
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1alpha1ApilistNamespacedCSIStorageCapacity
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApilistNamespacedCSIStorageCapacity
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApilistNamespacedCSIStorageCapacity
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1alpha1ApilistNamespacedCSIStorageCapacity
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApilistNamespacedCSIStorageCapacity
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApilistNamespacedCSIStorageCapacity
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1alpha1ApilistNamespacedCSIStorageCapacity
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1alpha1ApilistNamespacedCSIStorageCapacity
     */
    watch?: boolean
}

export interface StorageV1alpha1ApiListVolumeAttachmentRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttachment
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof StorageV1alpha1ApilistVolumeAttachment
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttachment
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttachment
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttachment
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1alpha1ApilistVolumeAttachment
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttachment
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttachment
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1alpha1ApilistVolumeAttachment
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1alpha1ApilistVolumeAttachment
     */
    watch?: boolean
}

export interface StorageV1alpha1ApiPatchNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * @type string
     * @memberof StorageV1alpha1ApipatchNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1alpha1ApipatchNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof StorageV1alpha1ApipatchNamespacedCSIStorageCapacity
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApipatchNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApipatchNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1alpha1ApipatchNamespacedCSIStorageCapacity
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1alpha1ApipatchNamespacedCSIStorageCapacity
     */
    force?: boolean
}

export interface StorageV1alpha1ApiPatchVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1alpha1ApipatchVolumeAttachment
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1alpha1ApipatchVolumeAttachment
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApipatchVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApipatchVolumeAttachment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1alpha1ApipatchVolumeAttachment
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1alpha1ApipatchVolumeAttachment
     */
    force?: boolean
}

export interface StorageV1alpha1ApiReadNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * @type string
     * @memberof StorageV1alpha1ApireadNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1alpha1ApireadNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApireadNamespacedCSIStorageCapacity
     */
    pretty?: string
}

export interface StorageV1alpha1ApiReadVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1alpha1ApireadVolumeAttachment
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApireadVolumeAttachment
     */
    pretty?: string
}

export interface StorageV1alpha1ApiReplaceNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * @type string
     * @memberof StorageV1alpha1ApireplaceNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1alpha1ApireplaceNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * 
     * @type V1alpha1CSIStorageCapacity
     * @memberof StorageV1alpha1ApireplaceNamespacedCSIStorageCapacity
     */
    body: V1alpha1CSIStorageCapacity
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApireplaceNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApireplaceNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1alpha1ApireplaceNamespacedCSIStorageCapacity
     */
    fieldManager?: string
}

export interface StorageV1alpha1ApiReplaceVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1alpha1ApireplaceVolumeAttachment
     */
    name: string
    /**
     * 
     * @type V1alpha1VolumeAttachment
     * @memberof StorageV1alpha1ApireplaceVolumeAttachment
     */
    body: V1alpha1VolumeAttachment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApireplaceVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApireplaceVolumeAttachment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1alpha1ApireplaceVolumeAttachment
     */
    fieldManager?: string
}

export class ObjectStorageV1alpha1Api {
    private api: ObservableStorageV1alpha1Api

    public constructor(configuration: Configuration, requestFactory?: StorageV1alpha1ApiRequestFactory, responseProcessor?: StorageV1alpha1ApiResponseProcessor) {
        this.api = new ObservableStorageV1alpha1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a CSIStorageCapacity
     * @param param the request object
     */
    public createNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1alpha1ApiCreateNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1alpha1CSIStorageCapacity>> {
        return this.api.createNamespacedCSIStorageCapacityWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a CSIStorageCapacity
     * @param param the request object
     */
    public createNamespacedCSIStorageCapacity(param: StorageV1alpha1ApiCreateNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1alpha1CSIStorageCapacity> {
        return this.api.createNamespacedCSIStorageCapacity(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a VolumeAttachment
     * @param param the request object
     */
    public createVolumeAttachmentWithHttpInfo(param: StorageV1alpha1ApiCreateVolumeAttachmentRequest, options?: Configuration): Promise<HttpInfo<V1alpha1VolumeAttachment>> {
        return this.api.createVolumeAttachmentWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a VolumeAttachment
     * @param param the request object
     */
    public createVolumeAttachment(param: StorageV1alpha1ApiCreateVolumeAttachmentRequest, options?: Configuration): Promise<V1alpha1VolumeAttachment> {
        return this.api.createVolumeAttachment(param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of CSIStorageCapacity
     * @param param the request object
     */
    public deleteCollectionNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1alpha1ApiDeleteCollectionNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedCSIStorageCapacityWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSIStorageCapacity
     * @param param the request object
     */
    public deleteCollectionNamespacedCSIStorageCapacity(param: StorageV1alpha1ApiDeleteCollectionNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedCSIStorageCapacity(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of VolumeAttachment
     * @param param the request object
     */
    public deleteCollectionVolumeAttachmentWithHttpInfo(param: StorageV1alpha1ApiDeleteCollectionVolumeAttachmentRequest = {}, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionVolumeAttachmentWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of VolumeAttachment
     * @param param the request object
     */
    public deleteCollectionVolumeAttachment(param: StorageV1alpha1ApiDeleteCollectionVolumeAttachmentRequest = {}, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionVolumeAttachment(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a CSIStorageCapacity
     * @param param the request object
     */
    public deleteNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1alpha1ApiDeleteNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CSIStorageCapacity
     * @param param the request object
     */
    public deleteNamespacedCSIStorageCapacity(param: StorageV1alpha1ApiDeleteNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedCSIStorageCapacity(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a VolumeAttachment
     * @param param the request object
     */
    public deleteVolumeAttachmentWithHttpInfo(param: StorageV1alpha1ApiDeleteVolumeAttachmentRequest, options?: Configuration): Promise<HttpInfo<V1alpha1VolumeAttachment>> {
        return this.api.deleteVolumeAttachmentWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a VolumeAttachment
     * @param param the request object
     */
    public deleteVolumeAttachment(param: StorageV1alpha1ApiDeleteVolumeAttachmentRequest, options?: Configuration): Promise<V1alpha1VolumeAttachment> {
        return this.api.deleteVolumeAttachment(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: StorageV1alpha1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: StorageV1alpha1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listCSIStorageCapacityForAllNamespacesWithHttpInfo(param: StorageV1alpha1ApiListCSIStorageCapacityForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1alpha1CSIStorageCapacityList>> {
        return this.api.listCSIStorageCapacityForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listCSIStorageCapacityForAllNamespaces(param: StorageV1alpha1ApiListCSIStorageCapacityForAllNamespacesRequest = {}, options?: Configuration): Promise<V1alpha1CSIStorageCapacityList> {
        return this.api.listCSIStorageCapacityForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1alpha1ApiListNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1alpha1CSIStorageCapacityList>> {
        return this.api.listNamespacedCSIStorageCapacityWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listNamespacedCSIStorageCapacity(param: StorageV1alpha1ApiListNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1alpha1CSIStorageCapacityList> {
        return this.api.listNamespacedCSIStorageCapacity(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind VolumeAttachment
     * @param param the request object
     */
    public listVolumeAttachmentWithHttpInfo(param: StorageV1alpha1ApiListVolumeAttachmentRequest = {}, options?: Configuration): Promise<HttpInfo<V1alpha1VolumeAttachmentList>> {
        return this.api.listVolumeAttachmentWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind VolumeAttachment
     * @param param the request object
     */
    public listVolumeAttachment(param: StorageV1alpha1ApiListVolumeAttachmentRequest = {}, options?: Configuration): Promise<V1alpha1VolumeAttachmentList> {
        return this.api.listVolumeAttachment(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified CSIStorageCapacity
     * @param param the request object
     */
    public patchNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1alpha1ApiPatchNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1alpha1CSIStorageCapacity>> {
        return this.api.patchNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CSIStorageCapacity
     * @param param the request object
     */
    public patchNamespacedCSIStorageCapacity(param: StorageV1alpha1ApiPatchNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1alpha1CSIStorageCapacity> {
        return this.api.patchNamespacedCSIStorageCapacity(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified VolumeAttachment
     * @param param the request object
     */
    public patchVolumeAttachmentWithHttpInfo(param: StorageV1alpha1ApiPatchVolumeAttachmentRequest, options?: Configuration): Promise<HttpInfo<V1alpha1VolumeAttachment>> {
        return this.api.patchVolumeAttachmentWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified VolumeAttachment
     * @param param the request object
     */
    public patchVolumeAttachment(param: StorageV1alpha1ApiPatchVolumeAttachmentRequest, options?: Configuration): Promise<V1alpha1VolumeAttachment> {
        return this.api.patchVolumeAttachment(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified CSIStorageCapacity
     * @param param the request object
     */
    public readNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1alpha1ApiReadNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1alpha1CSIStorageCapacity>> {
        return this.api.readNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CSIStorageCapacity
     * @param param the request object
     */
    public readNamespacedCSIStorageCapacity(param: StorageV1alpha1ApiReadNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1alpha1CSIStorageCapacity> {
        return this.api.readNamespacedCSIStorageCapacity(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified VolumeAttachment
     * @param param the request object
     */
    public readVolumeAttachmentWithHttpInfo(param: StorageV1alpha1ApiReadVolumeAttachmentRequest, options?: Configuration): Promise<HttpInfo<V1alpha1VolumeAttachment>> {
        return this.api.readVolumeAttachmentWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified VolumeAttachment
     * @param param the request object
     */
    public readVolumeAttachment(param: StorageV1alpha1ApiReadVolumeAttachmentRequest, options?: Configuration): Promise<V1alpha1VolumeAttachment> {
        return this.api.readVolumeAttachment(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified CSIStorageCapacity
     * @param param the request object
     */
    public replaceNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1alpha1ApiReplaceNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1alpha1CSIStorageCapacity>> {
        return this.api.replaceNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified CSIStorageCapacity
     * @param param the request object
     */
    public replaceNamespacedCSIStorageCapacity(param: StorageV1alpha1ApiReplaceNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1alpha1CSIStorageCapacity> {
        return this.api.replaceNamespacedCSIStorageCapacity(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified VolumeAttachment
     * @param param the request object
     */
    public replaceVolumeAttachmentWithHttpInfo(param: StorageV1alpha1ApiReplaceVolumeAttachmentRequest, options?: Configuration): Promise<HttpInfo<V1alpha1VolumeAttachment>> {
        return this.api.replaceVolumeAttachmentWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified VolumeAttachment
     * @param param the request object
     */
    public replaceVolumeAttachment(param: StorageV1alpha1ApiReplaceVolumeAttachmentRequest, options?: Configuration): Promise<V1alpha1VolumeAttachment> {
        return this.api.replaceVolumeAttachment(param.name, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableStorageV1beta1Api } from "./ObservableAPI";
import { StorageV1beta1ApiRequestFactory, StorageV1beta1ApiResponseProcessor} from "../apis/StorageV1beta1Api";

export interface StorageV1beta1ApiCreateNamespacedCSIStorageCapacityRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1beta1ApicreateNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * 
     * @type V1beta1CSIStorageCapacity
     * @memberof StorageV1beta1ApicreateNamespacedCSIStorageCapacity
     */
    body: V1beta1CSIStorageCapacity
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApicreateNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApicreateNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1beta1ApicreateNamespacedCSIStorageCapacity
     */
    fieldManager?: string
}

export interface StorageV1beta1ApiDeleteCollectionNamespacedCSIStorageCapacityRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    gracePeriodSeconds?: number
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1beta1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    body?: V1DeleteOptions
}

export interface StorageV1beta1ApiDeleteNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * @type string
     * @memberof StorageV1beta1ApideleteNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1beta1ApideleteNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApideleteNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApideleteNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1beta1ApideleteNamespacedCSIStorageCapacity
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1beta1ApideleteNamespacedCSIStorageCapacity
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1beta1ApideleteNamespacedCSIStorageCapacity
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1beta1ApideleteNamespacedCSIStorageCapacity
     */
    body?: V1DeleteOptions
}

export interface StorageV1beta1ApiGetAPIResourcesRequest {
}

export interface StorageV1beta1ApiListCSIStorageCapacityForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApilistCSIStorageCapacityForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApilistCSIStorageCapacityForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistCSIStorageCapacityForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistCSIStorageCapacityForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApilistCSIStorageCapacityForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApilistCSIStorageCapacityForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistCSIStorageCapacityForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistCSIStorageCapacityForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApilistCSIStorageCapacityForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApilistCSIStorageCapacityForAllNamespaces
     */
    watch?: boolean
}

export interface StorageV1beta1ApiListNamespacedCSIStorageCapacityRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1beta1ApilistNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApilistNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApilistNamespacedCSIStorageCapacity
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApilistNamespacedCSIStorageCapacity
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistNamespacedCSIStorageCapacity
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistNamespacedCSIStorageCapacity
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApilistNamespacedCSIStorageCapacity
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistNamespacedCSIStorageCapacity
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistNamespacedCSIStorageCapacity
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApilistNamespacedCSIStorageCapacity
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApilistNamespacedCSIStorageCapacity
     */
    watch?: boolean
}

export interface StorageV1beta1ApiPatchNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * @type string
     * @memberof StorageV1beta1ApipatchNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1beta1ApipatchNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof StorageV1beta1ApipatchNamespacedCSIStorageCapacity
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApipatchNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApipatchNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1beta1ApipatchNamespacedCSIStorageCapacity
     */
    fieldManager?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1beta1ApipatchNamespacedCSIStorageCapacity
     */
    force?: boolean
}

export interface StorageV1beta1ApiReadNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * @type string
     * @memberof StorageV1beta1ApireadNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1beta1ApireadNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApireadNamespacedCSIStorageCapacity
     */
    pretty?: string
}

export interface StorageV1beta1ApiReplaceNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * @type string
     * @memberof StorageV1beta1ApireplaceNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof StorageV1beta1ApireplaceNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * 
     * @type V1beta1CSIStorageCapacity
     * @memberof StorageV1beta1ApireplaceNamespacedCSIStorageCapacity
     */
    body: V1beta1CSIStorageCapacity
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApireplaceNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApireplaceNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1beta1ApireplaceNamespacedCSIStorageCapacity
     */
    fieldManager?: string
}

export class ObjectStorageV1beta1Api {
    private api: ObservableStorageV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: StorageV1beta1ApiRequestFactory, responseProcessor?: StorageV1beta1ApiResponseProcessor) {
        this.api = new ObservableStorageV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a CSIStorageCapacity
     * @param param the request object
     */
    public createNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1beta1ApiCreateNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1beta1CSIStorageCapacity>> {
        return this.api.createNamespacedCSIStorageCapacityWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * create a CSIStorageCapacity
     * @param param the request object
     */
    public createNamespacedCSIStorageCapacity(param: StorageV1beta1ApiCreateNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1beta1CSIStorageCapacity> {
        return this.api.createNamespacedCSIStorageCapacity(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * delete collection of CSIStorageCapacity
     * @param param the request object
     */
    public deleteCollectionNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1beta1ApiDeleteCollectionNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedCSIStorageCapacityWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSIStorageCapacity
     * @param param the request object
     */
    public deleteCollectionNamespacedCSIStorageCapacity(param: StorageV1beta1ApiDeleteCollectionNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedCSIStorageCapacity(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a CSIStorageCapacity
     * @param param the request object
     */
    public deleteNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1beta1ApiDeleteNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CSIStorageCapacity
     * @param param the request object
     */
    public deleteNamespacedCSIStorageCapacity(param: StorageV1beta1ApiDeleteNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1Status> {
        return this.api.deleteNamespacedCSIStorageCapacity(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: StorageV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: StorageV1beta1ApiGetAPIResourcesRequest = {}, options?: Configuration): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listCSIStorageCapacityForAllNamespacesWithHttpInfo(param: StorageV1beta1ApiListCSIStorageCapacityForAllNamespacesRequest = {}, options?: Configuration): Promise<HttpInfo<V1beta1CSIStorageCapacityList>> {
        return this.api.listCSIStorageCapacityForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listCSIStorageCapacityForAllNamespaces(param: StorageV1beta1ApiListCSIStorageCapacityForAllNamespacesRequest = {}, options?: Configuration): Promise<V1beta1CSIStorageCapacityList> {
        return this.api.listCSIStorageCapacityForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1beta1ApiListNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1beta1CSIStorageCapacityList>> {
        return this.api.listNamespacedCSIStorageCapacityWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listNamespacedCSIStorageCapacity(param: StorageV1beta1ApiListNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1beta1CSIStorageCapacityList> {
        return this.api.listNamespacedCSIStorageCapacity(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified CSIStorageCapacity
     * @param param the request object
     */
    public patchNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1beta1ApiPatchNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1beta1CSIStorageCapacity>> {
        return this.api.patchNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CSIStorageCapacity
     * @param param the request object
     */
    public patchNamespacedCSIStorageCapacity(param: StorageV1beta1ApiPatchNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1beta1CSIStorageCapacity> {
        return this.api.patchNamespacedCSIStorageCapacity(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.force,  options).toPromise();
    }

    /**
     * read the specified CSIStorageCapacity
     * @param param the request object
     */
    public readNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1beta1ApiReadNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1beta1CSIStorageCapacity>> {
        return this.api.readNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CSIStorageCapacity
     * @param param the request object
     */
    public readNamespacedCSIStorageCapacity(param: StorageV1beta1ApiReadNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1beta1CSIStorageCapacity> {
        return this.api.readNamespacedCSIStorageCapacity(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified CSIStorageCapacity
     * @param param the request object
     */
    public replaceNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1beta1ApiReplaceNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<HttpInfo<V1beta1CSIStorageCapacity>> {
        return this.api.replaceNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

    /**
     * replace the specified CSIStorageCapacity
     * @param param the request object
     */
    public replaceNamespacedCSIStorageCapacity(param: StorageV1beta1ApiReplaceNamespacedCSIStorageCapacityRequest, options?: Configuration): Promise<V1beta1CSIStorageCapacity> {
        return this.api.replaceNamespacedCSIStorageCapacity(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager,  options).toPromise();
    }

}

import { ObservableVersionApi } from "./ObservableAPI";
import { VersionApiRequestFactory, VersionApiResponseProcessor} from "../apis/VersionApi";

export interface VersionApiGetCodeRequest {
}

export class ObjectVersionApi {
    private api: ObservableVersionApi

    public constructor(configuration: Configuration, requestFactory?: VersionApiRequestFactory, responseProcessor?: VersionApiResponseProcessor) {
        this.api = new ObservableVersionApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get the code version
     * @param param the request object
     */
    public getCodeWithHttpInfo(param: VersionApiGetCodeRequest = {}, options?: Configuration): Promise<HttpInfo<VersionInfo>> {
        return this.api.getCodeWithHttpInfo( options).toPromise();
    }

    /**
     * get the code version
     * @param param the request object
     */
    public getCode(param: VersionApiGetCodeRequest = {}, options?: Configuration): Promise<VersionInfo> {
        return this.api.getCode( options).toPromise();
    }

}

import { ObservableWellKnownApi } from "./ObservableAPI";
import { WellKnownApiRequestFactory, WellKnownApiResponseProcessor} from "../apis/WellKnownApi";

export interface WellKnownApiGetServiceAccountIssuerOpenIDConfigurationRequest {
}

export class ObjectWellKnownApi {
    private api: ObservableWellKnownApi

    public constructor(configuration: Configuration, requestFactory?: WellKnownApiRequestFactory, responseProcessor?: WellKnownApiResponseProcessor) {
        this.api = new ObservableWellKnownApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get service account issuer OpenID configuration, also known as the \'OIDC discovery doc\'
     * @param param the request object
     */
    public getServiceAccountIssuerOpenIDConfigurationWithHttpInfo(param: WellKnownApiGetServiceAccountIssuerOpenIDConfigurationRequest = {}, options?: Configuration): Promise<HttpInfo<string>> {
        return this.api.getServiceAccountIssuerOpenIDConfigurationWithHttpInfo( options).toPromise();
    }

    /**
     * get service account issuer OpenID configuration, also known as the \'OIDC discovery doc\'
     * @param param the request object
     */
    public getServiceAccountIssuerOpenIDConfiguration(param: WellKnownApiGetServiceAccountIssuerOpenIDConfigurationRequest = {}, options?: Configuration): Promise<string> {
        return this.api.getServiceAccountIssuerOpenIDConfiguration( options).toPromise();
    }

}
